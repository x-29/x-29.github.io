<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>计算机网络(Computer Networking)笔记(二) - CS里的X-29</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="计算机网络(Computer Networking: A Top-Down Approach)学习笔记（第二部分）." />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="计算机网络(Computer Networking)笔记(二)" />
<meta property="og:description" content="计算机网络(Computer Networking: A Top-Down Approach)学习笔记（第二部分）." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://x-29.github.io/post/2022-05-computer-networking-notes-part2/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-05-25T08:59:38+08:00" />
<meta property="article:modified_time" content="2022-05-25T08:59:38+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="计算机网络(Computer Networking)笔记(二)"/>
<meta name="twitter:description" content="计算机网络(Computer Networking: A Top-Down Approach)学习笔记（第二部分）."/>
<script src="https://x-29.github.io/js/feather.min.js"></script>
	
	
        <link href="https://x-29.github.io/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://x-29.github.io/css/main.40ca3a860425083862b7ebd55447caec5c4384573f0cb098b8d06a91e8dace2e.css" />
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://x-29.github.io/">CS里的X-29</a>
	</div>
	<nav>
		
		<a href="/">首页</a>
		
		<a href="/post">文章</a>
		
		<a href="/about">关于</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">计算机网络(Computer Networking)笔记(二)</h1>
			<div class="meta">Posted on May 25, 2022</div>
		</div>
		

		<section class="body">
			<p>这是<a href="https://book.douban.com/subject/26176870/">《计算机网络自顶向下方法 第6版》</a>一书的读书笔记的第二部分。</p>
<p><a href="../2022-05-computer-networking-notes">第一部分</a></p>
<h2 id="四-网络层">四 网络层</h2>
<p><em>网络层怎样实现主机到主机的通信服务？</em></p>
<blockquote>
<p>在网络中的每一台主机和路由器中都有一个网络层。</p>
</blockquote>
<h3 id="转发和路由">转发和路由</h3>
<p>网络层的作用是将分组从一台发送主机转移到一台接收主机。为此，需要两种重要的网络功能：</p>
<ul>
<li>转发。将分组从路由器的输入链路移动到相应的输出链路。转发发生的时间尺度很短（通常为几纳秒），通常用硬件实现。</li>
<li>路由选择。决定分组从源到目的地的路由或路径。路由选择发生的时间尺度长一些（通常为几秒），通常用软件实现。计算路径的算法称为路由选择算法。</li>
</ul>
<p>用驾驶的例子类比，转发就像是通过单个立交桥的过程：驾驶员驾车从道路上进入立交桥的一个入口，并决定应当从哪个出口离开立交桥。路由选择可以看作是规划行程的过程：在开启行程之前，驾驶员查阅地图并在许多可能的路径中选择一条，其中每条路径都是由一系列经立交桥连接的路段组成。</p>
<hr>
<p>每台路由器中都有一张本地<strong>转发表</strong>（forwarding table）。路由器检查到达分组首部的一个或多个字段值，进而使用这些首部值在其转发表中索引查询。转发表中对应的表项指出了该分组将被转发的路由器的输出链路接口。</p>
<figure><img src="/images/per-router-control-plane.jpg" width="600"/>
</figure>

<p>如图，一个首部值字段值为 0111 的分组到达路由器。路由器在它的转发表中索引，并确定该分组的输出链路接口是接口 2。然后路由器在内部将分组转发到接口 2。</p>
<h3 id="网络服务模型">网络服务模型</h3>
<blockquote>
<p>网络服务模型（networ service model）定义了分组在发送与接收端系统之间的端到端运输特性。</p>
</blockquote>
<p>因特网的网络层提供了单一的服务，即尽力而为服务（best-effort service）。使用尽力而为服务：</p>
<ul>
<li>既不能保证传送的分组以它们发送的顺序被接收，也不能保证它们最终交付。</li>
<li>既不能保证端到端时延，也不能保证有最小的带宽。</li>
</ul>
<hr>
<p><strong>分组交换机</strong>是指一台通用分组交换设备，它根据分组首部字段中的值，从输入链路接口到输出链路接口转移分组。分组交换机主要有两类：</p>
<ul>
<li>链路层交换机（link-layer switches）。基于链路层字段中的值做转发决定。</li>
<li>路由器（router）。基于网络层字段中的值做转发决定。</li>
</ul>
<h3 id="路由器工作原理">路由器工作原理</h3>
<figure><img src="/images/router-architecture-overview.jpg"
         alt="路由器体系结构" width="600"/><figcaption>
            <p>路由器体系结构</p>
        </figcaption>
</figure>

<p>如上图，一台路由器由 4 个部分组成：</p>
<ul>
<li>输入端口（input ports）</li>
<li>交换结构（switching fabric）</li>
<li>输出端口（output ports）</li>
<li>路由选择处理器（routing processor）</li>
</ul>
<p>路由器的输入端口、输出端口和交换结构几乎总是用硬件实现。它们共同实现了转发功能。</p>
<p><strong>1. 输入端口</strong></p>
<figure><img src="/images/router-input-port-processing.jpg"
         alt="输入端口处理" width="600"/><figcaption>
            <p>输入端口处理</p>
        </figcaption>
</figure>

<p>输入端口的线路端接（line termination）功能与链路层处理（link-layer processing）实现了用于各个输入链路的物理层和链路层。</p>
<p>在输入端口执行的查找（lookup，图中红色框）是路由器操作的核心。正是在这里，路由器使用转发表来查找输出端口，使得到达的分组能经过交换结构（switch fabric）转发到该输出端口 。</p>
<p><strong>2. 交换结构</strong></p>
<p>交换结构位于一台路由器的核心部位。负责将分组从一个输入端口交换（即转发）到一个输出端口。</p>
<p>交换结构有很多种，最主要的 3 种是：</p>
<figure><img src="/images/3-types-switching-fabric.jpg"
         alt="三种交换技术"/><figcaption>
            <p>三种交换技术</p>
        </figcaption>
</figure>

<ul>
<li>经内存交换（memory）
<ul>
<li>输入端口与输出端口间的交换在 CPU（路由选择处理器）的直接控制下完成。一个分组到达一个输入端口时先被复制到处理器内存中，然后路由选择处理器提取分组首部字段，在转发表中找到适当的输出端口，并把分组复制到输出端口的缓存中。</li>
<li>转发速度受到内存带宽的限制，每个分组需要经过两次共享系统总线。</li>
</ul>
</li>
<li>经总线交换（bus）
<ul>
<li>输入端口经一根共享总线将分组直接传送到输出端口，不需要路由选择处理器的干预。</li>
<li>转发速度受到总线带宽的限制</li>
</ul>
</li>
<li>经互联网络交换（interconnection network）
<ul>
<li>使用了一种由 2N 条总线组成的互联网络，连接 N 输入端口与 N 个输出端口。这种纵横式网络能够并行转发多个分组。<strong>如果两个不同输入端口的两个分组的目的地时相同的输出端口，则一个分组必须在输入端等待，因为在某个时刻经给定总线仅有一个分组能够发送</strong>。</li>
<li>更为复杂的互联网络使用多级交换，以使来自不同输入端口的分组通过交换结构同时朝着相同的输出端口前行。</li>
<li>路由器的交换能力也能够通过并行运行多种交换结构进行扩展。
<ul>
<li>在这种方法中，输入端口和输出端口被连接到并行运行的 N 个交换结构 。</li>
<li>一个输入端口将一个分组分成 K 个较小的块，并且通过 N 个交换结构中的 K 个来发送这些块到所选择的输出端口，输出端口再将 K 个块装配还原成初始的分组。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>3. 输出端口</strong></p>
<p>输出端口处理（如图所示）获取存储在输出端口内存中的分组（数据包），并通过输出链路传输它们。这包括选择（即，调度）和取出排队的分组，以及执行所需的链路层和物理层传输功能。</p>
<figure><img src="/images/router-output-port-processing.jpg"
         alt="输出端口处理" width="600"/><figcaption>
            <p>输出端口处理</p>
        </figcaption>
</figure>

<p>如果分组到达的速率比链路传输的速率快时，分组就会在缓存中排队。一旦缓存满了就会丢弃分组，也就是出现丢包。</p>
<h4 id="输入端口和输出端口排队">输入端口和输出端口排队</h4>
<p>如果交换结构传送速率比分组到达输入端口的速率慢，那么在输入端口将会出现分组排队。</p>
<ul>
<li>这会产生排队时延，一旦输入端口的缓存溢出就会出现丢包。</li>
<li>存在线路前部阻塞（Head-Of-the-Line, HOL) 现象，即在队列前面排队的分组阻塞队列中的其它分组向前移动。</li>
</ul>
<figure><img src="/images/hol-blocking-at-input-queued-switch.jpg"
         alt="在输入排队交换机中的 HOL 阻塞"/><figcaption>
            <p>在输入排队交换机中的 HOL 阻塞</p>
        </figcaption>
</figure>

<p>如图，在两个输入端口队列前端的两个分组（红色）要发往同一个右上角的输出端口，假定交换结构决定发送左上角队列前端的分组，那么左下角队列中的红色分组就必须等待（同一个输出端口，交换结构一次只能传送一个分组到端口）。不仅它要等待，排在它后面的绿色分组也要等待，即使右下角的输出端口中无竞争。这种现象叫做输入排队交换机中的<strong>线路前部（Head-Of-the-Line，HOL）阻塞</strong>。</p>
<hr>
<p>如果交换结构传送分组的速率比输出链路传输的速率快时，分组就会在输出端口的缓存中排队。</p>
<ul>
<li>排队会带来时延，并且一旦队列满了分组就可能会被丢弃，也就是出现丢包。</li>
<li>调度规则，决定在排队的分组中选择哪个分组进行传输。</li>
</ul>
<figure><img src="/images/output-port-queueing.jpg"
         alt="输出端口排队"/><figcaption>
            <p>输出端口排队</p>
        </figcaption>
</figure>

<p>如图，在时刻<em>t</em>，每个输入端口都到达了一个分组，其中有两个分组是发往最上侧的输出端口，一个单位时间（即接送或发送一个分组所需的时间，也就是分组时间）之后，这两个分组都被传送到输出端口，并排队等待传输到输出链路上。由于输出端口在一个单位时间内只能发送一个分组，在下一个时间单位中，这 2 个分组中的一个将通过输出链路发送出去。具体是哪一个由分组调度规则决定。</p>
<h3 id="网际协议">网际协议</h3>
<p>因特网的网络层有 3 个主要组件：</p>
<ul>
<li>IP 协议</li>
<li>路由选择</li>
<li>因特网控制报文协议（ICMP）</li>
</ul>
<figure><img src="/images/network-layer-view.jpg"
         alt="因特网网络层的内部视图" width="600"/><figcaption>
            <p>因特网网络层的内部视图</p>
        </figcaption>
</figure>

<p>IP 协议有两个版本：IPv4 和 IPv6。</p>
<h4 id="ipv4-数据报格式">IPv4 数据报格式</h4>
<figure><img src="/images/ipv4-datagram-format.jpg"
         alt="IPv4 数据报格式"/><figcaption>
            <p>IPv4 数据报格式</p>
        </figcaption>
</figure>

<p>IPv4 数据报中的关键字段：</p>
<ul>
<li><em>版本(Version)</em>。长度为 4 bit，规定了数据报的 IP 协议版本。通过查看协议版本，路由器能够确定如何解释 IP 数据报的剩余部分。</li>
<li><em>首部长度（Header length）</em>。由于一个 IPv4 数据报可以包含一些可变数量的选项（options）。因此需要 4 bit 来确定数据报中的数据（payload data）部分实际从哪里开始。大多数 IP 数据报不包含选项，所以一般的 IP 数据报的首部为 20 字节。</li>
<li><em>服务类型（Type of service）</em>。以便路由器为不同类型的 IP 数据报提供不同等级的服务。</li>
<li><em>数据报长度（Datagram length）</em>。这是 IP 数据报的总长度（首部 + 数据），由于其长度为 16 bit，所以 IP 数据报的理论最大长度为 65,535 字节。然而，数据报很少有超过 1500 字节的。</li>
<li><em>标识（Identifier）、标志（flags）、 片偏移（fragmentation offset）</em>。这三个字段与所谓的 IP 分片有关，即一个大的 IP数据报被分成几个较小的 IP 数据报，然后这些较小的 IP 数据报被独立地转发到目的地，在目的地，这些较小的 IP 数据报被重新组装，然后它们的有效负载数据被向上传递到目的地主机的传输层。</li>
<li><em>寿命（Time-To-Live，TTL）</em>。用来确定数据报不会永远（如由于长时间的路由选择环路）在网络中循环。每当数据报由一台路由器处理时，TTL 字段的值就会减 1。若 TTL 字段减为 0，则该数据报必须丢弃。</li>
<li><em>协议（Protocol）</em>。该字段仅在一个 IP 数据报到达其最终目的地才会有用。它的值指示数据报的数据部分应该交给哪个运输层协议。例如，值为 6 表明数据部分交给 TCP，值为 17 表明数据要交给 UDP。<strong>这个字段的作用类似于运输层报文段中端口号字段所起的作用。协议号是将网络层与运输层绑定的粘合剂，而端口号是将运输层和应用层绑定到一起的粘合剂</strong>。</li>
<li><em>首部校验和（Header checksum）</em>。用于路由器检测 IP 数据报中的位错误。
<ul>
<li>首部校验和的计算是将首部中的 2 个字节当作一个数，用反码运算对这些数求和，再将该和的反码存放在校验和字段中。</li>
<li>路由器一般会丢弃检测出错误的数据报。</li>
<li>在每台路由器上必须重新计算校验和并再次存放到校验和字段中，因为 TTL 字段以及可能的选择字段会改变。</li>
</ul>
</li>
<li><em>源和目的 IP 地址（Source and destination IP addresses）</em>。当某个源生成一个数据报时，它在源 IP 字段中插入自己的 IP 地址，在目的 IP 地址字段中插入数据报送往的最终目的地的地址。通常源主机通过 DNS 查找来决定目的地的地址。</li>
<li><em>选项（options）</em>。用于扩张 IP 首部，很少使用，在 IPv6 首部中已经去掉。</li>
<li><em>数据（有效载荷，payload data）</em>。数据字段包含要交付给目的地的运输层报文段（TCP 或 UDP），当然，数据字段也可以承载其他类型的数据，如 ICMP 报文段。</li>
</ul>
<blockquote>
<p>一个 IP 数据报的首部总长为 20 字节（假设无选项）。如果数据报承载一个 TCP 报文段，则每个数据报共承载了总长 40 字节的首部（20 字节的 IP 首部 + 20 字节的 TCP 首部）以及应用层报文。</p>
</blockquote>
<h4 id="ipv4-编址">IPv4 编址</h4>
<p>IP 要求每台主机和路由器拥有自己的 IP 地址。</p>
<ul>
<li><strong>IP 地址</strong>是与每台主机或路由器<strong>接口</strong>相关联的 32 位标识符。</li>
<li>接口是主机/路由器与物理链路之间的边界（连接）。
<ul>
<li>一台路由器通常有多个接口，每个接口有自己的链路。</li>
<li>一台主机通常是一个或两个接口（例如，有线以太网、无线802.11）</li>
</ul>
</li>
<li>每个 IP 地址的长度为 32 位（也就是 4 字节），因此总共有 2^32 个可能的 IP 地址。</li>
<li>IP 地址一般用点分十进制记法（dotted-decimal notation）表示，即地址中的每个字节用它的十进制形式表示，各字节之间用句点（.）隔开。例如：<code>223.1.1.1</code>。如果用二进制记法表示这个 IP 地址就是：<code>11011111 00000001 00000001 00000001</code>，用十六进制记法表示就是：<code>0xdf010101</code>。</li>
</ul>
<figure><img src="/images/interface-addresses-and-subnets.jpg"
         alt="接口地址和子网"/><figcaption>
            <p>接口地址和子网</p>
        </figcaption>
</figure>

<p>在全球因特网中的每台主机和路由器上的每个接口，必须有一个全球唯一的 IP 地址（在 NAT 后面的接口除外），这些地址不能随意地自由选择，一个接口的 IP 地址的一部分需要由其连接的<strong>子网</strong>来决定。</p>
<p>什么是子网？</p>
<ul>
<li>子网，不需要通过中间路由器就可以在物理上连接到彼此的设备接口。</li>
<li>要确定子网，需要分开主机和路由器的接口，从而产生隔离的网络孤岛。每个隔离的网络称为<strong>子网（subnet）</strong>。如上图，有 3 个子网，分别是（223.1.1.1, 223.1.1.2, 223.1.1.3, 223.1.1.4)、(223.1.2.1, 223.1.2.9, 223.1.2.2)、(223.1.3.1, 223.1.3.2, 223.1.3.27)。</li>
</ul>
<p>因特网的地址分配策略称为<strong>无类别域间路由选择</strong>(Classless Interdomain Routing，CIDR)，CIDR 将 IP 地址划分成两个部分：</p>
<ul>
<li>子网部分。高 <em>x</em> 位，也称为网络地址或网络号，同一子网中的设备的网络地址是相同的。</li>
<li>主机部分。剩余的低位，也称为主机地址或主机号。</li>
</ul>
<figure><img src="/images/cidr-ip-addressing.jpg" width="600"/>
</figure>

<p>采用点分十进制数形式 <code>a.b.c.d/x</code> 表示，其中 <em>x</em> 是地址中子网部分的位数。一个地址剩余的 <code>32 - x</code> 位属于主机部分。<code>/x</code>的记法也称为子网掩码（subnet mask），例如 140.252.20.68/24，表示 IP 地址为 140.252.20.68，子网掩码的高 24 位是 1，也就是 255.255.255.0，IP 地址与子网掩码做与运算可以得到网络地址。网络地址相同的主机属于同一个网段，互相之间可以直接通信，网络地址不同的主机之间通信需要经过路由器转发。</p>
<p>通过这样划分，多个子网就可以汇总（summarize）成一个因特网上的网络，例如，有 8 个组织（每个组织有自己的子网）通过同一个 ISP 连到因特网上，它们 IP 地址的高 21 位是相同的（也就是网络地址相同），只有低 3 位不同，这 8 个组织就可以汇总，在因特网上只需要一个路由表项，数据包通过因特网上的路由器到达 ISP，然后在 ISP 再通过次级的路由器选路到某个组织。</p>
<hr>
<p>主机有两种方法可以获得 IP 地址（主机地址/主机部分）：</p>
<ul>
<li>通过系统管理员手工配置，把地址硬编码在配置文件中，如：Unix 系统的 /etc/rc.config。</li>
<li>使用动态主机配置协议（Dynamic Host Configuration Protocol, DHCP），从服务器动态获取一个地址。</li>
</ul>
<p>如今，更多的是使用 DHCP 协议。DHCP 协议也称为即插即用协议（plug-and-play），其目标是使得主机在加入到网络中时，能够动态地从网络服务器获得一个 IP 地址。</p>
<p>通过 DHCP 协议获取一个 IP 地址的过程：</p>
<ul>
<li>新加入到网络中的主机，首先广播一个条 <code>DHCP 发现报文</code>(DHCP discover message)，找到 DHCP 服务器。</li>
<li>服务器收到 DHCP 发现报文后，在子网中广播一个条 <code>DHCP 提供报文</code>（DHCP offer message）。因为在一个子网中可能存在多个 DHCP 服务器，所以在子网内广播，而不是直接发送给主机。报文中包含有向主机推荐的 IP 地址，子网掩码以及 IP 租用期。</li>
<li>主机从一个或多个服务器选择一个，并向选中的 DHCP 服务器回应 <code>DHCP 请求报文</code>（DHCP request message)，请求使用服务器提供的 IP 地址。</li>
<li>服务器用 DHCP ACK 报文，响应主机的 <code>DHCP 请求报文</code>，以确认主机的请求。</li>
</ul>
<figure><img src="/images/DHCP-client-server-interaction.jpg"
         alt="DHCP 客户-服务器交互"/><figcaption>
            <p>DHCP 客户-服务器交互</p>
        </figcaption>
</figure>

<p>除了 IP 地址之外，DHCP 还允许主机获得更多的信息，例如：</p>
<ul>
<li>它的子网掩码</li>
<li>它的第一跳路由器地址</li>
<li>它的本地 DNS 服务器的地址</li>
</ul>
<hr>
<p>网络地址（IP 地址的子网部分）是一个组织从已分配给 ISP 的地址空间中分配而来的。假设 ISP 已经被分配了一块地址（200.23.16.0/20） ，它可以将这块地址分成 8 个长度相等的连续地址块，每一个地址块可以分配给一个组织。</p>
<figure><img src="/images/isp-block.jpg" width="600"/>
</figure>

<p>上图中，地址中加了下划线的部分是网络地址。</p>
<p>而 ISP 本身是通过非营利的 ICANN 组织获得地址块的。</p>
<h4 id="nat-网络地址转换">NAT 网络地址转换</h4>
<p>随着越来越多的组织和家庭接入因特网，可供分配的 IP 地址会越来越少，实际上在 2011 年 ICANN 已经把最后一块 IP 地址分配出去了。应对 IP 地址短缺的方法，一种是使用网络地址转换（Network Address Translation, NAT）技术，另一种就是使用 IPv6。</p>
<p>一个组织或家庭内部组建局域网，IP 地址只用于局域网内的通信，而不直接连接到因特网上，理论上使用任意的 IP 地址都可以，但是 「RFC 1918」规定了用于组建局域网的<code>私有 IP 地址</code>，这些地址不会出现在因特网上，如下所示：</p>
<ul>
<li>10.*，前 8 位是网络地址，共16,777,216个地址</li>
<li>172.16.* 到 172.31.*，前12位是网络地址，共 1,048,576 个地址</li>
<li>192.168.*，前 16 位是网络地址，共 65,536 个地址</li>
</ul>
<p>使用<code>私有 IP 地址</code>的局域网主机发送报文到因特网上或从因特网上接收报文，要通过 NAT 路由器进行地址转换。对外界而言，NAT 路由器就像是具有单一 IP 地址的单一设备，局域网中的所有设备共享这一个 IPv4 地址。这样做的好处是：</p>
<ul>
<li>对所有设备，只需要从提供商 ISP 获得一个 IP 地址。</li>
<li>更改本地网络中主机的地址无需通知外界。</li>
<li>更换 ISP 无需改变本地网络中设备的地址。</li>
<li>局域网中的设备对外界不可见，不能直接寻址。</li>
</ul>
<p>NAT 路由器透明的实现地址转换：</p>
<ul>
<li>传出数据报：将每个传出数据报的（源IP地址，端口号）替换为（NAT IP地址，新端口号）。
<ul>
<li>远程客户端/服务器将使用（NAT IP地址，新端口号）作为目标地址进行响应。</li>
</ul>
</li>
<li>在 NAT 转换表中记录每个（源IP地址，端口号）到（NAT IP地址，新端口号）转换关系。</li>
<li>传入数据报：用存储在 NAT 表中的相应（源IP地址，端口号）替换每个传入数据报的目的地字段中的（NAT IP地址，新端口号）。</li>
</ul>
<figure><img src="/images/network-address-translation.jpg"
         alt="网络地址转换"/><figcaption>
            <p>网络地址转换</p>
        </figcaption>
</figure>

<p>如上图，局域网内的主机 10.0.0.1 向因特网上 IP 地址为 128.119.40.186 的 Web 服务器（端口 80）请求一个页面。主机 10.0.0.1 为其报文指派了源端口号 3345 并将数据报发送到局域网中。NAT 路由器收到该数据报，为该数据报生成一个新的端口 5001（可选择任意一个当前未在 NAT 转换表中的源端口号），将源 IP 地址替代为其广域网一侧接口的 IP 地址（如：138.76.29.7）。路由器中的 NAT 也在它的 NAT 转换表中增加一条表项。 Web 服务器并不知道刚到达的包含 HTTP 请求的数据报已被 NAT 路由器进行了改装。它会发回一个响应报文，其目的地址是 NAT 路由器的  IP 地址，其目的端口是5001。当该报文到达 NAT 路由器时，路由器使用目的 IP 地址与目的端口号从 NAT 转换表中检索出局域网主机使用的 IP 地址(10. 0. 0. 1)和目的端口号 (3345)。于是，路由器重写该数据报的目的 IP 地址 与目的端口号，并向局域网主机转发该数据报。</p>
<p>NAT 一直存在争议，比如路由器“应该”最多只能处理第3层(网络层的数据报)、由 IPv6 解决地址短缺问题、NAT 穿越等，但 NAT 将继续存在，并广泛应用于家庭和机构网络、4G/5G 蜂窝网络。</p>
<h4 id="ipv6">IPv6</h4>
<p>IPv6 最初的动机是解决 IPv4 地址空间不足的问题，另外也带来了一些新的变化。</p>
<p>IPv6 中引入的最重要的变化显示在其数据报格式中：</p>
<ul>
<li>地址容量扩大了。IPv6 将 IP 地址的长度从 32 位扩大到了 128 位。这就确保将不会用尽 IP 地址。</li>
<li>40 字节定长首部。舍弃了多个 IPv4 首部字段，形成 40 字节定长首部允许路由器更快地处理 IP 数据报。</li>
<li>流标签（flow label）。用于“给属于特殊流的分组加上标签，这些特殊流是发送方要求进行特殊处理的流，如一种非默认服务质量或需要实时服务的流”。</li>
</ul>
<figure><img src="/images/ipv6-datagram-format.jpg"
         alt="IPv6 数据报格式"/><figcaption>
            <p>IPv6 数据报格式</p>
        </figcaption>
</figure>

<p>IPv6 数据报结构更简单、更高效。与 IPv4 相比较：</p>
<ul>
<li>没有了<code>首部校验和</code>（Header checksum），加快了路由器处理数据报的速度。</li>
<li>没有了<code>分片/组装</code>（Fragmentation/reassembly)</li>
<li>没有了<code>选项</code>（options），选项字段不再是标准 IP 首部的一部分，而是可能出现在 IPv6 首部中由“下一个首部”（next header）指出的位置上。</li>
</ul>
<hr>
<p>从 IPv4 迁移到 IPv6，在实践中广泛采用的方法是<code>建隧道</code>。</p>
<figure><img src="/images/tunnel-logical-view.jpg"
         alt="隧道的逻辑视图"/><figcaption>
            <p>隧道的逻辑视图</p>
        </figcaption>
</figure>

<p>建隧道的基本思想是：假设两个 IPv6 I点要使用 IPv6 数据报通信，但是它们是经由中间 IPv4 路由器（可能会由多个）互联的。把两台 IPv6 路由器之间的中间 IPv4 路由器的集合称为一个<code>隧道</code>(tunnel)。在隧道发送端的 IPv6 节点将整个 IPv6 数据报放到在一个 IPv4 的有效载荷中，再发送给隧道的第一个节点，在隧道接收端的 IPv6 节点收到这个 IPv4 数据报后，通过观察在数据报中的协议号字段是 41 [ RFC 4213]，知道该 IPv4 有效载荷是一个 IPv6 数据报。</p>
<blockquote>
<p>网络层的数据平面关注的是如何将到达路由器输入链路的数据报转发到路由器输出链路上。</p>
</blockquote>
<h3 id="通用转发">通用转发</h3>
<p>路由器基于目的地的转发可以描述为两个步骤：1）查找目的地 IP 地址（“匹配”）；2）然后将数据包发送到交换结构中的指定输出端口（“动作”）。这是一个 ”匹配+动作“ 的模式，把这种模式变得通用化会更有意义，通用转发不只是匹配目的地 IP 地址，还可以对协议栈的多个首部字段进行匹配，采取的动作也不只是转发，还可以是丢弃、复制、修改字段等。</p>
<figure><img src="/images/flow-table-entries.jpg" width="600"/>
</figure>

<p>每一台分组交换机（第三层的路由器，第二层的交换机）都有一张匹配+动作转发表，也称为流表（flow table)。流表定义了匹配+动作的规则，其中每个表项包括：</p>
<ul>
<li><em>首部字段值的集合</em>。用于分组匹配（match），与流表项匹配不上的分组将会被丢弃。</li>
<li><em>计数器集合</em>。当分组与流表项匹配时更新计数器（counter）。</li>
<li><em>动作集合</em>。当分组匹配流表项时所采取的动作（action）集合。这些动作可能将分组转发到给定的输出端口，丢弃该分组、复制该分组和将它们发送到多个输出端口或重写所选的首部字段。</li>
</ul>
<p>如果一个分组匹配多个流表项，选定的匹配和对应的动作将是其中有最高优先级的那个。</p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/networking">networking</a></li>
					
				</ul>
			</nav>
			
			
		</div>
	</article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/x-29" title="GitHub"><i data-feather="github"></i></a><a class="soc" href="https://twiiter.com/x-29/" title="Twitter"><i data-feather="twitter"></i></a><a class="soc" href="https://gitlab.com/x-29/" title="GitLab"><i data-feather="gitlab"></i></a></div>
  <div class="footer-info">
    2022  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>


<script>
  feather.replace()
</script></div>
    </body>
</html>
