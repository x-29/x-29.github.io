<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>C 笔记 - CS里的X-29</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="这是《Linux C编程一站式学习》一书的读书笔记" />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="C 笔记" />
<meta property="og:description" content="这是《Linux C编程一站式学习》一书的读书笔记" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://x-29.github.io/post/2022-05-c-notes/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-05-10T14:49:25+08:00" />
<meta property="article:modified_time" content="2022-05-10T14:49:25+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C 笔记"/>
<meta name="twitter:description" content="这是《Linux C编程一站式学习》一书的读书笔记"/>
<script src="https://x-29.github.io/js/feather.min.js"></script>
	
	
        <link href="https://x-29.github.io/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://x-29.github.io/css/main.40ca3a860425083862b7ebd55447caec5c4384573f0cb098b8d06a91e8dace2e.css" />
	
	

	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://x-29.github.io/">CS里的X-29</a>
	</div>
	<nav>
		
		<a href="/">首页</a>
		
		<a href="/post">文章</a>
		
		<a href="/about">关于</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">C 笔记</h1>
			<div class="meta">Posted on May 10, 2022</div>
		</div>
		

		<section class="body">
			<p>这是 <a href="https://book.douban.com/subject/6025290/">《Linux C编程一站式学习》</a>一书的读书笔记。</p>
<h3 id="一">一</h3>
<p>程序由一系列指令组成，指令包括：</p>
<ul>
<li>输出</li>
<li>输入</li>
<li>基本运算</li>
<li>测试和分支</li>
<li>循环（递归）</li>
</ul>
<p>编写程序就是这样一个过程：</p>
<blockquote>
<p>把复杂的任务分解成子任务，把子任务再分解成更简单的任务，层层分解，直到最后简单得可以用以上指令来完成。</p>
</blockquote>
<hr>
<p>一种平台就是一种体系结构，就是一种指令集，就是一种机器语言。</p>
<hr>
<p>计算机只能执行低级语言中的指令（汇编语言的指令要先转成机器码才能执行），高级语言要执行就必须先翻译成低级语言。翻译的方式有两种：1) 编译 2）解释。</p>
<p>1）编译执行的过程：</p>
<p><code>source code</code> &ndash;&gt; <code>complier</code> &ndash;&gt; <code>executable</code> -&gt; <code>loader</code> &ndash;&gt; <code>输出结果</code></p>
<p>把源代码全部翻译成机器指令，再加上一些描述信息，生成一个可执行文件，可执行文件可以被操作系统加载运行。</p>
<p>2） 解释执行的过程：</p>
<p><code>source code</code> &ndash;&gt; <code>interpeter</code> &ndash;&gt; <code>结果</code></p>
<p>解释器读取源代码解释执行，程序运行的结果出现在屏幕上。</p>
<p>虚拟机执行过程：</p>
<p><code>source code</code> &ndash;&gt; <code>complier</code> &ndash;&gt; <code>byte code</code> &ndash;&gt; <code>interpeter</code> &ndash;&gt; <code>结果</code></p>
<hr>
<p>编程语言是一种形式语言，是专门设计用来表达计算过程的形式语言。</p>
<p>形式语言有严格的语法(Syntax)规则。语法规则是由符号（Token）和结构（structure）的规则所组成。</p>
<ul>
<li>关于 Token 的规则称为词法（Lexical）规则。</li>
<li>关于结构的规则称为语法（Grammar）规则。</li>
</ul>
<hr>
<p>程序中的错误叫做 Bug。找到 Bug 并加以纠正的过程叫做调试（Debug）。</p>
<p>程序中的 Bug 分为：</p>
<ul>
<li>编译时错误</li>
<li>运行时错误</li>
<li>逻辑错误</li>
<li>语义错误</li>
</ul>
<h3 id="二">二</h3>
<p>C89 是最早的C语言规范，于 1989 年提出，1990 年首先由 ANSI 推出，后来被采纳位 ISO 国际标准(ISO/IEC9899:1990)，因而有时也称为 C90。</p>
<p>C89 是最广泛采用的C语言标准。</p>
<p>C99 标准在 1999 年推出。</p>
<hr>
<p>注释不能嵌套使用，C语言的注释符为 /* 和 */。</p>
<p>单行注释符 // 在 C99 中标准化。</p>
<hr>
<p>转义序列是在编译时处理的，而转换说明是在运行时处理的。</p>
<pre tabindex="0"><code>printf(&#34;%d\n&#34;, a);

\n --- 转义序列
%d --- 转换说明
</code></pre><hr>
<p>变量的类型决定了它所占有的存储空间的大小。</p>
<p>在C语言中用声明（Declaration）来规定变量的名字和类型。</p>
<p>C 语言中的声明有三种：变量声明、函数声明和类型声明。声明分为“是定义（Definition）的声明” 和 “不是定义的声明”。分配存储空间的声明同时也是定义，不分配存储空间的声明不是定义。</p>
<hr>
<p>理解一个概念不是把定义背下来就行了，一定要理解它的外延和内涵，也就是什么情况属于这个概念，什么情况下不属于这个概念，什么情况虽然属于这个概念，但一般推荐的做法（Best practice）是要尽量避免这种情况，这才算是真正理解了。</p>
<hr>
<p>定义一个变量，就是分配一块存储空间并给它命名；给一个变量赋值，就是把一个值保存到这块存储空间中。</p>
<p>变量一定要先声明后使用，这样编译才知道如何读写这块存储空间。</p>
<p>变量的定义和赋值可以一步完成，这称为变量的初始化。初始化是一种特殊的声明，而不是一种赋值语句。</p>
<p>变量的最小存储单元是字节（Byte）。</p>
<hr>
<p>任何表达式都有值和类型两个基本属性。</p>
<p>等号（=）左边的表达式要求表示一个存储位置，而不是一个值。</p>
<p>表达式所表示的存储位置称为左值（lvalue），允许放在等号（=）左边，如变量就是可以做左值。</p>
<h3 id="三">三</h3>
<blockquote>
<p>在运用逻辑推理时一定要注意，不要把必要条件当充要条件。</p>
</blockquote>
<p>函数调用也是一种表达式。</p>
<p>log(1.0) 这个表达式是由操作数 log 和函数调用运算符 () 括号组成。</p>
<p>函数调用运算符是一种后缀运算符，() 括号及其中的参数是操作数 log 的后缀。</p>
<p>操作数 log 是一个函数名，它的类型是一种函数类型 (Function Type)。</p>
<hr>
<p>C 标准主要由两部分组成，一部分描述 C 的语法，另一部分描述 C 标准库。</p>
<p>C 标准库定义了一组标准头文件，每个头文件中包含一些相关的函数、变量、类型声明和宏定义。要在一个平台上支持 C 语言，不仅要实现 C 编译器，还要实现 C 标准库，这样的实现才算符号 C 标准。</p>
<p>在 Linux 平台上最广泛使用的 C 函数库是 glibc, 其中包括 C 标准库的实现，也包括系统函数。</p>
<hr>
<p>main 函数的返回值是返回给操作系统的，因为 main 函数是被操作系统调用的。</p>
<hr>
<p>函数的定义：返回值类型  函数名(参数列表)  函数体。</p>
<p>非定义的函数声明：返回值类型  函数名(参数列表)。</p>
<hr>
<p>形参相当于函数中定义的变量，调用函数传递参数的过程相当于定义形参变量并且用实参的值来初始化。</p>
<hr>
<p>每次调用函数时，局部变量都表示不同的存储空间。</p>
<p>局部变量在每次函数调用时分配空间，在每次函数返回是释放存储空间。</p>
<p>全局变量定义在函数体之外，在程序运行时分配存储空间，在程序结束时释放存储空间。</p>
<p>局部变量会覆盖全局变量。</p>
<p>局部变量可以用类型相等的任意表达式来初始化，全局变量只能用常量表达式来初始化。</p>
<p>局部变量在定义时不初始化，则初始值是不确定的，所以局部变量在使用之前一定要先赋值。</p>
<h3 id="四">四</h3>
<p>语句块中的变量和函数的局部变量作用域不同。</p>
<p>整数除法运算要向 0 取整：5 / 2 = 2。</p>
<p>% 运算符的结果总是与被除数同号。</p>
<p>C 语言规定，else 总是和它上面最近的一个 if 配对。</p>
<p>在 C 语言中通常用 int 型来表示布尔类型: 非 0 表示真，0 表示假。</p>
<hr>
<p>函数返回一个值相当于定一个和返回值类型相同的临时变量并用 return 后面的表达式来初始化。</p>
<p>函数的返回值不是左值，或者说函数调用表达式不能做左值。</p>
<hr>
<p>封装就是为了服用。把解决各种小问题的代码封装成函数，在解决第一个大问题时可以用这些函数，在解决第二个大问题时可以复用这些函数。</p>
<p>解决问题的过程是把大问题分解成小问题，小问题再分解更小的问题。这个过程在代码中体现为函数的分层设计：</p>
<ul>
<li>底层函数解决很小的问题。</li>
<li>上层函数调用底层函数来解决更大的问题。</li>
</ul>
<hr>
<p>如果定义一个概念需要用到这个概念本身，我们称它的定义是递归的。</p>
<p>自己直接或间接调用自己的函数称为递归函数。</p>
<p>递归函数的正确性可以用数学归纳法来证明，证明：</p>
<ul>
<li>1）Base case 正确</li>
<li>2）递推关系正确</li>
</ul>
<p>写递归函数时一定要记得写 Base Case，否则即使递推关系正确，整个函数也不正确。</p>
<p>递归和循环是等价的，用循环能做的事用递归都能做，反之亦然。</p>
<blockquote>
<p>递归是计算机的精髓所在，也是编程语言的精髓所在。</p>
</blockquote>
<hr>
<p>每次调用函数时分配参数和局部变量的存储空间，退出函数是释放它们的存储空间。</p>
<p>函数参数和局部变量的存储空间在栈上分配。</p>
<p>每个函数调用的参数和局部变量的存储空间称为一个栈帧（Stack Frame）。</p>
<p>操作系统为程序的运行预留了一块栈空间，函数调用是就在这个栈空间里分配栈帧，函数返回时就释放栈帧。</p>
<h3 id="五六七">五、六、七</h3>
<p>如果把 ++i 这个表达式看作一个函数调用，除了传入一个参数，返回一个值（等于参数值加 1）之外，还产生一个 Side Effect，就是把变量 i 的值增加了 1。</p>
<p>如果把 i++ 这个表达式看作一个函数调用，传入一个参数返回一个值，返回值就等于参数值（而不是参数值加 1），此外也产生一个 Side Effect，就是把变量 i 的值增加了 1。</p>
<hr>
<p>学习一门编程语言是要特别注意三个方面：</p>
<ol>
<li>这门语言提供了哪些 Primitive，比如基本运算符、表达式和语句, 基本类型。</li>
<li>这门语言提供了哪些组合规则，比如基本类型如何组合成复合类型。</li>
<li>这门语言提供了哪些抽象机制，包括数据抽象和过程抽象。</li>
</ol>
<hr>
<p>可以做算术运算的类型称为算术类型，算术类型包括整型和浮点型。</p>
<p>可以表示零和非零，可以参与逻辑与、或、非运算或者做控制表达式的类型称为标量类型，标量类型包括算术类型和指针类型。</p>
<hr>
<p>类型定义也是一种声明，声明都要以 <code>;</code> 号结尾。</p>
<hr>
<p>struct Tag {&hellip;} 整个可以看成一个类型名，就像 int 或 double 一样，只不过它是复合类型。</p>
<hr>
<p>{} 这种语法不能用于结构体的赋值，如：z = {3.0, 40 }    (错误的用法)。</p>
<hr>
<p>初始化不是赋值。</p>
<hr>
<p>结构体变量之间允许使用赋值运算符，也可以用一个结构体变量初始化另一个结构体变量。</p>
<hr>
<p>只要局部变量才能用另一个变量的值来初始化，全局变量必须是常量。</p>
<hr>
<p>由后缀运算符组成的表达是能否做左值取决于后缀运算符左边的操作数能否做右值。例如：</p>
<ul>
<li>z 是一个变量，可以做左值，因此表达式 z.x 也可以做左值。</li>
<li>add(z,y).x 只能做右值，不能做左值，因为 add(z, y) 不能做左值（函数调用只能做右值）。</li>
</ul>
<blockquote>
<p>抽象的思想，简单说就是“提取公因式”：ab + ac = a(b+c)。</p>
</blockquote>
<p>组合使得系统可以任意复杂，而抽象使得系统的复杂性是可以控制的，任何改动都只是局限在某一层，而不会波及整个系统。</p>
<p>All problem in computer science can be solved by another level of <em>indirection</em>.</p>
<p>这里的 indirection 其实就是抽象（abstraction）的意思。</p>
<hr>
<p>struct Tag 表示一个结构体类型。</p>
<p>enum Tag 表示一个枚举类型。</p>
<hr>
<p>枚举类型的成员是常量，它们的值由编译器自动分配。</p>
<p>enum text_type {DOC, EXCEL};</p>
<hr>
<p>结构体的成员的存储空间是相邻的（也可能有若干个填充字节），合在一起组成复数变量的存储空间。</p>
<p>结构体的成员名与变量名不再同一个命名空间中，枚举的在同一个命名空间中，会出现命名冲突。</p>
<p>结构体的成员可以是另一个结构体。</p>
<h3 id="八">八</h3>
<p>数组（Array）也是一种复合数据类型，它由一系列相同类型的元素组成。</p>
<p>和结构体相似，数组元素的存储空间也是相邻的。</p>
<p>定义一个由 4 个 int 型元素组成的数组 count：</p>
<pre tabindex="0"><code>int count[4];
</code></pre><p>数组下标的表达式不仅可以表示存储单元的值，也可以表示存储单元本身，就是说可以做左值，如：</p>
<pre tabindex="0"><code>count[0] = 7;
count[1] = count[2] * 2;
++count[2];
</code></pre><hr>
<p>在 C 语言中，后缀运算符的优选级最高，单目运算符次之。</p>
<hr>
<p>数组不能相互赋值或初始化，也不能用数组类型作为函数的参数或返回值。</p>
<hr>
<p>数组类型做右值，自动转换成指向数组首元素的指针。</p>
<p>在函数原型中，如果参数写成数组的形式，则该参数实际上是指针类型。</p>
<hr>
<p>define 定义是在预处理阶段处理，而枚举是在编译阶段处理的。</p>
<hr>
<p>NULL 表示空指针。</p>
<hr>
<p>字符串字面值和数组类型相似，它的每个元素是字符型的。</p>
<p>每个字符串末尾都有一个字符‘\0’做结束符。\0 是 ASCII 码中的 Null 字符。</p>
<p>字符串字面值所代表的存储空间是只读的，不允许修改。</p>
<pre tabindex="0"><code>&#34;Hello&#34;[0] = &#39;A&#39;     (x)
</code></pre><p>字符串字面值做右值使用时，自动转换成指向首元素的指针。</p>
<hr>
<p>字符数组可以用一个字符串字面值来初始化，如：</p>
<pre tabindex="0"><code>char str[10] = &#34;Hello&#34;;
</code></pre><p>str 的后 4 个元素没有指定，自动初始化为 &lsquo;\0&rsquo;，即 Null 字符。</p>
<blockquote>
<p>写代码最重要的是选择正确的数据结构来组织信息，设计控制流程和算法尚在其次，只要数据结构选择正确，其他代码自然而然就变得容易理解和维护了。</p>
</blockquote>
<p>一个数组的元素可以是另一个数组，这样就构成了多维数组。</p>
<p>定义并初始化一个二维数组：</p>
<pre tabindex="0"><code>int a[3][2] = {1, 2, 3, 4, 5};
</code></pre><p>数组 a 有 3 个元素：a[0]、a[1]、a[2]。每个元素也是一个数组，例如 a[0] 是一个数组，它有两个元素 a[0][0]、a[0][1]，这两个元素的类型是 int，值分别是 1, 2。</p>
<p><em>概念模型</em></p>
<pre tabindex="0"><code>   |  0    1
---|---------
0  |  1    2
1  |  3    4
2  |  5    0
-------------
</code></pre><p>从概念模型上看，这个二维数组是三行两列的表格，元素的两个下标分别是行号和列号。</p>
<p><em>物理模型</em></p>
<pre tabindex="0"><code> a[0][0]  a[0][1]  a[1][0]  a[1][1]  a[2][0]  a[2][1]
-------------------------------------------------------
|   1   |    2    |   3   |   4    |   5    |    0    |
-------------------------------------------------------
</code></pre><p>从物理模型上看，这 6 个元素在存储器中仍然是连续存储的。</p>
<h3 id="九">九</h3>
<p>编码风格</p>
<ul>
<li>用 tab 缩进，tab 最好设成是 8 个空格的长度。</li>
<li>函数内的注释要尽可能少用。写注释主要是为了说明代码“能做什么”，比如函数接口定义，而不是为了说明“怎么做”，只要代码写得足够清晰，“怎么做”是一目了然的。</li>
<li>复杂的结构体定义比函数更需要注释。</li>
<li>标识符命名
<ul>
<li>变量、函数采用全小写加下划线的方式命名</li>
<li>常量（比如宏定义和枚举常量）采用全大写加下划线的方式命名。</li>
</ul>
</li>
<li>每个函数都应该设计得尽可能简单，实现一个函数只是为了做好一件事情。</li>
<li>执行函数就是执行一个动作，函数名通常应包含动词。</li>
</ul>
<h3 id="十二">十二</h3>
<blockquote>
<p>算法 + 数据结构 = 程序</p>
</blockquote>
<p>数据结构（Data structure）是数据的组织方式。</p>
<p>一个问题中数据的存储方式和访问方式就决定了解决问题可以采用什么样的算法，要设计一个算法就要同时设计相应的数据结构来支持这种算法。</p>
<hr>
<p>堆栈是一种数据结构，它的特点是 LIFO（后进先出）。</p>
<p>堆栈有两个操作：push 和 pop</p>
<p>push 称为入栈，向栈顶添加元素。pop 称为出栈，取出当前栈顶的元素。</p>
<p>还有一个栈顶指针，总是指向栈顶的下一个元素。</p>
<hr>
<p>深度优先搜索（DFS）的特点：每次探索完各个方向相邻的点之后，取其中一个相邻的走下去，一直走到无路可走了再退回来，取另一个相邻的点再走下去。</p>
<hr>
<p>有什么样的数据结构就决定了可以用什么样的算法，同样，有什么样的算法就决定了可以用什么样的数据结构。设计算法和设计数据结构这两件工作是紧密联系的。</p>
<hr>
<p>队列，有两个基本操作:</p>
<ul>
<li>Enqueue（入队），将元素添加到队尾。</li>
<li>Dequeue（出队），从队头取出元素并返回。</li>
</ul>
<p>有两个指针：</p>
<ul>
<li>head，总是指向队头。</li>
<li>tail, 总是指向队尾的下一个元素。</li>
</ul>
<p>特点：FIFO（先进先出）。</p>
<hr>
<p>广度优先搜索（BFS）的特点是：沿各个方向同时展开搜索，每个可以走通的方向轮流往前走一步。</p>
<h3 id="十三">十三</h3>
<p>计算机是用数字电路搭成的，数字电路只有 1 和 0 两种状态，所以计算机使用二进制是最自然的计数方式。</p>
<p>不管用哪种计数方式，数的大小并没有变，十进制的 1 + 1 等于 2，二进制的 1 + 1 等于 10，二进制的 [10] 和 十进制的 2，大小是相等的。</p>
<hr>
<p>计算机采用逻辑电路计算两个 bit（位）的加法。</p>
<p>逻辑电路有门电路和导线组成，同一条导线上在某一个时刻的电压值只能是高和低两种状态之一，分别用 1 和 0 表示。</p>
<p>导线的电压值进入门电路的输入端，经过逻辑运算后在门电路的输出端输出运算结果的电压值。</p>
<p>任何复杂的加减乘除运算都可以分解成简单的逻辑运算。</p>
<hr>
<p>XOR（异或），两个操作数相同则结果为 0，两个操作数不同则结果为 1。</p>
<hr>
<p>对于一个二进制数（A3A2A1A0），最左边的 A3 位称为最高位（Most significant Bit，MSB），最右边的 A0 位称为最低位（Least Significant Bit，LSB）。</p>
<hr>
<p>二进制小数：(0.A1A2A3&hellip;)2 = A1 x 2-1 + A2x2-2 + A3 x 2-3 + &hellip;</p>
<hr>
<p>八进制，十六进制是程序员为了书写二进制数方便而发明的简便写法。</p>
<hr>
<p>计算机的加法器在做完计算之后，根据最高位产生的进位设置进位标志，同时，根据最高位和次高位产生的进位的异或（XOR）设置溢出标志。至于这个加法到底是有符号加法还是无符号加法则取决于程序怎么理解了（C语言支持无符号数和有符号数，Java 语言只支持有符号数）。</p>
<h3 id="十四">十四</h3>
<blockquote>
<p>C 标准的理论基础之一：优先考虑效率，可移植性在其次。</p>
</blockquote>
<p>不带 signed 或 unsigned 关键字的 char 型是无符号数还是有符号数，是由实现来定义的（Implementation Defined），在 x86 平台的 gcc 定义有符号的。</p>
<p>C 语言与平台和编译器是密不可分的。</p>
<p>在 C 标准中没有明确规定的地方会用 Implementation-defined、Unspecified 或 Undefined 来表述。</p>
<ul>
<li>Implementation-defined，要求编译器必须对此做出明确规定，并写在编译器的文档中。</li>
<li>Unspecified，编译器可以任意选择一种处理方式，不必写在编译器文档中，同一个编译器不同的版本选择的处理方式可以不同。</li>
<li>Undefined，C 标准没规定怎么处理，也没规定运行的结果对不对，编译器很可能也没规定，比如数组访问越界就是 undefined  的。</li>
</ul>
<hr>
<p>对于有符号数在计算机中的表示，C 标准没有明确规定，也就是 Implementation Defined。大多数体系结构都采用补码表示法。</p>
<p>C 标准明确规定，除了 char 型以外的整型类型如果不明确写 signed 或 unsigned 关键字都表示 signed。</p>
<p>除了 char 型在 C 标准中明确规定占一个字节之外，其他整型占几个字节都是 Implementation-Defined。通常编译器实现遵守 ILP32 或 LP64 规范。</p>
<ul>
<li>ILP32 的意思是 int（I）、long（L）和指针（P）类型都占 32 位。32 位计算机的 C 编译器采用这种规范。</li>
<li>LP64 是指 long（L）和指针（P）占 64 位。64 位计算机的 C 编译器采用这种规范。</li>
</ul>
<hr>
<p>指针类型的长度总是和计算机的位数一致。因为指针变量存储的是内存单元的地址，每个内存单元的地址长度是由计算机的字长决定的。</p>
<hr>
<p>整数常量的类型（在 c 头文件 limits.h 中）</p>
<pre tabindex="0"><code>#define    INT_MAX      2147483647
#define    INT_MIN      (-INT_MAX - 1) 
</code></pre><p>写成（-INT_MAX - 1）是因为补码表示的不对称性和 C 语言的转换规则之间奇怪的交互。虽然 -2147483648 这个数值能够用 int 表示，但在 C 语言中却没法写出对应这个数值的 int 常量，C 编译器会把它当成一个整数常量 2147483648 和一个负号（-）运算符组成的表达式，而整数常量 2147483648 已经超出了 int 型的取值范围，写成 -2147483647 - 1 这样减号（-）运算符的两个操作数都是 int 型，计算结果也应该是 int 型，并且它的值也没有超出 int 型的取值范围。</p>
<hr>
<p>C 标准规定中，既没有规定浮点型类型占多少字节，也没规定采用哪种表示形式。</p>
<p>大部分平台的浮点数实现遵循 IEEE 754，float 型通常是 32 位，double 型通常是 64 位。</p>
<p>浮点数在计算机中的表示是基于科学计数法的：</p>
<pre tabindex="0"><code>V = (-1)^s x M x 2^E

M: 尾数
E：指数
s: 符号，=0 表示正，=1 表示负
</code></pre><hr>
<p>C 语法规则中最复杂的是类型转换。（P181)</p>
<h3 id="十五">十五</h3>
<p>位运算 &amp;、｜、^ 运算符都是要做 Usual Aritchetic Conversion 的（其中有一步是 Integer Promotion）。</p>
<p>～ 运算符也要做 Integer Promotion。</p>
<p>位运算符的操作数必须是整型。</p>
<hr>
<p>在一定的取值范围内，将一个整数左移 1 位，相当于乘以 2。比如：二进制 [11]（十进制 3）左移一位变成 [110]，就是 6，在左移一位变成 [1100]，就是 12。</p>
<p>在一定的取值范围内，将一个整数右移 1 位，相当于除以 2，小数部分截掉。</p>
<hr>
<p>操作数是有符号数时，右移运算的规则：</p>
<ul>
<li>如果时正数，那么高位移入 0。</li>
<li>如果时负数，那么高位移入 1 还是 0 不一定，这是 Implementation-defined 的。对于 x86 平台的 gcc 编译器，最高位移入 1，也就是仍保持负数的符号位。这种处理方式对负数仍然保持了“右移 1 位相当于除以 2”的性质。（注：算术右移）。</li>
</ul>
<p>建议只对无符号数做位运算，以减少出错的可能。</p>
<hr>
<p>要对一个整数中的某些位进行操作，可以用<em>掩码</em>来表示这些位在整数中的位置。</p>
<p>例如：</p>
<pre tabindex="0"><code>1. 取出 8 ～ 15 位
（0x12345678 &amp; 0x0000ff00) &gt;&gt; 8           /* 0x00000056 */

2. 将 8 ～ 15 位清 0
  0x12345678 &amp; ～0x0000ff00                /* 12340078 */
</code></pre><hr>
<p>一个数和自己做异或的结果是 0，即 x ^ x = 0。</p>
<hr>
<p>a += 1 相当于 a = a + 1。( 表达式 a += 1，a 是求值一次；表达式 a = a + 1，a 求值两次。)</p>
<p>++i 相当于 i = i + 1。更准确说等价于 i += 1。</p>
<hr>
<p>x ^ x ^ y == y</p>
<hr>
<p>sizeof 表达式</p>
<p>sizeof(类型名)</p>
<p>这两种形式都是求类型所占的字节数。</p>
<p>例如：</p>
<pre tabindex="0"><code>1.
sizeof i++ 
求表达式 i++ 的类型所占的字节数。表达式 i++ 不会求值，sizeof 是在编译时计算。

2.
sizeof(int)
求 int 类型的字节数。
</code></pre><p>sizeof 运算符的结果是 size_t 类型。</p>
<p>C 标准规定 size_t 是一种无符号整型。</p>
<p>不同平台的编译器可能会根据自己平台的具体情况定义 size_t 所代表的类型，C 标准规定 size_t 这个名字就是为了隐藏这些细节，使代码具有可移植性。</p>
<hr>
<p>typedef  关键字用于给某种类型起一个新的名字。</p>
<p>例：typedef unsigned long size_t；</p>
<p>这样 size_t 就是一个类型名，代表 unsigned long 类型，可以这样使用：<code>size_t y;</code></p>
<hr>
<p>类型名通常加个 _t 后缀表示 Type。</p>
<hr>
<p><code>||</code> 操作符，左操作数的值为 1 时，就不再求右操作数的值。</p>
<p><code>&amp;&amp;</code> 操作，在左操作数的值为 0 时，就不再求右操作数的值。</p>
<hr>
<p>异或运算的一些特性：</p>
<ul>
<li>一个数和自己做异或的结果是 0。x86 平台的编译器可能会生成这样的指令：<code>XORL %eax, %eax</code>。不管 eax 寄存器里的值原来是多少，做异或运算都能得到 0，这条指令比同样效果的 movl $0, %eax 指令快。</li>
<li>不管 0 还是 1，和 0 做异或保持原值不变；和 1 做异或得到原值的相反值。</li>
<li>如果 a1 ^ a2 ^ a3 &hellip; ^ aN 的结果是 1，则表示当中 1 的个数为奇数个，否则为偶数个。这条性质可用于奇偶校验。</li>
<li>x ^ x ^ y == y，因为 x ^ x = 0，0 ^ y == y。这个性质可以用来不借助额外的存储空间交换两个变量的值，例如：</li>
</ul>
<pre tabindex="0"><code>a = a ^ b;
b = b ^ a;
a = a ^ b;
</code></pre><hr>
<p>为避免出现野指针，在定义指针变量是，应该给它明确的初值，或者把它初始化为 NULL。</p>
<pre tabindex="0"><code>int *p = NULL;
</code></pre><p>NULL 在标准库的头文件 stddef.h 中定义：</p>
<pre tabindex="0"><code>#define NULL ((void *)0)
</code></pre><p>就是把地址 0 转换成指针类型，称为空指针。它的特殊之处在于操作系统不会把任何数据保存在地址 0 及其附近，也不会把地址 0 ~ 0xfff 的页面映射到物理内存，所以任何对地址 0 的访问都会立即导致段错误。</p>
<h3 id="十六">十六</h3>
<blockquote>
<p>All problems in compute science can be solved by another level of indirection.</p>
</blockquote>
<p>现代计算机都是基于 Von Nenumann 体系结构。主要特点是：CPU 和内存是计算机的两个主要组成部分。内存中保存着数据和指令，CPU 从内存中取指令执行。</p>
<hr>
<p>每个内存单元有一个地址，内存地址是从 0 开始编号的整数，CPU 通过地址找到相应的内存单元，取其中的指令或者读写其中的数据。</p>
<p>一个地址所对应的内存单元不能存很多东西，只能存<em>一个字节</em>。像 int、float 等多字节的数据类型保存在内存中要<em>占用连续的多个地址</em>，这种情况下数据的地址是它所占内存单元的起始地址。</p>
<hr>
<blockquote>
<p>CPU 总是周而复始地做同一件事：从内存取指令，然后解释执行它，然后再取下一条指令，在解释执行。</p>
</blockquote>
<p>CPU 最核心的功能单元包括：</p>
<ul>
<li>寄存器（Register）。是 CPU 内部的高速存储器，像内存一样可以存取数据，但比访问内存快得多。</li>
<li>程序计数器（PC）。是一种特殊寄存器，保存着 CPU 取下一条指令的地址，CPU 按程序计数器保存的地址去内存中取指令然后解释执行，这时程序计数器保存的地址会自动加上该指令的长度，指向内存中的下一条指令。</li>
<li>指令译码器。CPU 取上来的指令由若干个字节组成，指令译码器负责解释它们的含义，然后调动相应的执行单元去执行它。</li>
<li>算术逻辑单元（ALU）。负责运算，比如加减乘除、位运算、逻辑运算。如果译码器将一条指令解释为运算指令，就调用算术逻辑单元去做运算。</li>
<li>地址和数据总线（Bus）。CPU 和内存之间同地址总线、数据总线和控制总线连接起来，每条线上有 1 和 0 两种状态。
<ul>
<li>地址线、数据线和 CPU 寄存器的位数通常是一致的，比如 64 位。</li>
<li>这里所说的地址线、数据线是指 CPU 的内总线，是直接和 CPU 的执行单元相连的，内总线经过 MMU 和总线接口的转换之后引出到芯片引脚才是外总线。</li>
<li>外地址线和外数据线的位数都有可能和内总线不同。</li>
</ul>
</li>
</ul>
<hr>
<p>从 CPU 的角度来看，访问设备只有内存映射 I/O 和端口 I/O 两种，要么像内存一样访问，要么用一种专用的指令访问。</p>
<p>计算机的设备五花八门，各种设备的要求都不一样，于是出现了各种适应不同要求的设备总线，比如 PCI、USB、SATA等，这些设备总线并不直接和 CPU 相连，CPU 通过内存映射 I/O 或端口 I/O 访问相应的总线控制器，通过总线控制器再去访问挂在总线上的设备。</p>
<hr>
<p>x86 平台上，硬盘是挂在 IDE、SATA 或 SCSI 总线上的设备，保存在硬盘上的程序是不能被 CPU 直接取指令执行的。</p>
<hr>
<p>操作系统在执行程序时会把它从硬盘拷贝到内存，这样 CPU 才能取指令执行，这个过程称为<em>加载（Load）</em>。</p>
<p>程序加载到内存之后，成为操作系统调度执行的一个任务，就成为<em>进程（process）</em>。</p>
<p>操作系统本身也是一段保存在磁盘上的程序，计算机在启动时执行一段固定的启动代码（称为 Boot loader）首先把操作系统从磁盘加载到内存，然后执行操作系统中的代码把用户需要的其他程序加载到内存。</p>
<p>操作系统是常驻内存的。</p>
<p>操作系统最核心的功能是管理进程调度、管理内存的分配使用和管理各种设备，做这些工作的程序称为内核（Kernel）。</p>
<hr>
<p>内存只是保存数据而不会产生新的数据，如果 CPU不去读它，它也不需要主动提供数据给 CPU。</p>
<hr>
<p>设备需要主动通知 CPU 来读数据。</p>
<p>每个设备都有一条中断线，通过中断控制器连接到 CPU，当设备需要主动通知 CPU 是就引发一个中断信号，CPU 正在执行的指令将被打断，程序计数器会指向某个固定的地址（由体系结构定义），于是 CPU 从这个地址开始取指令（或者说跳转到这个地址），执行中断服务程序（Interrupt Service Routine，ISR），完成中断处理之后再返回先前被打断的地方执行后续指令。</p>
<p>每个设备都需要专门的设备驱动程序。设备驱动程序通常是内核里的一个组函数，有些设备还要提供一个中断处理函数供 ISR 调用。</p>
<hr>
<p>现代操作系统普遍采用虚拟内存管理（Virtual Memory Management）机制，这需要 CPU 中的 MMU（Memory Management Unit，内存管理单元）提供支持。</p>
<hr>
<p>如果 CPU 没有 MMU，或者有 MMU 但没有启用，CPU 执行单元发出的内存地址将直接传到芯片引脚上，被内存芯片接收，这称为物理地址（Physical Address，PA）。</p>
<p>如果 CPU 启用了 MMU，CPU 执行单元发出的内存地址将被 MMU 截获，从 CPU 到 MMU 的地址称为虚拟地址（Virtual Address，VA），而 MMU 将这个地址翻译成另一个地址发到 CPU 芯片的外部地址引脚上，也就是将 VA 映射成 PA。</p>
<hr>
<p>以 32 位 CPU 为例，则内地址总线是 32 位的，与 CPU 执行单元相连，而经过 MMU 转换之后的外地址总线则不一定是 32 位的。也就说虚拟地址空间和物理地址空间是独立的，32 位 CPU 的虚拟地址空间是 4GB，而物理地址空间既可以大于也可以小于 4GB。</p>
<hr>
<p>MMU 将 VA 映射到 PA 是以页（Page）位单位的。</p>
<p>32 位 CPU 的页尺寸通常是 4KB（2^12）.</p>
<p>例：MMU 可以通过一个映射项将 VA 的一页 0xb7001000 ~ 0xb7001fff 映射到 PA 的一页 0x2000 ~ 0x2fff，如果 CPU 执行单元要访问虚拟地址 0xb7001008，则实际访问到的物理地址是 0x2008。</p>
<hr>
<p>物理内存中的页称为物理页面或者页帧（Page Frame）。</p>
<p>虚拟内存的哪个页面映射到物理内存的哪个页帧是通过页表（Page table）来描述的，页表保存在物理内存中（页表由操作系统管理维护），MMU 会查找页表来确定一个 VA 应该映射到什么 PA。</p>
<hr>
<p>程序中使用的地址都是虚拟地址，都会引发 MMU 做查表和地址转换操作。</p>
<hr>
<p>操作系统可以在页表中设置每个内存页面的访问权限，当 CPU 要访问一个 VA 时，MMU 会检查 CPU 当前处于用户模式还是特权模式，访问内存的目的是读数据，写数据还是取指令，如果和操作系统设定的页面权限相符，就允许访问，把它转换成 PA，否则不允许访问，产生一个异常（Exception）。</p>
<hr>
<p>操作系统把虚拟地址空间划分为<code>用户空间</code>和<code>内核空间</code>。</p>
<p>例如 x86 平台的 Linux 系统虚拟地址空间是 0x00000000 ~ 0xffffffff，前 3GB（0x00000000 ~ 0xbfffffff）是用户空间，后 1GB（0xc0000000 ~ 0xffffffff）是内核空间。</p>
<hr>
<p>在正常情况下 CPU 在用户模式执行用户程序，在中断或异常产生时 CPU 切换到特权模式执行内核程序，处理完中断或异常之后，再返回用户模式继续执行用户程序。</p>
<hr>
<p>对于多字节的整数类型，低地址保存的是整数的低位，这称为小端（Little Endian）字节序列（Byte order）。</p>
<p>x86 平台是小端字节序列的。</p>
<p>低地址保存整数的高位，称为大端（Big Endian）字节序列。</p>
<hr>
<p>硬盘、内存、CPU 寄存器、Cache 在计算机中这些都是存储器，计算机把存储器分成若干级，称为 <code>Memory Hierarchy</code>。按照离 CPU 由近到远的顺序依次是 CPU 寄存器、Cache、内存、硬盘，越是靠近 CPU 的存储器容量越小，但访问速度越快。</p>
<ul>
<li>
<p><code>CPU 寄存器</code>，位于 CPU 执行单元中。“寄存器” 这个名字是一种数字电路的名字，它由一组触发器（Flip-flop）组成，每个触发器保存一个 bit 的数据，可以做存取和移位等操作。计算机掉电时寄存器中保存的数据会丢失。</p>
</li>
<li>
<p><code>Cache</code>，和 MMU一样位于 CPU 核中。Cache 通常分为几级，一级靠近 CPU 执行单元，二级更靠近物理内存。Cache 和内存都是由 RAM（Random Access Memory）组成的，可以根据地址随机访问，计算机掉电时 RAM 中的数据会丢失。</p>
<ul>
<li>Cache 由 SRAM（Static RAM，静态 RAM）组成。</li>
<li>内存由 DRAM （Dynamic RAM，动态 RAM）组成。DRAM 电路简单，存储容量可以做得更大，但访问速度比 SRAM 慢。</li>
</ul>
<p>Cache  缓存最近访问过的内存数据。一级 Cache 时这样工作的：CPU 执行单元要访问内存时首先发出 VA，Cache 利用 VA 查找相应的数据有没有被缓存，如果 Cache 中有就不需要访问物理内存了，如果是	读操作就直接将 Cache 中的数据传给 CPU 寄存器，如果是写操作就直接改写到 Cache 中；如果 Cache 没有缓存该数据，就去物理内存中取数据，但并不是要哪个字节取哪个字节，而是把相邻的几十个字节都	取上来缓存着，以备下次用到，这称为一个 Cache Line。典型的 Cache Line 大小是 32 ～ 256 字节。如果计算机还配置了二级缓存，则在访问物理内存之前先用 PA 去二级缓存中查找。</p>
<ul>
<li>一级 Cache 用 VA 寻址的，二级 Cache 是用 PA 寻址的。</li>
<li>Cache 所做的工作是由硬件自动完成的，不是由指令来决定的。</li>
</ul>
</li>
<li>
<p><code>内存</code>，位于 CPU 外的芯片，与 CPU 通过地址总线和数据总线相连。内存是通过地址来访问的，在启用 MMU 的情况下，程序指令中的地址是 VA，而访问内存用的是 PA，它们之间的映射关系（页表）由操作系统维护。</p>
</li>
<li>
<p><code>硬盘</code>，位于设备总线上，不直接和 CPU 相连。CPU 通过设备总线的控制器访问硬盘。硬盘的访问速度较慢，操作系统通常一次从硬盘上读取几个页（Page）到内存中缓存起来。</p>
</li>
</ul>
<hr>
<p>Cache 从内存取数据时会预取一个 Cache Line 缓存起来，操作系统从硬盘读取数据时预读几个页面（Page）缓存起来都是希望这些数据以后会被程序访问到。（备注：局部性原理）。</p>
<p>大多数程序的行为都具有局部性（Locality）的特点：</p>
<p>它们会花费大量的时间反复执行一小段代码（例如循环），或者反复访问一个很小的地址范围中的数据（例如访问一个数组）。所以<code>预读 + 缓存</code>的思想是很有效的：</p>
<ul>
<li>CPU 取一条指令，我把和它相邻的指令缓存起来，CPU 很可能马上会取到。</li>
<li>CPU 访问一个数据，我把和它相邻的数据也都缓存起来，CPU 很可能马上就会访问到。</li>
</ul>
<hr>
<p>由于局部性原理，CPU 大部分时间在和 Cache 大交道，有 Cache 的计算机明显会快很多。这是 Memory Hierarchy 的意义所在。</p>
<h3 id="十七">十七</h3>
<blockquote>
<p>写一行 C 代码，编译器会生成什么样的指令，要做到心中有数。</p>
</blockquote>
<p>汇编器把汇编程序中的<em>助记符</em>翻译成机器指令，生成目标文件；链接器把目标文件链接成可执行文件。</p>
<p>链接器主要有两个作用：</p>
<ul>
<li>修改目标文件中的信息，对地址做重定位。</li>
<li>把多个目标文件合并成一个可执行文件。</li>
</ul>
<hr>
<p>以 <code>.</code> 开头的名称不是指令的助记符，不会被翻译成机器指令，而是给汇编器的一些特殊指示，称为<em>汇编指示</em>。</p>
<p><code>.section</code> 指示把代码划分成若干个 <em>section</em>，程序被操作系统加载执行时，每个 section 被加载到不同的地址，操作系统对不同的页面设置不同的读写、执行权限。</p>
<p><code>.data</code> 段的保存程序的数据，是可读可写的，相当于 C 程序全局变量。</p>
<p><code>.text</code> 段保存代码，是只读和可执行的。</p>
<hr>
<p><em>符号</em>在汇编程序中代表一个地址，可以用在指令中，经过编译器的处理之后，所有的符号都被替换成它所代表的地址值。</p>
<hr>
<p>在 C 语言中我们通过变量名访问一个变量，其实就是读写从某个地址开始的内存单元；通过函数调用一个函数，其实就是跳转到函数第一条指令所在的地址，所以
变量名和函数名都是符号，本质上是代表内存的地址。</p>
<hr>
<p>立即数是在 CPU 内部产生的。</p>
<hr>
<p>x86 汇编存在两种不同的语法：intel 语法和 AT&amp;T 语法。Unix 平台用 AT&amp;T 语法。</p>
<hr>
<p>寻址方式</p>
<pre tabindex="0"><code>偏移量(基地址, 变址, 倍数)
</code></pre><p>计算方式为：偏移量 + 基地址 + 变址 * 倍数。</p>
<ul>
<li>偏移量和倍数必须是常数。</li>
<li>基地址和变址必须是寄存器。</li>
</ul>
<p>在有些寻址方式会省略这 4 项中的某些项，相当于这些项是 0。</p>
<ul>
<li>直接寻址，只使用偏移量寻址。</li>
<li>变址寻址，例如 <code>movl data_items(, %rdi, 4)</code>。</li>
<li>间接寻址，只使用基地址寻址，例如：movel (%eax), %ebx，把 eax 寄存器的值看作地址，把内存中这个地址的 32 位数传送到 ebx 寄存器。</li>
<li>基址寻址，只使用偏移量和基址寻址，例如：<code>movl 4(%eax), %ebx</code>。</li>
</ul>
<hr>
<p>ELF 格式的可执行文件，它有三种不同的类型：</p>
<ul>
<li>可重定位的目标文件（Relocatable，或者 Object File)</li>
<li>可执行文件（Executable）</li>
<li>共享库（Shared Object，或者 Shared Library）</li>
</ul>
<h3 id="十八">十八</h3>
<p>在执行程序时，操作系统为进程分配一块栈空间来保存函数栈帧。</p>
<p>%rsp 寄存器总是指向栈顶。</p>
<p>在 x86 平台上这个栈是从高地址向低地址增长的。</p>
<hr>
<p>C 程序的入口其实是 crt1.o 提供的<code>_start</code>，它首先做一些初始化工作，然后调用我们写的 main 函数。</p>
<hr>
<p>函数的局部变量在栈是分配。</p>
<hr>
<p>虽然栈是从高地址向低地址增长的，但数组总是从低地址向高地址排列的。</p>
<hr>
<p><code>register</code> 关键字的作用，指示编译器尽可能分配一个寄存器来保存这个变量。</p>
<p>现在的编译器的优化都做得很好了，编译器自己会想办法有效利用 CPU 寄存器，所以现在 register 关键字很少用了。</p>
<hr>
<p>字符串字面值和数组名类似，做右值使用时表示首元素的地址（或者说指向首元素的指针）。</p>
<hr>
<p><code>const</code> 和 <code>volatile</code>、<code>restrict</code> 关键字属于同一类语法元素，称为类型限定符（Type Qualifier）。</p>
<hr>
<p>变量的生存期分为几类：</p>
<ul>
<li>静态生存期，用 static 修饰的变量。</li>
<li>自动生存期，没有被 static 修饰的变量。</li>
<li>动态分配生存期，在堆空间中分配内存。</li>
</ul>
<hr>
<p>结构体成员也是从低地址向高地址排列的。</p>
<p>结构体和数组不同的点是：结构体的成员并不是一个紧挨一个排列的，中间有空隙，称为填充（Pading）。</p>
<hr>
<p>大多数计算机体系结构对访问内存的指令是有限制的，在 32 位平台上，如果一条指令访问 4 个字节（如 movl），起始内存地址应该是 4 的整数倍，如果一条指令访问两个字节（如 movw），起始内存地址应该是 2 的整数倍，这称为对齐（Alignment）。访问一个字节的指令（如 movb）没有对齐要求。</p>
<hr>
<p>在 x86 平台虽然能访问没有正确对齐的内存地址，但是执行效率要低，所以编译器在安排各种变量的地址是都会考虑到对齐的问题。</p>
<hr>
<p>C 标准规定，数组元素必须紧挨着排列，不能有空隙。保证每个元素的地址可以按 “基地址 + n x 每个元素的字节数” 计算出来。</p>
<hr>
<p>合理设计结构体成员的排列顺序可以节省存储空间。</p>
<p>例如：</p>
<pre tabindex="0"><code>1. 有空隙
struct {
	char a;
	shourt c;
	int d;
	char b;
} S;

2. 无空隙
struct {
	char a;
	char b;
	short c;
	int d;
} S;
</code></pre><hr>
<p>如果两个平台具有相同的体系结构，并且遵循相同的 ABI（Application Binary Interface，应用程序二进制接口规范），就可以保证一个平台上的二进制程序直接拷贝到另一个平台就能运行，不用重新编译。</p>
<hr>
<p>在 C 语言中用 <code>volatile </code> 限定符修饰的变量，编译器在编译时不会做优化，每次读这个变量都会老老实实从内存读取，每次写这个变量也老老实实写回内存。</p>
<hr>
<p>作用域（scope）这个概念适用于所有标识符，而不仅仅时变量，C 语言的作用域分为以下几类：</p>
<ul>
<li>函数作用域，标识符在整个函数中都有效。只有标号属于函数作用域。</li>
<li>文件作用域（File Scope），标识符在函数外声明，从它声明的位置开始直到这个文件末尾都有效&mdash;严格来说是直到编译单元（Translation Unit）末尾都有效。比如有源文件 a.c 包含 b.h 和 c.h，那么经过预处理把 b.h 和 c.h 在 a.c 中展开之后得到的代码称为一个编译单元。编译器将每个编译单元分别编译成一个目标文件，最后链接器把这些目标文件链接到一起成为一个可执行文件。</li>
<li>块作用域（Block Scope），标识符在一对 { } 括号中声明，即在函数体或语句块中声明。从它声明的位置开始到右 } 括之间有效。</li>
<li>函数原型作用域（Function Prototype Scope），标识符从声明的位置开始到这个原型结束之前有效。</li>
</ul>
<p>对于同一个命名空间的重名标识符，内层作用域的标识符将覆盖外层作用域的标识符。</p>
<p>命名空间可分为以下几类：</p>
<ul>
<li>语句标号单独属于一个命名空间。例如在函数中局部变量和语句标号可以重名，互不影响。</li>
<li>struct、enum 和 union 的 Tag 属于一个命名空间。</li>
<li>struct 和 union 的成员名属于一个命名空间。</li>
<li>所有其他标识符，例如变量名、函数名、宏定义、typedef 定义的类型名。enum 成员等都属于同一个命名空间，如果有重名则按内层作用域覆盖外层作用域的规则处理。</li>
<li>如果宏定义和其他标识符重名，则宏定义覆盖所有其他标识符，因为宏定义在预处理阶段先处理，而其他标识符在编译阶段处理。</li>
</ul>
<p>标识符的链接属性（Linkage) 有三种：</p>
<ul>
<li>外部链接（External Linkage），一个标识符在不同的编译单元中可能被声明多次，当这些编译单元链接成一个可执行文件时，如果这些声明都代表同一个变量或函数（即代表同一个内存地址），则这个标识符具有 External Linkage。具有 External Linkage 的标识符编译后在目标文件中是全局符号。</li>
<li>内部链接（Internal Linkage)，一个标识符在某个编译单元中可能被声明多次，这些声明都代表同一个内存地址，但如果这个标识符在不同的编译单元中被声明多次，在链接时这些声明就不代表同一个内存地址，这样的标识符具有 Internal Linkage。具有 Internal Linkage 的标识符编译后在目标文件中是局部符号，在链接是不做符号解析。</li>
<li>无链接属性（No Linkage）。除以上情况之外的标识符都属于 No Linkage。例如函数的局部变量，以及不表示变量和函数的其他标识符。</li>
</ul>
<p>存储类修饰符（Storage Class Specifier）指的是以下几个关键字，可以修饰变量和函数声明：</p>
<ul>
<li>static，用它修饰的变量的存储空间是静态分配的，用它修饰的文件作用域的变量或函数具有 Internal Linkage。</li>
<li>auto，用它修饰的变量在函数调用时自动在栈上分配存储空间，函数返回时自动释放。
<ul>
<li>auto 可以省略不写</li>
<li>auto 不能修饰文件作用域的变量。</li>
</ul>
</li>
<li>register，现在比较少用了。</li>
<li>extern，用于多次声明同一个具有 External Linkage 或 Internal Linkage 的标识符。</li>
<li>typedef，这个关键字不是用来修饰变量的，而是定义一个类型名。</li>
</ul>
<hr>
<p>看 typedef 声明怎么看呢？</p>
<p>首先去掉 typedef 把它看成变量声明，看这个变量是什么类型的，那么 typedef 就给什么类型起了一个类型名。</p>
<h3 id="十九">十九</h3>
<p>凡是被多次声明的变量或函数，必须有且只有一个声明是定义，如果有多个定义，或是一个定义都没有，链接器就无法完成链接。</p>
<hr>
<p>用 <code>extern</code> 关键字修饰的函数名具有 External Linkage。</p>
<p>用 <code>static</code> 关键字修饰的函数名具有 Internal Linkage。</p>
<hr>
<p><code>/pro</code> 目录下的文件并不是真正的磁盘文件，而是由内核虚拟出来的，当前运行的每个进程在 /proc 下都有一个子目录，目录名就是进程的 <code>id</code>，查看子目录下的文件可以得到该进程的相关信息。</p>
<hr>
<p>进程虚拟地址空间</p>
<p><img src="/images/IMG_001.jpg" alt=""></p>
<p>堆空间的结束地址称为<code>Break</code>，动态分配内存时堆空间可以向高地址增长，堆空间要向高地址增长就要抬高 Break，映射新的虚拟内存页面到物理内存（这是通过系统调用 brk 实现的，malloc 函数也是调用 brk 向内核请求分配内存的）。</p>
<hr>
<p>栈空间从高地址向低地址增长。</p>
<p>栈空间比堆空间小得多，实际的应用程序需要很大栈空间是非常小见的。设想一个应用程序有几十层深的函数调用，并且每层调用都有非常多的局部变量，这十分罕见。</p>
<hr>
<p>栈空间是可能用尽的，并且比堆空间更容易用尽。</p>
<hr>
<p>x86 平台的虚拟地址空间是 0x00000000 ~ 0xffffffff。大致上前 3GB（0x00000000 ~ 0xbfffffff）是用户空间，后 1GB（0xc0000000 ~ 0xffffffff）是内核空间。</p>
<hr>
<p>操作系统的虚拟内存管理机制起到的作用：</p>
<p>1）可以控制物理内存的访问权限。</p>
<p>物理内存本身是不限制访问的，任何地址都可以读写，而操作系统要求不同的页面具有不同的访问权限（利用 CPU 模式和 MMU的内存保护机制实现的）。</p>
<p>2）使每个进程有独立的地址空间。</p>
<p>不同进程中相同的 VA 被 MMU映射到不同的 PA，因此在某个进程中访问任何虚拟地址都不可能访问到属于另一个进程的物理内存页面，并且每个进程都认为自己独占 0x00000000 ~ 0xbfffffff（32 位机器的前 3GB） 的整个用户地址空间。</p>
<p>独立地址空间的好处是：任何一个进程由于执行了错误指令或恶意代码而导致的非法内存访问都不会意外改写其他进程的数据，不会影响其他进程。</p>
<p>每个进程都有自己的一套 VA 到 PA 的映射表，在一个进程中通过 VA 只能访问到属于自己的物理页面，而不访问到其他进程的物理页面。</p>
<p><img src="/images/IMG_010.jpg" alt=""></p>
<p>操作系统可以安排两个进程共享相同的物理页面，只要每个进程中不同的 VA 映射到相同的 PA 就可以实现共享。</p>
<p>3）VA 到 PA 的映射会给分配和释放内存带来方便，物理地址不连续的几块内存可以映射成虚拟地址连续的一块内存。</p>
<p><img src="/images/IMG_011.jpg" alt=""></p>
<p>4）虚拟内存管理机制可以是的运行着的进程分配的内存之和可以大于实际可用的物理内存。</p>
<p>进程访问的是虚拟内存页面，这些页面的数据可以保存在物理页面中，也可以临时保存在磁盘上而不占用物理内存页面，可以在磁盘上开一个分区或着建一个文件专门用于临时保存虚拟内存页面的数据，这称为交换设备（Swap Device）。</p>
<p>启用了交换设备之后，系统可以分配的内存总量 = 物理内存的大小 + 交换设备的大小。</p>
<p>当物理内存不够用时，操作系统将一些不常用的物理页面中的数据临时保存到交换设备，同时解除 VA 到 PA 的映射，这个物理页面就可以认为是空闲的了，可以重新分配给进程使用，这称为换出（Page out）。</p>
<p>如果进程访问到被换出的虚拟内存页面，由于 VA 到 PA 的映射不存在，访问内存的指令会引发一个异常，称为缺页错误（Page Fault），这时进入异常出来程序，操作系统把缺失的页面从交换设备再加载会物理内存，并建立 VA 到 PA 的映射，然后回到用户模式重新执行那条访问内存的指令，这称为换入（Page in）。</p>
<p>换出和换入操作系统，称为换页（Paging）。</p>
<h3 id="二十">二十</h3>
<p>可以像变量一样在代码中使用的宏定义称为变量式宏定义。如：<code>#define N   20</code></p>
<p>可以像函数调用一样在代码中使用的称为函数式宏定义，如：</p>
<pre tabindex="0"><code>#define   MAX(a, b)   ((a)&gt;(b)?(a):(b))
k = MAX(i&amp;0x0f, j&amp;0x0f)
</code></pre><p>k 展开成：k = ((i&amp;0x0f)&gt;(j&amp;0x0f)?(i&amp;0x0f):(j&amp;0x0f))。就像函数调用一样，把两个实参表达式分别替换到宏定义中形参 a 和 b 的位置。</p>
<hr>
<p>一般来说简短的，被频繁调用的函数适合用函数宏定义来代替实现，省去了分配和释放栈帧、传参、传返回值等一系列工作。</p>
<p>函数式宏定义经常写成这样的形式（取自内核代码）：</p>
<pre tabindex="0"><code>#define device_init_wakeup(dev, val)\
	do {\
		device_can_wakeup(dev) =!!(val);\
		device_set_wakeup_enable(dev, val);\
	} while(0)
</code></pre><p>用 do {&hellip;} while(0) 括起来。</p>
<hr>
<p>C99 引入一个新。的关键字 inline，用于定义内联函数（Inline Function），在内核代码中很常见。inline 关键字告诉编译器，这个函数的调用要尽可能快，可以当普通的函数调用实现，也可以用宏展开的办法实现。</p>
<hr>
<p>宏定义中可变参数部分用<code>_VA_ARGS_</code>表示，在宏展开是和<code>...</code>对应的几个实参可以看成一个实参来替换掉_VA_ARGS_。</p>
<p>例：</p>
<pre tabindex="0"><code>#define showlist(...) printf(#_VA_ARGS_)
showlist(The first, second, and third items.);
</code></pre><p>预处理之后变成：printf(&ldquo;The first, second, and third items.&rdquo;);</p>
<hr>
<p><code>#</code> 号运算符后面应该跟一个形参，用于创建字符串字面值，预处理器用<code>&quot;</code>号把实参括起来称为一个字符串字面值，并且实参中的连续多个空白字符串被替换成一个空格。</p>
<p><code>##</code> 运算符把前后两个预处理 Token 连接成一个预处理 Token。</p>
<pre tabindex="0"><code>#define CONCAT(a,b)     a##b
CONCAT(con, cat)
</code></pre><p>预处理之后是：concat。</p>
<hr>
<p>重复定义一个宏必须定义得一摸一样才算对，否则算错，而重复取消一个宏的定义不算错。</p>
<p>取消宏定义用 <code>#undef</code> 预处理指示，如：<code>#undef X</code>。</p>
<hr>
<p>宏展开的步骤：</p>
<p>例：</p>
<pre tabindex="0"><code>#define   sh(x)    printf(&#34;n&#34;  #x   &#34;=%d, or %d\n&#34;, n##x, alt[x])
#define  sub_z    26
sh(sub_z)
</code></pre><p>替换过程如下：</p>
<ul>
<li><code>#x</code>要替换成 “sub_z”。</li>
<li>n##x 要替换成 nsub_z。</li>
<li>除了带<code>#</code>和<code>##</code>运算符的参数之外，其他参数在替换之前要对实参本身做充分展开，所以应该先把 sub_z 展开成 26 再替换到 alt<input checked="" disabled="" type="checkbox"> 中 x 的位置。</li>
<li>现在展开成了 printf(&ldquo;n&rdquo; &ldquo;sub_z&rdquo; &ldquo;=%d, or %d\n&rdquo;, nsub_z, alt[26])，所有参数都替换完了，这时编译器会再扫描一遍，再找出可以展开的宏定义来展开，假设 nsub_z 或 alt 是变量是宏定义，这时会进一步展开。</li>
</ul>
<hr>
<p>预处理运算符 defined 一般用作表达式中的一部分，如果单独使用，</p>
<p><code>#if defined x</code> 相当于 <code>#ifdef x</code>。</p>
<p><code>#if !defined x</code> 相当于 <code>#ifndef x</code>。</p>
<hr>
<p>预处理器如何求值 #if 后面的表达式（这个表达式必须是常量表达式）。</p>
<p>例：</p>
<pre tabindex="0"><code>#define VERSION   2
#if defined x||y||VERSION&lt;3
</code></pre><ol>
<li>如果 x 这个宏有定义，则把 defined x 替换成 1，否则替换成 0，因此变成 <code>#if 0||y||VERSION&lt;3</code></li>
<li>把有定义的宏展开，变成 <code>#if 0||y||2&lt;3</code></li>
<li>把每一定义的宏替换成 0，变成 <code>#if 0||0||2&lt;3</code></li>
<li>把得到的表达式求值，结果是 #if1，因此条件成立。</li>
</ol>
<h3 id="二十一二十二">二十一、二十二</h3>
<p>把一个变量所在的内存单元的地址保存在另一个内存单元中，保存地址的这个内存单元称为指针。</p>
<hr>
<p>变量的地址在编译链接是确定的，所以 <code>&amp;i</code> 是常量表达式。</p>
<hr>
<p>指针变量占用的空间跟平台相关，32 位平台上指针变量占 4 个字节，因为要保存 32 位的虚拟地址，在 64 位平台上指针变量占 8 个字节。</p>
<hr>
<p>把多个数组放在一起声明，每个数组名后面都要有<code>[]</code>，同理，把多个指针变量放在一起声明，每个变量名前面都要有 <code>*</code>。</p>
<p>例如：</p>
<pre tabindex="0"><code>int a[5], b[10];
int *p, *q;
</code></pre><hr>
<p><code>pi = &amp;j</code>，把变量 j 的内存地址赋给指针变量 pi。</p>
<p><code>*pi = *pi + 10</code>，通过指针变量 pi 间接寻址到变量 j，把变量 j 的值增加 10。</p>
<p>这里的 * 是指针间接寻址运算符。</p>
<p>*pi 表示取指针 pi 所指向的变量的值，也称为 Dereference 操作。</p>
<p>指针有时称为变量的引用（Reference），所以根据指针找到变量称为 Dereference。</p>
<hr>
<p><code>[]</code> 用在声明中表示声明一个数组；用在表达式中是取下标运算符。</p>
<p><code>*</code> 用在声明中表示声明一个指针类型；用在表达式总是间接寻址运算符。</p>
<hr>
<p>符号（=）左边的表达式要求表示一个存储位置而不是一个值。</p>
<p>表达式所表示的存储位置称为左值，允许放在等号左边，比如变量。</p>
<p>像 a + 1 这样的表达式称为右值，只能放在等号右边。</p>
<p>有的表达式既可以做左值也可以做右值，而有的表达式只能做右值。</p>
<p>表达式可以是常量或变量，也可以更复杂。</p>
<hr>
<p>定义一个变量，就是分配一块存储空间并给它命名；给一个变量赋值就是把一个值保存到这块存储空间中。</p>
<p>变量声明中的类型表明变量代表多大的一块存储空间。</p>
<hr>
<p><code>*</code> 和 <code>&amp;</code> 互为逆运算。</p>
<p><code>&amp;</code> 运算符的操作数必须是左值，只有左值才表示一个内存单元，才会有地址，运算结果是指针类型。</p>
<p><code>*</code> 运算符的操作数必须是指针类型，运算结果可以做左值。</p>
<p>如果表达式 E 可以做左值，则：*&amp;E 和 E 等价。</p>
<p>如果表达式 E 是指针类型，则：&amp;*E 和 E 等价。</p>
<hr>
<p>指针之间可以相互赋值，也可以用一个指针初始化另一个指针。</p>
<p>int *pti = pi；</p>
<p>或</p>
<p>int *pti;
pti = pi;</p>
<p>表示 pi 指向哪就让 pti 也指向哪，本质上是把变量 pi 所保存的地址值赋给变量 pti。</p>
<hr>
<p>void * 为通用指针。</p>
<p>其他类型的指针可以转换成 void * 指针。</p>
<p>void * 指针也可以转换成任意其他类型的指针。</p>
<p>void * 指针与其他类型的指针之间可以隐式转换，不必用（）运算符强制转换。</p>
<hr>
<p>调用函数的串参过程相当于定义形参变量并且用实参的值来初始化。</p>
<hr>
<p>函数返回之后它的栈帧就会释放掉。</p>
<hr>
<p>后缀运算符的优先级高于单目运算符。</p>
<p>&amp;a[0] 是取 a[0] 的地址，而不是取 a 的地址。</p>
<hr>
<p>数组类型做右值时，自动转换成指向首元素的指针。</p>
<p>a 做右值时自动转换成指向 a[0] 的 int * 指针，所以 a[2] 也可以写成 *(a+2)，本质上都是通过指针间接寻址访问元素。</p>
<hr>
<p>数组类型做左值时表示整个数组的存储空间。</p>
<p>数组类型做左值支持 &amp; 运算符，&amp;a 是合法的，这个表达式的类型是指向数组的指针。</p>
<p>sizeof(a) 这个表达式中数组 a 不是做右值，计算结果是整个数组的存储空间大小。</p>
<hr>
<p>sizeof pa，求一个指针 pa 的存储空间大小，计算结果是 4 字节（32 位平台）或是 8 字节（64 位平台）。</p>
<hr>
<p>函数原型中的参数写成指针形式还是数组形式对编译器来说没有区别，这个参数都是指针类型。</p>
<hr>
<pre tabindex="0"><code>const int *a;
int const *a;
</code></pre><p>这两种写法一样，a 是一个指向 const int 型的指针，a 所指向的内存单元不可改写，所以（*a)++ 是不允许的，但指针 a 本身可以改写，即 a 可以指向别的存储单元，a++ 是允许的。</p>
<pre tabindex="0"><code>int *const a;
</code></pre><p>a 是一个指向 int 型的 const 指针，*a 是可以改写的，但 a 本身不允许改写。</p>
<pre tabindex="0"><code>int const *const a;
const int *const a;
</code></pre><p>a 是一个指向 const int 型的 const 指针，*a 和 a 本身都不允许改写。</p>
<hr>
<p>要想把指针 p 赋给指针 q，q 指向的类型应该比 p 指向的类型限定得更严格，或至少是同样严格，而不能比 p 指向的类型限定得更宽松。</p>
<hr>
<p>尽量使用 const 限定符，把不该变的都声明成只读，防止意外改写数据。</p>
<hr>
<p>表达式 &amp;c 是指针类型，如：</p>
<pre tabindex="0"><code>const char c = &#39;a&#39;;
char *q = &amp;c;
</code></pre><p>表达式 &amp;c 是 const char * 型的。</p>
<hr>
<p>指针数组中的每一个元素都是指针。</p>
<p>例如：char *argv[]；</p>
<p>argv 指向一个指针数组的首元素，数组中每个元素都是 char * 指针。</p>
<hr>
<p>指向指针的指针</p>
<p><code>int **pi；</code></p>
<p>拆开来看：  <code>[int *] *ppi</code></p>
<p>转换一下：  <code>typedef int *T</code></p>
<p>T *ppi</p>
<p>指针变量 ppi 指向一个 int * 指针类型的变量，也可以说是定义了一个指向 int * 指针类型的指针变量 ppi。</p>
<hr>
<p>数组也是一种类型，可以定义指向数组的指针。</p>
<p><code>int (*a)[10];</code> 指针变量 a 指向由 10 个 int 元素组成的数组。</p>
<p><code>int *a[10];</code> 指针变量 a 为指针数组，数组元素为 int * 指针。</p>
<p>拆开来看：</p>
<pre tabindex="0"><code>int (*a)[10]   =&gt; int [10] *a;
                  =&gt; typedef int T[10];
                  =&gt; T *a;
T 代表由 10 个 int 元素组成的数组类型，a 则是指向这种类型的指针（a 就是指向数组的指针）。

int *a[10]     =&gt; [int *]a[10];
                  =&gt; T a[10] ;
             
</code></pre><hr>
<p>int a[10]；</p>
<p><code>&amp;a[0]</code> 的类型是 <code>int *</code>，<code>&amp;a</code> 的类型是 <code>int (*)[10]</code>。</p>
<hr>
<p>函数也是一种类型，可以定义指向函数的指针。</p>
<hr>
<p>指针变量的内存单元里存放一个地址值，函数指针的内存单元里存放的是函数的入口地址。</p>
<hr>
<p><code>[]</code> 比 <code>*</code> 优先级高（后缀比前缀运算符优先级高），如果：</p>
<ul>
<li>a 先与 <code>*</code> 结合则表示 a 是一个指针。</li>
<li>a 先与 <code>[]</code> 结合则表示 a 是一个数组。</li>
</ul>
<hr>
<p><code>void (*) (const char *) = say_hello</code>；</p>
<p>分析：</p>
<ol>
<li>f 先跟 <code>*</code> 结合在一起，因此是一个指针。</li>
</ol>
<p>2）(*f) 外面是一个函数原型格式，参数是 <code>const char *</code>，返回值是 void。所以 f 是指向这种函数的指针。</p>
<p>表达式 say_hello 是一种函数类型，做右值时自动转换成函数指针类型，因此，可以直接赋给 f，也可以写成 &amp;say_hello 的形式。</p>
<hr>
<p>数组取下标运算符 <code>[]</code> 要求操作数时指针类型。</p>
<p>函数调用运算符 <code>()</code> 要求操作数是函数指针类型。</p>
<hr>
<p>typedef int F(void);</p>
<p>定义了函数类型 F。这种类型的函数不带参数，返回值是 int。</p>
<p>那么，F f, g； 相当于声明：</p>
<pre tabindex="0"><code>int f(void);
int g(void);
</code></pre><p>而 F h(void); 这个声明是错误的。函数不能返回 <em>函数类型</em>，也不能返回数组类型。</p>
<p>F *e(void)； 函数 e 返回一个 F * 类型的函数指针。</p>
<p>F *fp；fp 是一个函数指针。</p>
<hr>
<p>在分析复杂声明时，要借助 typedef 把复杂声明分解成几种基本形式：</p>
<ul>
<li>T *p；p 是指向 T 类型的指针。</li>
<li>T a[]；a 是由 T 类型的元素组成的数组（如果 a 是函数的形参，则相当于 T *a）。</li>
<li>T1 f(T2, T3, &hellip;)；f 是一个函数，参数类型是 T2, T3 等，返回值类型是 T1。</li>
</ul>
<p>例：分解 <code>int (* (*fp)(void *))[10]</code>;</p>
<ol>
<li>fp 和 * 号括在一起，说明 fp 是一个指针，指向 T1 类型：</li>
</ol>
<pre tabindex="0"><code>typedef int (*T1(void *))[10];
T1 *fp;
</code></pre><ol start="2">
<li>T1 应该是一个函数类型，参数是 void *，返回值是 T2 类型：</li>
</ol>
<pre tabindex="0"><code>typedef int (*T2)[10];
typedef T2 T1(void *);
T1 *fp;
</code></pre><ol start="3">
<li>T2 和 * 号括在一个起，应该也是一个指针，指向 T3 类型：</li>
</ol>
<pre tabindex="0"><code>typedef int T3[10];
typedef int T2 *T2;
typedef T2 T1(void *);
T1 *fp;
</code></pre><p>显然，T3 是一个 int 数组，由 10 个元素组成。分解完毕。</p>
<hr>
<p>在赋值，初始化和函数调用传参过程中，假设要把指针 p 赋给 指针 q，应注意 const 限定符的语义作用：</p>
<ul>
<li>如果 p 指向的类型不带有 const 限定，而 q 指向的类型带有 const 限定，则可以把 p 赋给 q，例如：</li>
</ul>
<pre tabindex="0"><code>char c = `a`;
const char *q = &amp;c;
</code></pre><p>表达式 &amp;c 是 char * 型的，而 q 是 const char * 型的，可以赋值，赋值后 *q 不允许改写，即不能通过指针 q 来改写变量 c 的值。</p>
<ul>
<li>如果 p 指向的类型带有 const 限定，而 q 指向的类型不带有 const 限定，则不能把 p 赋给 q。
例如，对下面的代码编译器会报警告：</li>
</ul>
<pre tabindex="0"><code>cons char c = `c`;
char *q = &amp;c;
</code></pre><p>表达式 &amp;c 是 const char * 型的，而 q 是 char * 型的。假如允许赋值，则赋值后就可以通过指针 q 来改写变量 c 的值，等于绕过了变量 c 的 const 限定这道防线，这是很危险的。</p>
<ul>
<li>如果 p 和 q 指向的类型都带有 const 限定，或者都不带有 const 限定，则可以把 p 赋给 q。</li>
</ul>
<p>概括：要想把指针 p 赋给指针 q，q 指向的类型应该比 p 指向的类型限定得更严格，或至少是同样严格，而不能比 p 指向的类型限定得更宽松。</p>
<h3 id="二十三">二十三</h3>
<p>缓冲区（buffer）写越界的错误称为缓冲区溢出（Buffer Overflow）。</p>
<hr>
<p>每个进程都有一个堆空间，C 标准库函数 malloc 可以在堆空间动态分配内存，它的底层通过 brk 系统调用向操作系统申请内存。</p>
<hr>
<p>每次调用系统函数之后都应该判断是否成功。</p>
<hr>
<p><code>free(p);</code> 之后，p 所指向的内存空间归还了，但是 p 的值并没有变，p 成了野指针。为避免出现野指针，应该在 free(p); 之后手动置 p = NULL;。</p>
<p>应该先 free(p-&gt;msg)，再 free(p)，顺序不能颠倒。如果先 free(p)，p 成了野指针，就不能在访问 p-&gt;msg 了，也就不能 free(p-&gt;msg) 了。</p>
<hr>
<p>malloc 必须要有 free 与之配对，分配一次就要释放一次。</p>
<p>malloc 返回的指针一定要保存好，只有把它传给 free 才能释放这块内存，如果这个指针丢失了，就没有办法 free 这块内存，会造成内存泄露。</p>
<hr>
<p>内存泄露的 Bug 很难找到，它并不像访问越界一样导致程序运行错误，少量内存泄露并响应程序的正确运行，大量的内存泄露会导致物理内存紧缺，换页频繁，不仅影响当前进程，而且会把整个系统都拖得很慢。</p>
<hr>
<p>动态分配的内存用完之后可以用 free 释放，更准确的说是归还给了 malloc，下次调用 malloc 时这块内存可以再次分配出来。</p>
<p>从内核申请到的内存以后都归 malloc 管，即使调用 free 也不会还给内核。</p>
<hr>
<p>(完)</p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/c">C</a></li>
					
				</ul>
			</nav>
			
			
		</div>
	</article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/x-29" title="GitHub"><i data-feather="github"></i></a><a class="soc" href="https://twiiter.com/x-29/" title="Twitter"><i data-feather="twitter"></i></a><a class="soc" href="https://gitlab.com/x-29/" title="GitLab"><i data-feather="gitlab"></i></a></div>
  <div class="footer-info">
    2022  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>


<script>
  feather.replace()
</script></div>
    </body>
</html>
