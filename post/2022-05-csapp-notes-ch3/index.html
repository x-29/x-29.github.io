<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>深入理解计算机系统(csapp)笔记-程序的机器级表示 - CS里的X-29</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="这是深入理解计算机系统(Computer Systems A Programmer&#39;s Perspective 3rd)第三章的学习笔记." />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="深入理解计算机系统(csapp)笔记-程序的机器级表示" />
<meta property="og:description" content="这是深入理解计算机系统(Computer Systems A Programmer&#39;s Perspective 3rd)第三章的学习笔记." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://x-29.github.io/post/2022-05-csapp-notes-ch3/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-05-16T10:12:20+08:10" />
<meta property="article:modified_time" content="2022-05-16T10:12:20+08:10" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="深入理解计算机系统(csapp)笔记-程序的机器级表示"/>
<meta name="twitter:description" content="这是深入理解计算机系统(Computer Systems A Programmer&#39;s Perspective 3rd)第三章的学习笔记."/>
<script src="https://x-29.github.io/js/feather.min.js"></script>
	
	
        <link href="https://x-29.github.io/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://x-29.github.io/css/main.40ca3a860425083862b7ebd55447caec5c4384573f0cb098b8d06a91e8dace2e.css" />
	
	

	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>
        
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://x-29.github.io/">CS里的X-29</a>
	</div>
	<nav>
		
		<a href="/">首页</a>
		
		<a href="/post">文章</a>
		
		<a href="/about">关于</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">深入理解计算机系统(csapp)笔记-程序的机器级表示</h1>
			<div class="meta">Posted on May 16, 2022</div>
		</div>
		

		<section class="body">
			<p>计算机执行「机器代码」，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。</p>
<p>汇编代码表示非常接近于机器代码。与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。理解汇编代码以及它与原始 C 代码的联系，是理解计算机如何执行程序的关键一步。</p>
<h2 id="程序编码">程序编码</h2>
<p>假设一个 C 程序，有两个文件 p1.c 和 p2.c。用下面的 Unix 命令编译这些代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>linux&gt; gcc -Og -o p p1.c p2.c
</span></span></code></pre></div><p>命令 gcc 指的是 GCC C 编译器，这是 Linux 上默认的编译器。</p>
<p>gcc 命令实际上会调用一整套的程序，将源代码转换成可执行代码。</p>
<ul>
<li>首先，调用「C 预处理器」扩展源代码，插入所有用 <code>#include</code> 命令指定的文件，并扩展所有用 <code>#define</code> 声明指定的宏。</li>
<li>其次，调用「编译器」产生两个源文件的汇编代码，名字分别为 <code>p1.s</code> 和 <code>p2.s</code>。</li>
<li>接下来，调用「汇编器」将汇编代码转换成二进制「目标代码」文件 <code>p1.o</code> 和 <code>p2.o</code>。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。</li>
<li>最后，调用「链接器」将两个目标代码文件与实现库函数的代码合并，并产生最终的「可执行」代码文件 p。可执行代码是机器代码的第二种形式。</li>
</ul>
<hr>
<p>计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，其中两种抽象尤为重要：</p>
<ol>
<li>由「指令集体系结构或指令集架构（Instruction Set Architecture，ISA）」来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。</li>
<li>机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数值。</li>
</ol>
<p>C语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单地将内存看成一个很大、按字节寻址的数组。</p>
<ul>
<li>C 语言中的聚合数据类型，例如数组和结构，在机器代码中用一组连续的字节来表示。</li>
<li>对标量数据类型，汇编代码也不区分有符号或无符号，不区分各种类型的指针，甚至不区分指针和整数。</li>
</ul>
<p>在 gcc 命令上使用 &ldquo;-S&rdquo; 选项，可以产生一个汇编文件，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>linux&gt; gcc -Og -S mstore.c
</span></span></code></pre></div><p>执行这条命令，将会使 GCC 运行编译器，产生一个汇编文件 <code>mstore.s</code>，但不做进一步的工作。（通常情况下，它还会继续调用汇编器产生目标代码文件）。</p>
<p>使用 “-c“ 选项，GCC 会执行编译并汇编代码，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>linux&gt; gcc -Og -c mstore.c
</span></span></code></pre></div><p>这会产生目标代码文件 mstore.o，它是二进制格式的，所以我们无法直接查看。</p>
<p>要想查看机器代码文件的内容，可以使用「反汇编器」程序，例如，在 Linux 系统中，带 &lsquo;-d&rsquo; 选项的 objdump 命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>linux&gt; objdump -d mstore.o
</span></span></code></pre></div><p>查看机器代码文件的内容，我们会发现「<strong>机器执行的程序只是一个字节序列，它是对一系列指令的编码</strong>」。例如：</p>
<pre tabindex="0"><code>53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3
</code></pre><p>这些字节分成若干组，每组有 1 ～ 5 个字节。<strong>每组都是一条指令</strong>。例如 <code>53</code> 是 <code>push %rbx</code> 指令，<code>48 89 d3</code> 是指令 <code>mov %rdx, %rbx</code>。机器对产生这些指令的源代码几乎一无所知。</p>
<hr>
<p>汇编代码格式有两种：ATT 格式和 Intel 格式。</p>
<ul>
<li>GCC、objdump 用得是 ATT 格式的汇编代码。</li>
<li>Microsoft 的工具，以及 Intel 的文档，都是使用 Intel 格式的汇编代码。</li>
</ul>
<p>Intel 和 ATT 格式的一些主要不同点：</p>
<ul>
<li>Intel 代码省略了指示大小的后缀。如指令 push 和 mov，而不是 pushq 和 movq。</li>
<li>Intel 代码省略了寄存器名字前面的 &lsquo;%&rsquo; 符号，用的是 rbx，而不是 %rbx。</li>
<li>Intel 代码用不同的方式来描述内存中的位置，例如 &lsquo;QWORD PTR [rbx]&rsquo;，而不是 &lsquo;(%rbx)&rsquo;。</li>
<li>在有多个操作数的指令中，列出的操作数的顺序相反。</li>
</ul>
<h2 id="数据格式">数据格式</h2>
<p>由于是从 16 位体系结构扩展成 32 位的，Intel 用术语「字（word）」表示 16 位数据类型。因此，称 32 位数为「双字（double words）」，64 位数为「四字（quad words）」。</p>
<p>C 语言基本数据类型对应的 x86-64 表示：</p>
<figure><img src="/images/c-data-types-x86.jpg"
         alt="C 语言数据类型在 x86-64 中的大小" width="600"/><figcaption>
            <p>C 语言数据类型在 x86-64 中的大小</p>
        </figcaption>
</figure>

<p>如图所示，大多数 GCC 生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。</p>
<p>例如，数据传输指令的 4 个变种：</p>
<ul>
<li>movb，传送字节</li>
<li>movw，传送字</li>
<li>movl，传送双字</li>
<li>movq，传送四字。</li>
</ul>
<h2 id="访问信息">访问信息</h2>
<p>一个 x86-64 的 CPU 包含一组 16 个存储「64 位」值的「通用目的寄存器」。这些寄存器用来「存储整数数据和指针」。</p>
<blockquote>
<p>每个 CPU core 都有各自的寄存器。</p>
</blockquote>
<p>如图：</p>
<figure><img src="/images/integer-registers.jpg"
         alt="整数寄存器"/><figcaption>
            <p>整数寄存器</p>
        </figcaption>
</figure>

<p>所有 16 个寄存器的低位部分都可以作为字节、字（16位）、双字（32位）和四字（64位）数字访问，即：</p>
<ul>
<li>字节级操作可以访问最低的字节（8位）。</li>
<li>16 位操作可以访问最低的 2 个字节（16位）。</li>
<li>32 位操作可以访问最低的 4 个字节（32位）。</li>
<li>64 位操作可以访问整个寄存器。</li>
</ul>
<p>程序计数器是特殊的寄存器，通常称为 PC，在 x86-64 中用 %rip 表示，它给出将要执行的下一条指令在内存中的地址。</p>
<blockquote>
<p>在常见的程序里不同的寄存器扮演不同的角色，其中最特别的是「栈指针 %rsp」，它用来指明运行时栈的结束位置。</p>
</blockquote>
<p>有一组标准的编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数的返回值，以及存储局部和临时数据。</p>
<h3 id="寻址方式">寻址方式</h3>
<p>大多数指令有一个或多个操作数（operand）。指令的操作数分为三种类型：</p>
<ul>
<li>立即数（immediate），用来表示常数值。如 <code>$-577</code>，<code>$0x1F</code>。</li>
<li>寄存器（register），表示某个寄存器的内容。</li>
<li>内存引用 ，它会根据计算出来的地址（通常称为有效地址）访问某个内存位置，也就是读取内存位置所存放的值。</li>
</ul>
<p>内存引用有多种不同的形式，最常用的形式为：$Imm(r_b，r_i，s)$。这样的引用有四个组成部分：</p>
<ul>
<li>一个立即数偏移量 $Imm$。</li>
<li>一个基址寄存器 $r_b$。</li>
<li>一个变址寄存器 $r_i$。</li>
<li>一个比例因子 $s$。$s$ 必须是 1、2、4 或者 8。</li>
</ul>
<p>它所表示的地址可以这样计算出来：</p>
<p>$$Imm+R[r_b]+R[r_i] \cdot s$$</p>
<p>符号说明：符号 $r_a$ 表示任意寄存器 $a$，$R[r_a]$ 表示它的值。这是将寄存器集合看成一个数组 $R$，用寄存器标识作为索引。</p>
<p>其他形式都是这种形式的特殊情况，只是省略了某些部分，相当于这些部分是 0。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>格式</th>
<th>操作数类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接（绝对）寻址（Direct/Absolute Addressing Mode））</td>
<td>$Imm$</td>
<td>Memory</td>
<td>只使用 $Imm$ 寻址，例如 movl 0x20, %eax。把地址 0x20 处的 32 位数传送到 eax 寄存器。注意与立即数寻址的区别，这里是直接的内存地址。</td>
</tr>
<tr>
<td>间接寻址（Indirect Addressing Mode）</td>
<td>($r_b$)</td>
<td>Memory</td>
<td>只使用 $r_b$ 寻址。例如 movl (%eax), %ebx。把 eax 寄存器的值看做内存地址，把内存中这个地址处的 32 位数传送到 ebx 寄存器。<strong>注意与 movl %eax, %ebx 区分开来</strong>。</td>
</tr>
<tr>
<td>(基址+偏移量)寻址（Base Pointer Addressing Mode）</td>
<td>$Imm(r_b)$</td>
<td>Memory</td>
<td>只使用 $Imm$ 和 $r_b$ 寻址，例如 movl 4(%eax), %ebx。用于访问结构体成员比较方便，例如一个结构体的基地址保存在 eax 寄存器中，其中一个成员在结构体内的偏移量是 4 字节，要把这个成员读上来就可以用这条指令</td>
</tr>
<tr>
<td>变址寻址（Indexed Addressing Mode）</td>
<td>$(r_b,r_i)、Imm(r_b,r_i)$、$(,r_i,s)、Imm(,r_i,s)$、$(r_b,r_i,s)$、$Imm(r_b，r_i,s)$</td>
<td>Memory</td>
<td>例如 movl items(,%edi,4), %eax 就属于这种寻址方式，用于访问数组元素比较方便</td>
</tr>
<tr>
<td>立即数寻址（Immediate Mode）</td>
<td>$Imm$</td>
<td>立即数</td>
<td>就是指令中有一个操作数是立即数，例如 <code>movl $12, %eax</code>中的 $12，这其实跟寻址没什么关系，但也算作一种寻址方式。</td>
</tr>
<tr>
<td>寄存器寻址（Register Addressing Mode）</td>
<td>$r_a$</td>
<td>Register</td>
<td>就是指令中有一个操作数是寄存器，例如movl $12, %eax 中的 %eax，这跟内存寻址没什么关系，但也算作一种寻址方式。</td>
</tr>
</tbody>
</table>
<p>看几个例子，加深理解，假设下面的值存放在指明的内存地址和寄存器中：</p>
<table>
<thead>
<tr>
<th>内存地址</th>
<th>值</th>
<th>寄存器</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x100</td>
<td>0xFF</td>
<td>%rax</td>
<td>0x100</td>
</tr>
<tr>
<td>0x104</td>
<td>0xAB</td>
<td>%rcx</td>
<td>0x1</td>
</tr>
<tr>
<td>0x108</td>
<td>0x13</td>
<td>%rdx</td>
<td>0x3</td>
</tr>
<tr>
<td>0x10c</td>
<td>0x11</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>给出所示操作数的值：</p>
<table>
<thead>
<tr>
<th>操作数</th>
<th>值</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>%rax</td>
<td>0x100</td>
<td>寄存器寻址</td>
</tr>
<tr>
<td>0x104</td>
<td>0xAB</td>
<td>直接寻址</td>
</tr>
<tr>
<td>$0x108</td>
<td>0x108</td>
<td>立即数寻址</td>
</tr>
<tr>
<td>(%rax)</td>
<td>0xFF</td>
<td>间接寻址，内存地址 0x100</td>
</tr>
<tr>
<td>4(%rax)</td>
<td>0xAB</td>
<td>变址寻址，内存地址 0x104</td>
</tr>
<tr>
<td>9(%rax,%rdx)</td>
<td>0x11</td>
<td>变址寻址，内存地址 0x10c</td>
</tr>
<tr>
<td>260(%rcx,%rdx)</td>
<td>0x13</td>
<td>变址寻址，内存地址 0x108。十进制 264 用十六进制表示就是 0x108</td>
</tr>
<tr>
<td>0xFC(,%rcx, 4)</td>
<td>0xFF</td>
<td>变址寻址，内存地址 0x100</td>
</tr>
<tr>
<td>(%rax,%rdx, 4)</td>
<td>0x11</td>
<td>变址寻址，内存地址 0x10c</td>
</tr>
</tbody>
</table>
<h3 id="数据传送指令">数据传送指令</h3>
<p>数据传送指令（Move）是将数据从一个位置复制到另一个位置的指令，它有两个操作数：源操作数和目的操作数。</p>
<ul>
<li>源操作数指定的值是一个立即数，存储在寄存器（register）中或者内存（memory）中。</li>
<li>目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址。</li>
<li>X86-64 限制传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令。第一条指令将源值加载到寄存器中，第二条将寄存器的值写入目的位置。</li>
</ul>
<p>寄存器部分的大小必须与指令最后一个字符（&lsquo;b&rsquo;, &lsquo;w&rsquo;, &rsquo;l&rsquo; 或 &lsquo;q&rsquo;）指定的大小匹配，如：</p>
<pre tabindex="0"><code>movl $0x4050, %eax         Immediate -- Register, 4 bytes
movb $-17, (%rsp)          Immediate -- Memory,   1 bytes
movb (%rdi, %rcx), %al     Memory -- Register,    1 bytes
movw %bp, %sp              Register -- Register,  2 bytes
movq %rax, -12(%rbp)       Register -- Memory,    8 bytes
</code></pre><p>可以看到上面的 movl 指令是传送 4 个字节的数据到寄存器中，所以寄存器用 32 位的 <code>%eax</code>。同样的，movb 指令是传送 1 个字节的数据，寄存器用 8 位的 <code>%al</code>。后面的 <code>%bp</code>、<code>%sp</code>、<code>%rax</code> 也都是与指令最后一个字符指定的大小相匹配的。</p>
<p>当指令以寄存器为目的操作数时，对于生成小于 8 字节的指令，寄存器中剩下的字节会怎样处理呢？对此有两条规则：</p>
<ul>
<li>生成 1 字节和 2 字节数字的指令会保持剩下的字节不变。</li>
<li>生成 4 字节的指令会把高位 4 个字节置为 0。
<ul>
<li>movl 指令以寄存器作为目的操作数时，它会将寄存器的高 4 字节置为 0。</li>
</ul>
</li>
</ul>
<p>例如：</p>
<pre tabindex="0"><code>movabsq $0x0011223344556677, %rax      %rax = 0011223344556677
movb    $-1, %al                       %rax = 00112233445566FF
movw    $-1, %ax                       %rax = 001122334455FFFF
movl    $-1, %eax                      %rax = 00000000FFFFFFFF
movq    $-1, %rax                      %rax = FFFFFFFFFFFFFFFF
</code></pre><p>第一条 <code>movabsq</code> 指令传送绝对的四字，能够以任意 64 位立即数作为源操作数，并且只以寄存器作为目的操作数。在这里它把寄存器 %rax 初始化为位模式 0011223344556677。</p>
<p>在将较小的源值传送到较大的目的时，需要先对源值做扩展：</p>
<ul>
<li><code>MOVZ S, R</code> 类的指令是做零扩展，用 0 填充。</li>
<li><code>MOVS S, R</code> 类的指令是做符号扩展，用符号为来填充。</li>
</ul>
<p>例如，%dl = AA，执行 movzbl %dl, %eax 后 %eax = 000000AA。movzbl 指令会先对 %dl 的值做零扩展到 32 位（命令中的字符 l 指明了目的的大小，b 表示源值的大小），也就是前 24 位填充 0，再将值传送到 %eax 中。执行 movsbl %dl, %eax 后 %eax=FFFFFFAA。</p>
<blockquote>
<p>数据传送指令中有一条 cltq 指令。这条指令没有操作数：它总是以寄存器 %eax 为源操作数，%rax 为符号扩展结果的目的操作数。它的效果与指令 movslq %eax, %rax 完全一致。</p>
</blockquote>
<p>下面结合 C 程序来看一个数据传送的示例：</p>
<p>C 代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">exchange</span>(<span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>p, <span style="color:#66d9ef">long</span> y) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> x <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>xp;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>xp <span style="color:#f92672">=</span> y;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> x;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>汇编代码：</p>
<pre tabindex="0"><code>    long exchange(long *xp, long y)
    xp in %rdi, y in %rsi

1   exchange:
2     movq  (%rdi), %rax      Get x at xp. Set as return value.
3     movq  %rsi, (%rdi)      Store y at xp.
4     ret                     Return
</code></pre><p>我们看到函数 exchange 由三条指令实现：两条数据传送（movq），加上一条返回函数被调用点的指令（ret）。</p>
<p>当过程开始执行时，过程参数 xp 和 y 分别存储在寄存器 %rdi 和 %rsi 中。然后，指令 2 从内存中读出 x，把它存放到寄存器 %rax 中，直接实现了 C 程序中的 x=*xp 操作。指令 3 将 y 写入到寄存器 %rdi 中的 xp 指向的内存位置，直接实现了操作 *xp=y。</p>
<p>从这个段汇编代码中我们可以看到这么两点：</p>
<ul>
<li>C 语言中所谓的“指针”其实就是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用（$Imm(r_b,r_i,s)$)中使用这个寄存器。</li>
<li>局部变量（如：x）通常保存在寄存器中，而不是内存中。访问寄存器比访问内存要快得多。</li>
</ul>
<p>有关 C 指针的一些示例：</p>
<pre tabindex="0"><code>char *p;
p = &amp;a;        // p 存储的是地址。C 操作符 &amp; 称为“取址” 操作符，它创建一个指针。

char b = *p;   // 读取 p 所指向位置中的值，并将它存放到变量 b 中。C 操作符 * 执行指针的间接引用。
*p = c;        // 将 c 的值写到 p 所指向的位置。这也是指针间接引用的一种形式。
</code></pre><h3 id="压入和弹出栈数据">压入和弹出栈数据</h3>
<p>「栈」是一个种数据结构，可以添加或者删除值，不过要遵循“后进先出”的原则。通过 push 操作把数据压入栈中，通过 pop 操作弹出（删除）数据。pop 操作的值永远是最近被压入而且仍然在栈中的值。</p>
<p>在 x86-64 中，程序栈存放在内存中某个区域。<code>pushq</code> 指令把数据压入到栈中，<code>popq</code> 指令从栈中弹出数据。这两条指令都只有一个操作数。</p>
<figure><img src="/images/push-pop-instructions.jpg"
         alt="入栈和出栈指令。操作数 S：表示压入栈的数据源，操作数 D：表示弹出的数据目的" width="600"/><figcaption>
            <p>入栈和出栈指令。操作数 S：表示压入栈的数据源，操作数 D：表示弹出的数据目的</p>
        </figcaption>
</figure>

<p>将一个四字的值压入栈中，首先要将栈指针减 8，然后将值写到新的栈地址。因此，指令 pushq %rbp 的行为等价于下面两条指令：</p>
<pre tabindex="0"><code>subq $8, %rsp        Decrement stack Pointer
movq %rbp, (%rsp)    Store %rbp on stack
</code></pre><p>弹出一个四字的操作，首先是从栈顶位置读出数据，然后将栈指针加 8。因此，指令 popq %rax 等价于下面两条指令：</p>
<pre tabindex="0"><code>movq (%rsp), %rax      Read %rax from stack
addq $8, %rsp          Increment stack pointer
</code></pre><p>栈总是从一端压入或弹出数据。这一端称之为「栈顶」。</p>
<p>在 x86-64 中，「<strong>栈向低地址方向增长，栈顶元素的地址是所有栈元素地址中最低的</strong>」。栈指针 %rsp 保存着栈顶元素的地址。所以压栈是减小栈指针（寄存器 %rsp）的值，并将数据存放到内存中，而出栈是从内存中读数据，并增加栈指针的值。</p>
<p>看一个栈操作的例子。最开始是 %rsp 为 0x108，%rax 为 0x123。</p>
<figure><img src="/images/stack-operation.jpg"
         alt="栈操作" width="600"/><figcaption>
            <p>栈操作</p>
        </figcaption>
</figure>

<p>执行指令 <code>pushq %rax</code>，首先将 %rsp 减去 8，得到 0x100，然后把值 0x123 存放到内存地址 0x100 处。</p>
<p>执行完 pushq 指令后，接着就执行 <code>popq %rdx</code> 指令，这时先从内存中读出值 0x123，再写到寄存器 %rdx 中，最后，寄存器 %rsp 的值增加 8，回到了 0x108。</p>
<p>我们可以看到，<strong>%rsp 指向的地址总是栈顶</strong>。</p>
<p>栈和程序代码以及其他形式的程序数据都是放在同一个内存中的，<strong>程序可以用标准的内存寻址方法访问栈内的任意位置</strong>。例如，假设栈顶元素是四字，指令 movq 8(%rsp), %rdx 会将第二个四字从栈中复制到寄存器 %rdx。</p>
<h2 id="算术和逻辑操作">算术和逻辑操作</h2>
<p>在 x86-64 中的算术和逻辑操作，可以分为四组：加载有效地址、一元操作、二元操作和移位。二元操作有两个操作数，一元操作只有一个操作数。</p>
<figure><img src="/images/integer-arithmetic-operations.jpg"
         alt="整数算术操作" width="600"/><figcaption>
            <p>整数算术操作</p>
        </figcaption>
</figure>

<p>加载有效地址（Load effective address) 指令 <code>leaq S, D</code>:</p>
<ul>
<li>S 是地址表达式。</li>
<li>D 是一个寄存器。</li>
</ul>
<p>leaq 指令是将 D 设置为 S 表达式计算出来的地址。例如，leaq (%rdx, %rcx, 4), %rax，它会将表达式 <code>R[%rdx] + R[%rcx] * 4</code> 计算出来的地址，写入到寄存器 %rax 中。</p>
<p>需要特别注意：leaq 指令的第一个操作数 S，只做数学计算，不做内存引用。</p>
<p>用一个例子来对 leaq 和 movq 指令做个比较，能更好的理解它。</p>
<figure><img src="/images/leaq-vs-movq.jpg"
         alt="leaq vs movq" width="600"/><figcaption>
            <p>leaq vs movq</p>
        </figcaption>
</figure>

<p>这种只做数学运算不做内存引用的特点，使得 leaq 指令在一些简单的算术表达式中很有用处。</p>
<p>例如，有这么一个 C 函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">arith</span> (<span style="color:#66d9ef">long</span> x, <span style="color:#66d9ef">long</span> y, <span style="color:#66d9ef">long</span> z) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> t1 <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> y;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> t2 <span style="color:#f92672">=</span> z <span style="color:#f92672">+</span> t1;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> t3 <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> t4 <span style="color:#f92672">=</span> y <span style="color:#f92672">*</span> <span style="color:#ae81ff">48</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> t5 <span style="color:#f92672">=</span> t3 <span style="color:#f92672">+</span> t4;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> rval <span style="color:#f92672">=</span> t2 <span style="color:#f92672">*</span> t5;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> rval;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>编译时，该函数的算术运算会以 leaq 来实现。汇编代码如下：</p>
<pre tabindex="0"><code>  long arith (long x, long y, long z)
  x in %rdi, y in %rsi, z in %rdx

arith:
  leaq  (%rdi, %rsi), %rax            #t1 = x + y
  addq  %rdx, %rax                    #t2 = z + t1;
  leaq  (%rsi, %rsi, 2), %rdx         #y+2y=3y
  salq  $4, %rdx                      #t4 = 3y * 16 = y * 48
  leaq  4(%rdi, %rdx), %rcx           #t5 = 4 + x + t4 = t3 + t4
  imulq %rcx, %rax                    #return t2 * t5
  ret
</code></pre><hr>
<p><code>subq %rax, %rdx </code> 指令，可以解读成 &ldquo;从 %rdx 中减去 %rax&rdquo;。subq 指令有两个操作数：</p>
<ul>
<li>第一个操作数是源操作数，可以是立即数、寄存器或是内存位置。</li>
<li>第二个操作数是目的操作数，它既是源又是目的，可以是寄存器或是内存位置。当为内存位置时，处理器必须<strong>从内存读出值</strong>，执行操作，再把结果写回内存。</li>
</ul>
<p>例如，给出内存地址和寄存器的情况的如下：</p>
<pre tabindex="0"><code>Memory Address  |  Value            Register |  Value
---------------------------       -----------------------
  0x100         |   0xFF              %rax   |  0x100
  0x108         |   0xAB              %rcx   |  0x1
  0x110         |   0x13              %rdx   |  0x3
</code></pre><p>执行指令</p>
<pre tabindex="0"><code>Instruction          |  Destination  |  Value
-----------------------------------------------
  addq %rcx, (%rax)  |   0x100       |  0x100
  subq %rdx, 8(%rax) |   0x108       |  0xA8
</code></pre><p>目的操作数 (%rdx)、8(%rax) 都为内存地址，要先从内存中读出值，它们的值分别为 0xFF、0xAB，执行操作后，再把结果写回到内存。最后，内存地址 [0x100] 的值为 0x100，内存地址 [0x108] 的值为 0xA8。</p>
<hr>
<p><code>sal、shl</code> 为左移位指令，两者都是将右边填上 0。</p>
<p><code>sar</code> 为算术右移，填符号为。</p>
<p><code>shr</code> 为逻辑右移，填上 0。</p>
<p>移位操作的源操作数为移位量，可以是一个立即数，或者放在单字节寄存器 %cl 中。目的操作数为要移位的数，可以是一个寄存器或是一个内存位置。</p>
<p>例如：</p>
<pre tabindex="0"><code>sal $4, %rax
sar %cl, %rax
</code></pre><hr>
<p><code>xorq %rdx, %rdx</code>，这条指令会将寄存器 %rdx 设置为 0。对于任意 x，x^x = 0。</p>
<h2 id="控制">控制</h2>
<p>C 语言中的条件语句、循环语言和分支语言，要求有条件的执行，根据测试的结果决定操作执行的顺序。机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。</p>
<p>除了整数寄存器，CPU 还维护着一组「<strong>单个位</strong>（single bit）」的「条件码」（condition code）寄存器，它们描述了最近算术或逻辑操作的情况。可以检查这些寄存器来执行条件分支指令。</p>
<p>最常用的条件码有：</p>
<ul>
<li>CF：进位标志。最近的操作使最高位产生了进位。可以用来检查无符号操作是否溢出。</li>
<li>ZF：零标志。最近的操作得出的结果为 0。</li>
<li>SF：符号标志。最近的操作得到的结果为负数。</li>
<li>OF：溢出标志。最近的操作导致一个补码溢出。</li>
</ul>
<p>除了 leaq 指令不改变任何条件码，前面（图：<em>整数算术操作</em>）列出的算术和逻辑操作指令都会设置条件码。</p>
<ul>
<li>对于逻辑操作，例如 XOR，进位标志（CF）和溢出标志（OF）会设置为 0.</li>
<li>对于移位操作，进位标志将设置为最后一个被移出的位，而溢出标志设置为 0。</li>
<li>INC 和 DEC 指令会设置溢出和零标志，但不会改变进位标志。</li>
</ul>
<p>另外，CMP 和 TEST 这两类指令也会设置条件码，但它们不会改变任何其他的寄存器，就是说不会更新目的寄存器。比如，<code>cmp S1, S2 </code>指令根据两个操作数之差（S2-S1）来设置条件码，它不会改变 S2 的值。</p>
<p><code>test S1, S2</code> 指令的结果是基于 S1&amp;S2。典型的用法是，两个操作数是一样，比如，testq %rax, %rax 指令用来检查 %rax 是负数、零，还是正数。或者其中一个操作数是一个掩码，用来指示哪些为应该被测试。</p>
<hr>
<p>条件码通常不会直接读取，常用的使用方法有三种：</p>
<ul>
<li>可以根据条件码的某种组合将一个字节设置为 0 或者 1。</li>
<li>可以条件跳转到程序的某个其他的部分。</li>
<li>可以有条件地传送数据。</li>
</ul>
<p>SET 指令就是根据条件码的某种组合，将一个字节设置为 0 或者 1。</p>
<figure><img src="/images/setx.jpg"
         alt="SET 指令" width="600"/><figcaption>
            <p>SET 指令</p>
        </figcaption>
</figure>

<ul>
<li>SET 指令的目的操作数是低位单字节寄存器（如 al、dl）之一，或者是一个字节的内存位置。</li>
<li>SET 指令不会修改寄存器的剩余字节。
<ul>
<li>通常用 <code>movzbl</code> 指令来将高 32 位设置为 0。</li>
<li>我们知道，在 x86-64 中，任何为寄存器生成 32 位（4 字节）值的指令，也会将寄存器的高位部分（最高 4 个字节）设置为 0。比如，movl、movzbl、movsbl。</li>
</ul>
</li>
</ul>
<p>例如，有 C 代码：</p>
<pre tabindex="0"><code>int gt(long x, long y) {
  return x &gt; y;
}
</code></pre><p>它的汇编指令如下：</p>
<pre tabindex="0"><code>  int get(long x, long y)
  x in %rdi, y int %rsi

gt:
  cmpq    %rsi, %rdi  # compare x:y
  setg    %al         # al = x &gt; y
  movzbl  %al, %eax   # Zero rest of %rax
  ret
</code></pre><p>先是执行比较指令，根据计算（y - x）设置条件码。然后，setg 指令根据条件码的组合（~(SF^0F)&amp;~ZF），将 %al 设置为 0 或 1。最后，movzbl 指令将高位填充为 0 传送到 %rax 作为结果返回。</p>
<hr>
<p>正常情况下，指令按照它们出现的顺序一条一条地执行。跳转（jump）指令会导致执行切换到程序中一个全新的位置。</p>
<ul>
<li>它根据条件码跳转到代码的不同部分。</li>
<li>跳转的目的地是一个地址。在汇编代码中，通常用一个标号（Label）指明。</li>
</ul>
<p><code>jmp</code> 指令是无条件跳转。它可以是直接跳转，即跳转目标是作为指令的一部分编码的；也可以是间接跳转，即跳转目标是从寄存器或内存位置中读出的。</p>
<p>例如，直接跳转，用一个标号作为跳转目标：</p>
<pre tabindex="0"><code>jmp .L1     # L1 为标号。
</code></pre><p>间接跳转，在 “*” 号后面跟一个操作数指示符：</p>
<pre tabindex="0"><code>jmp *%rax   # 用寄存器 %rax 中的值作为跳转目标

jmp *(%rax) # 以 %rax 中的值作为读地址，从内存中读出跳转目标
</code></pre><p>详细的跳转指令表：</p>
<figure><img src="/images/jump.jpg"
         alt="跳转指令"/><figcaption>
            <p>跳转指令</p>
        </figcaption>
</figure>

<p>除 jmp 之外，表中其他的跳转指令都是有条件的，它们根据条件码的某种组合，跳转或继续执行代码序列中下一条指令。</p>
<p>跳转目标在汇编和链接时会进行编码，最常用的编码方法是「PC-relative」（PC 相对的）。<strong>它会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码</strong>。另外一种编码方法是给出 “绝对” 地址，用 4 个字节直接指定目标。汇编器和链接器会选择适当的编码方法。</p>
<p>下面是一个 PC-relative 的例子，假设有一个函数的汇编代码如下：</p>
<pre tabindex="0"><code>   movq  %rdi, %rax
   jmp   .L2
 .L3:
   sarq  %rax
 .L2
   testq %rax, %rax
   jg    .L3
   rep；ret
</code></pre><p>汇编器产生的 &ldquo;.o&rdquo; 格式的反汇编代码如下：</p>
<pre tabindex="0"><code>1    0:    48 89 f8          mov   %rdi,%rax
2    3:    eb 03             jmp   8 &lt;loop+0x8&gt;
3    5:    48 d1 f8          sar   %rax
4    8:    48 85 c0          test  %rax,%rax
5    b:    7f f8             jg    5 &lt;loop+0x5&gt;
6    d:    f3 c3             repz retq
</code></pre><p>从反汇编的代码中可以看到，第 2 行和第 5 行中跳转指令的跳转目标分别指明为 0x8 和 0x5。观察指令的字节编码，会看到第一条跳转指令的目标编码（在第二个字节中）为 0x03。把它加上 0x5（也就是下一条指令的地址），就得到跳转目标地址 0x8，也就是第 4 行指令的地址。类似地，第二条跳转指令的目标编码是 0xf8，将它加上 0xd（第 6 行指令的地址），得到跳转目标地址 0x5，也就是第 3 行指令的地址。</p>
<p>下面是经过链接器链接后的程序反编译代码：</p>
<pre tabindex="0"><code>1    4004d0:    48 89 f8          mov   %rdi,%rax
2    4004d3:    eb 03             jmp   4004d8 &lt;loop+0x8&gt;
3    4004d5:    48 d1 f8          sar   %rax
4    4004d8:    48 85 c0          test  %rax,%rax
5    4004db:    7f f8             jg    4004d5 &lt;loop+0x5&gt;
6    4004dd:    f3 c3             repz retq
</code></pre><p>链接之后，这些指令被「重定位」到不同的地址，但是第 2 行和第 5 行中跳转目标的编码并没有变。</p>
<hr>
<h3 id="实现条件分支">实现条件分支</h3>
<p>条件分支的实现方式有两种：</p>
<ul>
<li>使用「控制」的条件转移实现。
<ul>
<li>当条件满足时，程序沿着一条执行路径执行，当条件不满足时，就走另一条路径。</li>
<li>这种机制，在现代处理器上，非常低效。</li>
</ul>
</li>
<li>使用「数据」的条件转移实现
<ul>
<li>计算一个条件操作的两种结果，然后根据条件是否满足从中选取一个。</li>
<li>这种策略只有在一些受限制的情况中才可行，一旦可行，就可以用一条简单的「条件传送」指令来实现它，条件传送指令更符合现代处理器的性能特性。</li>
</ul>
</li>
</ul>
<p>例如，一个计算两个数之差的 C 函数如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">absdiff</span>(<span style="color:#66d9ef">long</span> x, <span style="color:#66d9ef">long</span> y) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> result;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">&gt;</span> y)
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> x<span style="color:#f92672">-</span>y;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> y<span style="color:#f92672">-</span>x;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用条件控制实现的汇编代码。编译命令：gcc –Og -S –fno-if-conversion control.c</p>
<pre tabindex="0"><code>  long absdiff(long x, long y)
  x in %rdi, y in %rsi

absdiff:
  cmpq    %rsi, %rdi  # Compare x:y
  jle     .L4
  movq    %rdi, %rax
  subq    %rsi, %rax
  ret
.L4:      # x &lt;= y
  movq    %rsi, %rax
  subq    %rdi, %rax
  ret
</code></pre><p>使用条件数据传送实现的汇编代码</p>
<pre tabindex="0"><code>  long absdiff(long x, long y)
  x in %rdi, y in %rsi

absdiff：
  movq    %rdi, %rax  # x
  subq    %rsi, %rax  # result = x-y
  movq    %rsi, %rdx
  subq    %rdi, %rdx  # else_val = y-x
  compq   %rsi, %rdi  # Compare x:y
  cmovle  %rdx, %rax  # if &lt;=, result = else_val
  ret
</code></pre><p>基于条件数据传送的代码比基于条件控制转移的代码性能要好的原因是：处理器<strong>无需预测</strong>测试的结果<strong>就可以执行条件传送</strong>。</p>
<p>现代处理器通过使用「流水线」（pipelining）技术来获得高性能。在流水线中，一条指令的处理要经过一系列的「阶段」，每个阶段执行所需操作的一小部分（比如，从内存取指令、确定指令类型、从内存读数据、执行算术运算、向内存写数据，以及更新程序计数器）。流水线技术通过重叠连续指令的步骤，从而获得高性能。例如，在取一条指令的同时，执行它前面一条指令的算术运算。要做到这一点，要求能够事先确定要执行的指令序列，这样才能保证流水线中充满待执行的指令。当机器遇到「条件跳转」（也就是“分支”）时，只有当分支条件求值完成之后，才能决定分支往哪边走。现代处理器采用非常精密的「分支预测逻辑」来猜测每条跳转指令是否会执行。分支预测是否正确，成了性能好坏的关键。现代处理器设计试图达到 90% 以上的预测成功率。同条件跳转不同，处理器<strong>无需预测</strong>测试的结果<strong>就可以执行条件传送</strong>。处理器只是读源值（可能是从内存中），检查条件码，然后要么更新目的寄存器，要么保持不变。</p>
<p>详细的条件传送指令表：</p>
<figure><img src="/images/cmovx.jpg"
         alt="条件传送指令" width="600"/><figcaption>
            <p>条件传送指令</p>
        </figcaption>
</figure>

<p>每条指令都有两个操作数：源寄存器或者内存地址 S，和目的寄存器 R。当传送条件满足时，指令把源值 S 复制到目的 R。</p>
<h3 id="循环">循环</h3>
<p>C 语言提供了多种循环结构，即 do-while、while 和 for。汇编中没有相应的指令，它通过条件「测试」和「跳转」的组合来实现循环效果。</p>
<p>GCC 产生的循环代码主要基于两种基本的循环模式：</p>
<ul>
<li>do-while 循环</li>
<li>while 循环</li>
</ul>
<h4 id="do-while-循环">do-while 循环</h4>
<p>do-while 语句的通用形式：</p>
<pre tabindex="0"><code>do 
  Body
  while (Test);
</code></pre><p>这种通用形式可以被翻译成下面的条件和 goto 语句：</p>
<pre tabindex="0"><code>loop:
    Body
    if (Test)
        goto loop;
</code></pre><p>例如，有一个 C 函数 fact_do</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">fact_do</span>(<span style="color:#66d9ef">long</span> n) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">*=</span> n;
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">while</span> (n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对应的汇编代码：</p>
<pre tabindex="0"><code>  long fact_do(long n)
  n in %rdi

fact_do:
  movl   $1, %eax       # Set result = 0
.L2:                    # loop:
  imulq  %rdi, %rax     # Compute result *= n
  subq   $1, %rdi       # Decrement n
  cmpq   $1, %rdi       # Compare n:1
  jn     .L2            # if &gt;, goto loop
  rep; ret              # return (rep weird)
</code></pre><p>从汇编代码可以看到，它是利用条件测试和跳转来实现的循环。</p>
<p>上面的 C 代码，也可以用 goto 语句来实现循环：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">fact_do_goto</span>(<span style="color:#66d9ef">long</span> n) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>loop: 
</span></span><span style="display:flex;"><span>  result <span style="color:#f92672">*=</span> n;
</span></span><span style="display:flex;"><span>  n <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> loop:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对比一下，我们就能看到汇编代码其实就是 goto 代码的原型。</p>
<h4 id="while-循环">while 循环</h4>
<p>while 语句的通用形式：</p>
<pre tabindex="0"><code>while (Test)
  Body
</code></pre><p>有很多种方法将 while 循环翻译成机器代码，GCC 在代码生成中使用了其中的两种方法。第一种翻译方法称为「跳转到中间」（jump to middle）：</p>
<ul>
<li>它执行一个无条件跳转到循环结尾处的测试，以此来执行初始的测试。</li>
<li>编译时使用 -Og 选项。</li>
</ul>
<p>可以用下面的 goto 代码来表达这种方法：</p>
<pre tabindex="0"><code>  goto test
loop:
  Body
test:
  if (Test)
    goto loop;
</code></pre><p>第二种翻译方法，称之为「guarded-do」：</p>
<ul>
<li>它首先用条件分支，如果初始条件不成立就跳过循环，把代码变换为 do-while 循环。</li>
<li>编译时使用 –O1 选项。</li>
</ul>
<p>可以用如下的 do-while 循环表达这种方法：</p>
<pre tabindex="0"><code>if (!Test)
  goto done;
do
  Body
  while (Test)
done:
</code></pre><p>也可以用 goto 代码来表达：</p>
<pre tabindex="0"><code>  if (!Test)
    goto done;
loop:
  Body
  if (Test)
    goto loop;
done:
</code></pre><h4 id="for-循环">for 循环</h4>
<p>for 循环的通用形式：</p>
<pre tabindex="0"><code>for (Init; Test; Update)
  Body;
</code></pre><p>GCC 为 for 循环产生的代码是 while 循环的两种翻译之一，具有是哪一种取决于优化的等级。</p>
<h3 id="switch-语句">switch 语句</h3>
<p>switch（开关）语句可以根据一个整数索引值进行多重分支（multiway branching）。与使用一组很长的 if-else 语句相比，switch 可以利用「跳表」（jump table）这种数据结构使得实现更加高效，让执行 switch 语句的时间与开关情况的数量无关。</p>
<figure><img src="/images/jump-table.jpg"
         alt="switch 与跳表" width="600"/><figcaption>
            <p>switch 与跳表</p>
        </figcaption>
</figure>

<p>在汇编代码中，跳表用以下的声明表示：</p>
<figure><img src="/images/jump-table-as.jpg"
         alt="跳表在汇编代码中的表示" width="600"/><figcaption>
            <p>跳表在汇编代码中的表示</p>
        </figcaption>
</figure>

<h2 id="过程">过程</h2>
<p>过程是软件中一种重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可以选的返回值实现了某种功能。过程的形式：</p>
<ul>
<li>函数（function）</li>
<li>方法（method）</li>
<li>子例程（subroutine）</li>
<li>处理函数（handler）</li>
</ul>
<p>过程调用，包含的动作：（假设过程 P 调用过程 Q，Q 执行后返回到 P）</p>
<ul>
<li>传递控制。在进入过程 Q 的时候，程序计数器（%rip）必须被设置为 Q 的代码的起始地址，然后在返回时，要把程序计数器（%rip）设置为 P 中调用 Q 后面那条指令的地址。</li>
<li>传递数据。P 必须能够向 Q 提供一个或多个参数，Q 必须能够向 P 返回一个值。</li>
<li>分配和释放内存。在开始时，Q 可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。</li>
</ul>
<p>x86-64 的过程实现包括一组特殊的指令和一些对机器资源（例如，寄存器和程序内存）使用的约定规则。</p>
<h3 id="运行时栈">运行时栈</h3>
<p>程序用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需的信息。</p>
<p>栈是一块内存区域，由系统自动分配。</p>
<figure><img src="/images/memory-layout.jpg"
         alt="内存的布局" width="600"/><figcaption>
            <p>内存的布局</p>
        </figcaption>
</figure>

<p>x86-64 的栈向低地址方向增长，栈指针（寄存器 %rsp）指向栈顶元素。通过 pushq 和 popq 指令可以将数据存入栈中或是从栈中取出。将栈指针减小一个适当的量可以为没有指定初始值的数据在栈上分配空间，而增加栈指针可以释放空间。</p>
<figure><img src="/images/stack-push-pop.jpg" width="600"/>
</figure>

<p>当 x86-64 过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这部分栈上分配的空间称为过程的栈帧（stack frame）。</p>
<figure><img src="/images/stack.jpg"
         alt="通用的栈帧结构" width="600"/><figcaption>
            <p>通用的栈帧结构</p>
        </figcaption>
</figure>

<p>当前正在执行的过程（如函数 Q）的帧总是在栈顶。当过程 P 调用过程 Q 时，会把返回地址压入栈中（作为 P 的栈帧的一部分），指明当 Q 返回时，要从 P 程序的那个位置继续执行。</p>
<p>大多数过程的栈帧都是定长的，在过程的开始就分配好了。实际上，在所有的局部变量都可以保存在寄存器中，而函数又不调用任何其他函数时，该函数是不需要栈帧的（不需要在栈上分配空间）。</p>
<h3 id="转移控制">转移控制</h3>
<p>将控制从函数 P 转移到函数 Q，只需要简单地把程序计数器（寄存器 %rip）设置为 Q 的代码的起始地址。不过，当从 Q 返回时，处理器必须要知道从 P 的哪个位置继续执行。在 x86-64 机器中，过程调用通过 <code>call Q</code> 指令完成，它会把返回地址 A 压入栈中，并将程序计数器（寄存器 %rip）设置为 Q 的起始地址。返回地址 A 是紧跟在 call 指令后面的那条指令的地址。例如：</p>
<pre tabindex="0"><code>400544: call 400550 &lt;mult2&gt;
400549: movq %rax, (%rax)
</code></pre><p>返回地址 A = 0x400549。从过程中返回通过 <code>ret</code> 指令完成，ret 指令会从栈中弹出返回地址 A，并把程序计数器设置为 A。</p>
<p>call 指令有一个目标操作数，指明被调用过程起始的指令地址。</p>
<ul>
<li>call .Label， 直接调用。</li>
<li>call *Operand，间接调用。</li>
</ul>
<p>通过一个例子来看一下 call 和 ret 指令的执行情况，在下图的反汇编代码中，multstore 函数调用了 mult2 函数。</p>
<figure><img src="/images/call-step-1.jpg"
         alt="执行 call" width="600"/><figcaption>
            <p>执行 call</p>
        </figcaption>
</figure>

<p>从上图中看到，在 multstore 函数中，执行到 call 指令时，程序计数器 %rip = 0x400544，栈指针 %rsp = 0x120。</p>
<figure><img src="/images/call-step-2.jpg"
         alt="call 执行之后" width="600"/><figcaption>
            <p>call 执行之后</p>
        </figcaption>
</figure>

<p>call 指令执行之后，返回地址 <code>0x400549</code> 压入到了栈中，程序计数器设置到了 mult2 函数的开始地址（第一条指令的地址），即 %rip = 0x400550。栈指针指向到栈顶 %rsp = 0x118。</p>
<figure><img src="/images/ret-step-1.jpg"
         alt="执行 ret" width="600"/><figcaption>
            <p>执行 ret</p>
        </figcaption>
</figure>

<p>在 mult2 函数执行到 ret 指令时，程序计数器 %rip = 0x40057，栈指针 %rsp = 0x118，没有变化。</p>
<figure><img src="/images/ret-step-2.jpg"
         alt="ret执行之后" width="600"/><figcaption>
            <p>ret执行之后</p>
        </figcaption>
</figure>

<p>ret 指令执行之后，返回地址被弹出了栈，并且程序计数器设置成了返回地址，即 %rip = 0x400549。栈指针指向到 0x120。</p>
<h3 id="数据传送">数据传送</h3>
<p>在调用一个过程时，除了把控制传递给它并在过程返回时再传递回来之外，过程调用还可能要传递一些参数，而从过程返回也可能要换回一个值。在 x86-64 中，大部分过程间的这种数据传送是通过「寄存器」实现的。</p>
<ul>
<li>x86-64 中，可以通过寄存器最多传递 6 个整型（例如整数和指针）参数。</li>
<li>如果一个函数有大于 6 个整型参数，超出 6 个的部分要通过「栈】来传递。
<ul>
<li>通过栈传递参数时，所有的数据大小都向 8 的倍数对齐。</li>
<li>参数是以参数列表相反的顺序入栈。</li>
</ul>
</li>
</ul>
<figure><img src="/images/register-stack-function-args.jpg" width="600"/>
</figure>

<p>寄存器的使用有特殊的顺序，在 x86-64 中，会根据参数在参数列表中的顺序为它们分配寄存器，第 1 个参数分配给 %rdi，第 2 个分配给 %rsi，第 3~6 依次为 %rdx, %rcx, %r8, %r9。从第 7 个参数开始，就要在栈上分配了。需要注意的是，<strong>参数 7 位于栈顶</strong>，也就是说，<strong>参数是以参数列表相反的顺序入栈的</strong>，对于参数 7～n 的入栈顺序是 n，n-1，&hellip;，7，最后一个参数先入栈。</p>
<p>按照约定，过程返回的值放在 %rax 寄存器中。</p>
<ul>
<li>被调用方将返回值放在 %rax 中。
<ul>
<li>%rax 能存放 8 个字节的数据。</li>
<li>超过 8 个字节，最好返回一个指向它们的指针。</li>
</ul>
</li>
<li>调用方从 %rax 读取返回值。</li>
</ul>
<p>下面是一个数据传送的例子：</p>
<pre tabindex="0"><code>void multstore(long x, long y, long *desc) {
  long t = mult2(x, y);
  *dest = t;
}

0000000000400540 &lt;multstore&gt;:
  # x in %rdi, y in %rsi, dest in %rdx
    • • •
  400541:  movq   %rdx, %rbx            # Save dest
  400544:  call   400550 &lt;mult2&gt;        # mult2(x,y)
  # t in %rax
  400549:  movq   %rax, (%rbx)          # Save at dest
    • • •


long mult2(long a, long b) {
  long s = a * b;
  return s;
}

0000000000400550 &lt;mult2&gt;:
  # a in %rdi, b in %rsi
  400550:  movq   %rdi, %rax     # a
  400553:  imulq  %rsi, %rax     # a * b
  # s in %rax
  400557: ret                    # Return
</code></pre><h3 id="栈上的局部存储">栈上的局部存储</h3>
<p>在这些情况下，局部数据需要存放到内存中：</p>
<ul>
<li>寄存器不能存放下所有的本地数据。</li>
<li>对一个局部变量使用地址运算符‘&amp;’，这时必须能够为它产生一个地址。</li>
<li>局部变量是数值或结构，这时必须能够通过数值或结构引用被访问到。</li>
</ul>
<p>一般来说，过程通过减小栈指针，在栈上分配空间。分配的结果作为栈帧的一部分，标号为“局部变量”（Local variables）。</p>
<p>下面是一个例子，体现了 x86-64 栈行为的一些特性。</p>
<pre tabindex="0"><code>long call_proc() {
  long x1 = 1;
  int x2 = 2;
  short x3 = 3;
  char x4 = 4;
  proc(x1, &amp;x1, x2, &amp;x2, x3, &amp;x3, x4, &amp;x4);
  return (x1 + x2) * (x3 - x4)
}


1   call_proc:
      # Set up arguments to proc
2     subq    $32, %rsp       # Allocate 32-byte stack frame
      ~~~~~~~~~~~~~~~~
3     movq    $1,  24(%rsp)   # Store 1 in &amp;x1
4     movl    $2,  20(%rsp)   # Store 2 in &amp;x2
5     movw    $3,  18(%rsp)   # Store 3 in &amp;x3
6     movb    $4,  17(%rsp)   # Store 4 in &amp;x4
7     leaq    17(%rsp), %rax  # Create &amp;x4
8     movq    %rax, 8(%rsp)   # Store &amp;x4 as argument 8
9     movl    $4, (%rsp)      # Store 4 as argument 7
10    leaq    18(%rsp), %r9   # Pass &amp;x3 as argument 6
11    movl    $3, %r8d        # Pass 3 as argument 5
12    leaq    20(%rsp), %rcx  # Pass &amp;x2 as argument 4
13    movl    $2, %edx        # Pass 2 as argument 3
14    leaq    24(%rsp), %rsi  # Pass &amp;x1 as argument 2
15    movl    $1, %edi        # Pass 1 as argument 1
      # Call proc
16    call  proc
      # Retrieve changes to memory
17    movslq  20(%rsp), %rdx  # Get x2 and convert to long
18    addq    24(%rsp), %rdx  # Compute x1+x2 
19    movswl  18(%rsp), %eax  # Get x3 and convert to int 
20    movsbl  17(%rsp), %ecx  # Get x4 and convert to int 
21    subl    %ecx, %eax      # Compute x3-x4 
22    cltq                    # Convert to long 
23    imulq   %rdx, %rax      # Compute (x1+x2) * (x3-x4) 
24    addq    $32, %rsp       # Deallocate stack frame
      ~~~~~~~~~~~~~~~~
25    ret                     # Return
</code></pre><p>可以看到代码中第2～15行都是为调用 proc 做准备，其中包括为局部变量和函数参数建立栈帧，将函数参数加载至寄存器。
过程 proc 的前 6 个参数通过寄存器传送，后面 2 个通过栈传送。</p>
<pre tabindex="0"><code>void proc(long a1, long *a1p, 
          int a2, int *a2p, 
          short a3, short *a3p, 
          char a4, char *a4p) {
  *a1p += a1;
  *a2p += a2;
  *a3p += a3;
  *a4p += a4;
}



    void proc(a1, a1p, a2, a2p, a3, a3p, a4, a4p) 
    # Arguments passed as follows:
    a1  in %rdi     (64 bits) 
    a1p in %rsi     (64 bits) 
    a2  in %edx     (32 bits) 
    a2p in %rcx     (64 bits) 
    a3  in %r8w     (16 bits) 
    a3p in %r9      (64 bits) 
    a4  at %rsp+8   (8 bits) 
    a4p at %rsp+16  (64 bits)

1   proc:
2     movq  16(%rsp), %rax     # Fetch a4p  (64 bits)
3     addq  %rdi, (%rsi)       # *a1p += a1 (64 bits)
4     addl  %edx, (%rcx)       # *a2p += a2 (32 bits)
5     addw  %r8w, (%r9)        # *a3p += a3 (16 bits)
6     movl  8(%rsp), %edx      # Fetch a4   (8 bits)
7     addb  %dl, (%rax)        # *a4p += a4 (8 bits)
8     ret                      # Return
</code></pre><p>我们看到在 proc 中读取参数 8（第2行）和 7（第6行）时，偏移量与入栈（第 8 和 9 行）时不一样。这是因为作为过程调用的一部分，返回地址被压入栈中（位于栈顶），因而这两个参数位于相对于栈指针（%rsp）距离为 8 和 16 的位置。</p>
<h3 id="存储器中的局部存储空间">存储器中的局部存储空间</h3>
<p>虽然在给定时刻只有一个过程是活动的，我们仍必须确保当一个过程（caller，调用者）调用另一个过程（callee，被调用者时，被调用者不会覆盖调用者稍后会使用的寄存器。</p>
<p>x86-64 采用了一组统一的寄存器使用惯例，所有的过程都必须遵循：</p>
<figure><img src="/images/register-usage-conventions.jpg"
         alt="x86-64 寄存器使用惯例" width="600"/><figcaption>
            <p>x86-64 寄存器使用惯例</p>
        </figcaption>
</figure>

<ul>
<li>寄存器 %rbx, %rbp 和 %r12 ~ %r15 划分为「被调用者保存寄存器」。
<ul>
<li>当过程 P 调用过程 Q 时，Q 必须保存这些寄存器的值，保证它们的值在 Q 返回到 P 时与 Q 被调用时是一样的。过程 Q 保存一个寄存器的值不变，有两种方式：
<ul>
<li>根本不去改变它</li>
<li>把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。压入寄存器的值会在栈帧中创建标号为“保存的寄存器（Saved register）”的一部分。</li>
</ul>
</li>
</ul>
</li>
<li>除栈指针（%rsp）外，其他的寄存器划分为「调用者保存寄存器」。
<ul>
<li>这些寄存器可以被任意修改。在 P 调用 Q 之前，P 有责任在自己的栈帧上保存好这些寄存器的值。</li>
</ul>
</li>
</ul>
<p>一个被调用者保存的例子：</p>
<pre tabindex="0"><code>long call_incr2(long x) {
  long v1 = 351;
  long v2 = increment(&amp;v1, 100);
  return x + v2;
}


  call_incr(long x)
  x in %rdi

call_incr2:
  pushq   %rbx              # Save %rbx
  subq    $16, %rsp         # Allocate 16-bytes stack frame
  movq    %rdi, %rbx        # Save x
  movq    $351, 8(%rsp)     # Save 351
  movl    $100, %esi        # Move 100 to second argument
  leaq    8(%rsp), %rdi     # First argument
  call    increment
  addq    %rbx, %rax        # x+v2
  addq    $16, %rsp         # Deallocate stack frame 
  popq    %rbx              # Restore %rbx
  ret
</code></pre><h3 id="递归过程">递归过程</h3>
<p>寄存器和栈的使用惯例使得 x86-64 过程能够递归地调用它们自身。每个过程调用在「栈」中都有它自己的私有空间，多个未完成调用的局部变量不会相互影响。栈的先进先出规则很自然地就与函数「调用-返回」的顺序匹配，当函数被调用时分配局部存储，函数返回时就释放存储。</p>
<p>递归调用的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">/* Recursive rfact */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">rfact</span>(<span style="color:#66d9ef">long</span> n) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> result;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>) <span style="color:#75715e">/* 递归的 Base Case */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> n <span style="color:#f92672">*</span> rfact(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>   long rfact(long n)
   n in %rdi

1  rfact:
2    pushq   %rbx            # Save %rbx
3    movq    %rdi, %rbx      # Store n in callee-saved register
4    movl    $1, %eax        # Set return value = 1
5    cmpq    $1, %rdi        # Compare n:1
6    jle     .L35            # If &lt;-, goto done
7    leaq    -1(%rdi), %rdi  # Compute n-1
8    call    refact          # Call rfact(n-1)
9    imulq   %rbx, %rax      # Multiply result by n
10  .L35:
11    popq    %rbx           # Result %rbx
12    ret                    # Return
</code></pre><p>从汇编代码可以看到，使用寄存器 %rbx 来保存参数 n，先把已有的值保存在栈上（第2行），随后在返回前恢复该值（第11行）。根据栈的使用特性和寄存器保存惯例，可以保证当递归调用 rfact(n-1) 返回时（第9行），该次调用的结果会保存在寄存器 %rax 中，参数 n 的值仍然在寄存器 %rbx 中。把这两个值相乘就能得到期望的结果。</p>
<h2 id="数值分配和访问">数值分配和访问</h2>
<p>基本原则：
对于数据类型 $T$ 和 整型常数 $N$，声明如下：</p>
<p>$$T A[N]；$$</p>
<p>起始位置表示为 $x_A$。这个声明，首先在内存中分配一个 $L\cdot N$ 字节的连续区域，$L$ 是数据类型 $T$ 的大小（单位为字节）。其次，引入了一个标识符 $A$，可以用 $A$ 来作为指向数组开头的指针，这个指针的值就是 $x_A$（类型为 $T*$）。可以用 $0 \thicksim N-1$ 的整数索引来访问数组元素。数组元素 $i$ 被存放在地址为 $x_A + L \cdot i$ 的地方。</p>
<p>例如：</p>
<figure><img src="/images/arrary-example.jpg" width="600"/>
</figure>

<p>数组 msg 由 12 个单字节（char）元素组成。数组 val 由 5 个整数组成，每个元素需要 4 个字节。数组 a 由 3 个双精度浮点数组成，每个元素需要 8 个字节。p 为指针数组，每个元素都是 8 个字节。</p>
<p>x86-64 的内存引用指令可以用来简化数组访问。例如，假设 A 是一个 int 型的数组，A 的地址存放在寄存器 %rdx 中，i 存放在寄存器 %rcx 中，那么就可以这样来访问 A[i]：</p>
<pre tabindex="0"><code>movl (%rdx, %rcx, 4), %rax
</code></pre><p>这条指令会执行地址计算 $x_A + 4i$，然后读取这个内存位置的值，并将结果存放到寄存器 %eax 中。</p>
<h3 id="指针运算">指针运算</h3>
<p>C 语言允许对指针进行运算，而计算出来的值会根据指针引用的数据类型的大小进行「伸缩」。就是说，如果 p 是一个指向类型为 $T$ 的数据的指针，p 的值为 $x_p$，那么表达式 p + i 的值为 $x_p + L \cdot i$，$L$ 是数据类型 $T$ 的大小（单位字节）。</p>
<p>可以对数组和指针应用数组下标操作。数组引用 A[i] 等同于表达式 *(A + i)，它计算第 $i$ 个数组元素的地址，然后访问这个内存位置。</p>
<figure><img src="/images/arrary-and-pointer.jpg" width="600"/>
</figure>

<p>如上图的数组 x 的地址为 a， x[4] 等同于 *(x + 4) = *(a + 4 * 4) = 5。</p>
<h3 id="嵌套数组">嵌套数组</h3>
<p>对于一个声明如下的数组：</p>
<p>$$T A[R][C];$$</p>
<p>它有 R 行、C 列。每个元素需要 sizeof(T) 字节。数组的大小为 R * C * sizeof(T) 字节。数组元素以行优先的顺序排列。</p>
<figure><img src="/images/row-major-ordering.jpg" width="600"/>
</figure>

<ul>
<li>A[i] 是一个有 C 个元素的数组（也就是第 i 行有 C 个元素）。</li>
<li>A 是数组的起始地址。</li>
<li>第 i 行的起始地址为：<code>A[i] = A + i*(C * L)</code>。L 是数据类型 $T$ 以字节为单位的大小。</li>
<li>第 i 行，第 j 列的地址为：<code>A[i][j] = A + i*(C*L) + j*L = A + (i*C + j) * L</code>。</li>
</ul>
<figure><img src="/images/nested-array-element-access.jpg" width="600"/>
</figure>

<p>例如，定义一个 5 x 3 的整型数组 int A[5][3]，下面的代码可以将数组元素 A[i][j] 复制到寄存器 %eax 中：</p>
<pre tabindex="0"><code>    A in %rdi, i in %rsi, and j in %rdx

1   leaq  (%rsi, %rsi, 2), %rax       # Compute 3i
2   leaq  (%rdi, %rax, 4), %rax       # Compue A + 12i
3   movl  (%rax, %rdx, 4), %eax       # Read from M[A + 12i + 4j]=M[A + 4(3i + j)]
</code></pre><h4 id="多级数组-vs-嵌套数组">多级数组 vs 嵌套数组</h4>
<pre tabindex="0"><code>/* 嵌套数组 */
int sea[4][5] = {
  { 9, 8, 1, 9, 5 },
  { 9, 8, 1, 0, 5 },
  { 9, 8, 1, 0, 3 },
  { 9, 8, 1, 1, 5 }
};
</code></pre><pre tabindex="0"><code>int cmu[5] = { 1, 5, 2, 1, 3 };
int uw[5] = { 9, 8, 1, 9, 5 };
int ucb[5] = { 9, 4, 7, 2, 0 };

/* 多级数组 */
int* univ[3] = {uw, cmu, ucb};
</code></pre><p>虽然两者访问元素的方式看起来相同，但实际是有区别的。</p>
<figure><img src="/images/nested-vs-multilevel-array.jpg"/>
</figure>

<ul>
<li>嵌套数组的元素访问是：<strong>Mem</strong>[sea+20*index+4*digit]。</li>
<li>多级数组的元素访问是：<strong>Mem</strong>[<strong>Mem</strong>[univ+8*index]+4*digit]。必须读两次内存：
<ul>
<li>首先，获取到指向行数组的指针。</li>
<li>然后，访问数组中的元素。</li>
</ul>
</li>
</ul>
<h2 id="结构">结构</h2>
<p>结构定义：</p>
<pre tabindex="0"><code>struct name {
  /* fields */
};
</code></pre><p>类似于数组的实现，结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。</p>
<p>下面的代码定义了一个结构，并声明了一个指向这个结构的指针变量。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> rec {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> a[<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> i;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> rec <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>} <span style="color:#f92672">*</span>r;
</span></span></code></pre></div><p>这个结构包括了 3 个字段：一个由 4 个类型为 int 的元素组成的数组、一个 8 字节 long 和一个 8 字节的结构指针。总共是 32 个字节：</p>
<figure><img src="/images/struct-layout.jpg" width="400"/>
</figure>

<p>结构的大小和字段的位置是在编译时决定的，机器代码不包含结构信息。在汇编代码中访问结构字段，要将结构的地址加上适当的偏移，编译器了解结构的每个字段的偏移（offset），通过 r + offset 计算出字段的位置。</p>
<p>假如，指针变量 r 存放在寄存器 %rdi 中。那么下面的指令会将字段 i 的值返回：</p>
<pre tabindex="0"><code># r in %rdi
movq  16(%rdi), %rax
ret
</code></pre><p>同样的，只需要将结构的地址加上某个字段的偏移量，就能产生一个指向该字段的指针。例如，只要加上偏移量 0 + 4 x 1 = 4，就可以得到指针 &amp;(r-&gt;a[1])。由此，我们可以用一条指令就能产生指针 &amp;(r-&gt;a[i]) 的值：</p>
<pre tabindex="0"><code>    # Register: r in %rdi, i %rsi
1   leaq    (%rdi, %rsi, 4), %rax       # Set %rax to &amp;r-&gt;a[i]
</code></pre><h3 id="数据对齐">数据对齐</h3>
<p>许多计算机系统对基本数据类型的合法地址做出了限制，要求某种类型对象的地址必须是某个 $K$ 值（通常是 2、4 或 8）的倍数。这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计。无论数据是否对齐，x86-64 硬件都是能正确工作的。不过，Intel 还是建议要对齐数据以提高内存系统的性能。</p>
<p>对齐原则：任何 $K$ 字节的基本对象，它的「地址」必须是 $K$ 的倍数。</p>
<figure><img src="/images/memory-alignment.jpg"
         alt="基本数据类型的地址对齐" width="600"/><figcaption>
            <p>基本数据类型的地址对齐</p>
        </figcaption>
</figure>

<p>对于包含结构的代码，编译器可能需要在字段的分配中插入间隙，以保证每个结构元素都满足它的对齐要求。</p>
<p>例如：</p>
<pre tabindex="0"><code>struct S1 {
  char c;
  int  i[2];
  double v;
} *p;
</code></pre><figure><img src="/images/unaligned-data.jpg"
         alt="未对齐数据" width="600"/><figcaption>
            <p>未对齐数据</p>
        </figcaption>
</figure>

<p>在未对齐数据的情况下，i 的地址是 p+1，并不是 4 的倍数，v 的地址是 p+9，也不是 8 的倍数。为了满足对齐要求，编译器会在字段之间插入间隙：</p>
<figure><img src="/images/aligned-data.jpg"
         alt="对齐数据" width="600"/><figcaption>
            <p>对齐数据</p>
        </figcaption>
</figure>

<p>在对齐数据的情况下，字段 c 和 i 之间插入了 3 个字节的间隙，使得 i 的地址为 p+4，满足 4 的倍数的对齐要求，i 和 v 之间插入了 4 个字节的间隙，使得 v 的地址为 p+16，满足 8 的倍数的对齐要求。插入的这些间隙，也称为内部碎片。最后，整个结构的大小为 24 个字节。</p>
<p>除了结构的每个元素必须满足对齐要求外，结构自身也要满足 $K_{max}$ 的对齐要求：</p>
<ul>
<li>$K_{max}$ 是指结构中最大的那个元素的大小。对于数组，每个元素单独的计数。</li>
</ul>
<p>比如，前面的例子 S1 的最大元素为 double 类型的 v，即 $K_{max}$ = 8。那么，结构 S1 的地址以及它的大小就必须是 8 的倍数。</p>
<h3 id="结构数组">结构数组</h3>
<p>在结构的末尾也可能需要一些填充，例如：</p>
<pre tabindex="0"><code>struct S2 {
  double v;
  int i[2];
  char c;
} a[10];
</code></pre><figure><img src="/images/arrary-struct-alignment.jpg"
         alt="结构数组" width="600"/><figcaption>
            <p>结构数组</p>
        </figcaption>
</figure>

<p>虽然，结构 S2 中的元素都满足对齐要求，但是，如果把它作为数组元素，那么，a[0]=a+0，a[1]=a+17，就不满足数组的每个元素都要对齐的要求了。而结构的地址和大小必须是 $K_{max}$ 的倍数，所以在结构的末尾需要填充 7 个字节。在末尾填充的字节，也称为外部碎片。</p>
<h3 id="节省空间">节省空间</h3>
<p>对齐数据在结构的元素之间或者是结构的末尾填充字节，虽然提升了访问效率，但也浪费了一些内存空间。由于编译器是根据结构元素声明的顺序来对齐数据的，有时候只要我们在编写代码时仔细考虑一下元素声明的顺序，就可能节省一些内存空间。</p>
<p>例如：</p>
<pre tabindex="0"><code>struct S4 {
  char c;
  int i;
  char d;
} *p;
</code></pre><p>编译结构 S4 时，为了满足对齐要求，会在元素 c 和 i 之间插入 3 个字节，同时在末尾填充 3 个字节。这样，就要为整个结构分配 12 个字节的内存空间。</p>
<pre tabindex="0"><code>struct S5 {
  int i;
  char c;
  char d;
} *p;
</code></pre><p>结构 S5 改变了元素声明的顺序后，把大的元素放在首位，编译器只需要在结构末尾填充 2 个字节，而整个结构的大小只有 8 字节。</p>
<h2 id="联合">联合</h2>
<p>联合声明的语法与结构的语法一样，但是，它们的语义相差很大。</p>
<pre tabindex="0"><code>union name {
  /* fields */
};
</code></pre><p>联合是「用不同」的字段来引用「相同」的内存块，为相同内存位置提供了不同的视图。</p>
<ul>
<li>仅为联合中最大的字段分配足够的内存空间。</li>
<li>一次只能使用一个字段（改变一个字段，其他字段也会受到影响）。</li>
</ul>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/cs">cs</a></li>
					
				</ul>
			</nav>
			
			
		</div>
	</article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/x-29" title="GitHub"><i data-feather="github"></i></a><a class="soc" href="https://twiiter.com/x-29/" title="Twitter"><i data-feather="twitter"></i></a><a class="soc" href="https://gitlab.com/x-29/" title="GitLab"><i data-feather="gitlab"></i></a></div>
  <div class="footer-info">
    2022  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>


<script>
  feather.replace()
</script></div>
    </body>
</html>
