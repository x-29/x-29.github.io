<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>深入理解计算机系统(csapp)笔记-程序的机器级表示 - CS里的X-29</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="这是深入理解计算机系统(Computer Systems A Programmer&#39;s Perspective 3rd)第三章的学习笔记." />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="深入理解计算机系统(csapp)笔记-程序的机器级表示" />
<meta property="og:description" content="这是深入理解计算机系统(Computer Systems A Programmer&#39;s Perspective 3rd)第三章的学习笔记." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://x-29.github.io/post/2022-05-csapp-notes-ch3/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-05-16T10:12:20+08:10" />
<meta property="article:modified_time" content="2022-05-16T10:12:20+08:10" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="深入理解计算机系统(csapp)笔记-程序的机器级表示"/>
<meta name="twitter:description" content="这是深入理解计算机系统(Computer Systems A Programmer&#39;s Perspective 3rd)第三章的学习笔记."/>
<script src="https://x-29.github.io/js/feather.min.js"></script>
	
	
        <link href="https://x-29.github.io/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://x-29.github.io/css/main.40ca3a860425083862b7ebd55447caec5c4384573f0cb098b8d06a91e8dace2e.css" />
	
	

	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>
        
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://x-29.github.io/">CS里的X-29</a>
	</div>
	<nav>
		
		<a href="/">首页</a>
		
		<a href="/post">文章</a>
		
		<a href="/about">关于</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">深入理解计算机系统(csapp)笔记-程序的机器级表示</h1>
			<div class="meta">Posted on May 16, 2022</div>
		</div>
		

		<section class="body">
			<p>计算机执行「机器代码」，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。</p>
<p>汇编代码表示非常接近于机器代码。与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。理解汇编代码以及它与原始 C 代码的联系，是理解计算机如何执行程序的关键一步。</p>
<h2 id="程序编码">程序编码</h2>
<p>假设一个 C 程序，有两个文件 p1.c 和 p2.c。用下面的 Unix 命令编译这些代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>linux&gt; gcc -Og -o p p1.c p2.c
</span></span></code></pre></div><p>命令 gcc 指的是 GCC C 编译器，这是 Linux 上默认的编译器。</p>
<p>gcc 命令实际上会调用一整套的程序，将源代码转换成可执行代码。</p>
<ul>
<li>首先，调用「C 预处理器」扩展源代码，插入所有用 <code>#include</code> 命令指定的文件，并扩展所有用 <code>#define</code> 声明指定的宏。</li>
<li>其次，调用「编译器」产生两个源文件的汇编代码，名字分别为 <code>p1.s</code> 和 <code>p2.s</code>。</li>
<li>接下来，调用「汇编器」将汇编代码转换成二进制「目标代码」文件 <code>p1.o</code> 和 <code>p2.o</code>。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。</li>
<li>最后，调用「链接器」将两个目标代码文件与实现库函数的代码合并，并产生最终的「可执行」代码文件 p。可执行代码是机器代码的第二种形式。</li>
</ul>
<hr>
<p>计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，其中两种抽象尤为重要：</p>
<ol>
<li>由「指令集体系结构或指令集架构（Instruction Set Architecture，ISA）」来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。</li>
<li>机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数值。</li>
</ol>
<p>C语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单地将内存看成一个很大、按字节寻址的数组。</p>
<ul>
<li>C 语言中的聚合数据类型，例如数组和结构，在机器代码中用一组连续的字节来表示。</li>
<li>对标量数据类型，汇编代码也不区分有符号或无符号，不区分各种类型的指针，甚至不区分指针和整数。</li>
</ul>
<p>在 gcc 命令上使用 &ldquo;-S&rdquo; 选项，可以产生一个汇编文件，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>linux&gt; gcc -Og -S mstore.c
</span></span></code></pre></div><p>执行这条命令，将会使 GCC 运行编译器，产生一个汇编文件 <code>mstore.s</code>，但不做进一步的工作。（通常情况下，它还会继续调用汇编器产生目标代码文件）。</p>
<p>使用 “-c“ 选项，GCC 会执行编译并汇编代码，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>linux&gt; gcc -Og -c mstore.c
</span></span></code></pre></div><p>这会产生目标代码文件 mstore.o，它是二进制格式的，所以我们无法直接查看。</p>
<p>要想查看机器代码文件的内容，可以使用「反汇编器」程序，例如，在 Linux 系统中，带 &lsquo;-d&rsquo; 选项的 objdump 命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>linux&gt; objdump -d mstore.o
</span></span></code></pre></div><p>查看机器代码文件的内容，我们会发现「<strong>机器执行的程序只是一个字节序列，它是对一系列指令的编码</strong>」。例如：</p>
<pre tabindex="0"><code>53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3
</code></pre><p>这些字节分成若干组，每组有 1 ～ 5 个字节。<strong>每组都是一条指令</strong>。例如 <code>53</code> 是 <code>push %rbx</code> 指令，<code>48 89 d3</code> 是指令 <code>mov %rdx, %rbx</code>。机器对产生这些指令的源代码几乎一无所知。</p>
<hr>
<p>汇编代码格式有两种：ATT 格式和 Intel 格式。</p>
<ul>
<li>GCC、objdump 用得是 ATT 格式的汇编代码。</li>
<li>Microsoft 的工具，以及 Intel 的文档，都是使用 Intel 格式的汇编代码。</li>
</ul>
<p>Intel 和 ATT 格式的一些主要不同点：</p>
<ul>
<li>Intel 代码省略了指示大小的后缀。如指令 push 和 mov，而不是 pushq 和 movq。</li>
<li>Intel 代码省略了寄存器名字前面的 &lsquo;%&rsquo; 符号，用的是 rbx，而不是 %rbx。</li>
<li>Intel 代码用不同的方式来描述内存中的位置，例如 &lsquo;QWORD PTR [rbx]&rsquo;，而不是 &lsquo;(%rbx)&rsquo;。</li>
<li>在有多个操作数的指令中，列出的操作数的顺序相反。</li>
</ul>
<h2 id="数据格式">数据格式</h2>
<p>由于是从 16 位体系结构扩展成 32 位的，Intel 用术语「字（word）」表示 16 位数据类型。因此，称 32 位数为「双字（double words）」，64 位数为「四字（quad words）」。</p>
<p>C 语言基本数据类型对应的 x86-64 表示：</p>
<figure><img src="/images/c-data-types-x86.jpg"
         alt="C 语言数据类型在 x86-64 中的大小" width="600"/><figcaption>
            <p>C 语言数据类型在 x86-64 中的大小</p>
        </figcaption>
</figure>

<p>如图所示，大多数 GCC 生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。</p>
<p>例如，数据传输指令的 4 个变种：</p>
<ul>
<li>movb，传送字节</li>
<li>movw，传送字</li>
<li>movl，传送双字</li>
<li>movq，传送四字。</li>
</ul>
<h2 id="访问信息">访问信息</h2>
<p>一个 x86-64 的 CPU 包含一组 16 个存储「64 位」值的「通用目的寄存器」。这些寄存器用来「存储整数数据和指针」。</p>
<blockquote>
<p>每个 CPU core 都有各自的寄存器。</p>
</blockquote>
<p>如图：</p>
<figure><img src="/images/integer-registers.jpg"
         alt="整数寄存器"/><figcaption>
            <p>整数寄存器</p>
        </figcaption>
</figure>

<p>所有 16 个寄存器的低位部分都可以作为字节、字（16位）、双字（32位）和四字（64位）数字访问，即：</p>
<ul>
<li>字节级操作可以访问最低的字节（8位）。</li>
<li>16 位操作可以访问最低的 2 个字节（16位）。</li>
<li>32 位操作可以访问最低的 4 个字节（32位）。</li>
<li>64 位操作可以访问整个寄存器。</li>
</ul>
<p>程序计数器是特殊的寄存器，通常称为 PC，在 x86-64 中用 %rip 表示，它给出将要执行的下一条指令在内存中的地址。</p>
<blockquote>
<p>在常见的程序里不同的寄存器扮演不同的角色，其中最特别的是「栈指针 %rsp」，它用来指明运行时栈的结束位置。</p>
</blockquote>
<p>有一组标准的编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数的返回值，以及存储局部和临时数据。</p>
<h3 id="寻址方式">寻址方式</h3>
<p>大多数指令有一个或多个操作数（operand）。指令的操作数分为三种类型：</p>
<ul>
<li>立即数（immediate），用来表示常数值。如 <code>$-577</code>，<code>$0x1F</code>。</li>
<li>寄存器（register），表示某个寄存器的内容。</li>
<li>内存引用 ，它会根据计算出来的地址（通常称为有效地址）访问某个内存位置，也就是读取内存位置所存放的值。</li>
</ul>
<p>内存引用有多种不同的形式，最常用的形式为：$Imm(r_b，r_i，s)$。这样的引用有四个组成部分：</p>
<ul>
<li>一个立即数偏移量 $Imm$。</li>
<li>一个基址寄存器 $r_b$。</li>
<li>一个变址寄存器 $r_i$。</li>
<li>一个比例因子 $s$。$s$ 必须是 1、2、4 或者 8。</li>
</ul>
<p>它所表示的地址可以这样计算出来：</p>
<p>$$Imm+R[r_b]+R[r_i] \cdot s$$</p>
<p>符号说明：符号 $r_a$ 表示任意寄存器 $a$，$R[r_a]$ 表示它的值。这是将寄存器集合看成一个数组 $R$，用寄存器标识作为索引。</p>
<p>其他形式都是这种形式的特殊情况，只是省略了某些部分，相当于这些部分是 0。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>格式</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接（绝对）寻址（Direct/Absolute Addressing Mode））</td>
<td>$Imm$</td>
<td>Memory</td>
<td>只使用 $Imm$ 寻址，例如 movl 0x20, %eax。把地址 0x20 处的 32 位数传送到 eax 寄存器。注意与立即数寻址的区别，这里是直接的内存地址。</td>
</tr>
<tr>
<td>间接寻址（Indirect Addressing Mode）</td>
<td>($r_b$)</td>
<td>Memory</td>
<td>只使用 $r_b$ 寻址。例如 movl (%eax), %ebx。把 eax 寄存器的值看做内存地址，把内存中这个地址处的 32 位数传送到 ebx 寄存器。<strong>注意与 movl %eax, %ebx 区分开来</strong>。</td>
</tr>
<tr>
<td>(基址+偏移量)寻址（Base Pointer Addressing Mode）</td>
<td>$Imm(r_b)$</td>
<td>Memory</td>
<td>只使用 $Imm$ 和 $r_b$ 寻址，例如 movl 4(%eax), %ebx。用于访问结构体成员比较方便，例如一个结构体的基地址保存在 eax 寄存器中，其中一个成员在结构体内的偏移量是 4 字节，要把这个成员读上来就可以用这条指令</td>
</tr>
<tr>
<td>变址寻址（Indexed Addressing Mode）</td>
<td>$(r_b,r_i)、Imm(r_b,r_i)$、$(,r_i,s)、Imm(,r_i,s)$、$(r_b,r_i,s)$、$Imm(r_b，r_i,s)$</td>
<td>Memory</td>
<td>例如 movl items(,%edi,4), %eax 就属于这种寻址方式，用于访问数组元素比较方便</td>
</tr>
<tr>
<td>立即数寻址（Immediate Mode）</td>
<td>$Imm$</td>
<td>立即数</td>
<td>就是指令中有一个操作数是立即数，例如 <code>movl $12, %eax</code>中的 $12，这其实跟寻址没什么关系，但也算作一种寻址方式。</td>
</tr>
<tr>
<td>寄存器寻址（Register Addressing Mode）</td>
<td>$r_a$</td>
<td>Register</td>
<td>就是指令中有一个操作数是寄存器，例如movl $12, %eax 中的 %eax，这跟内存寻址没什么关系，但也算作一种寻址方式。</td>
</tr>
</tbody>
</table>
<p>看几个例子，加深理解，假设下面的值存放在指明的内存地址和寄存器中：</p>
<table>
<thead>
<tr>
<th>内存地址</th>
<th>值</th>
<th>寄存器</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x100</td>
<td>0xFF</td>
<td>%rax</td>
<td>0x100</td>
</tr>
<tr>
<td>0x104</td>
<td>0xAB</td>
<td>%rcx</td>
<td>0x1</td>
</tr>
<tr>
<td>0x108</td>
<td>0x13</td>
<td>%rdx</td>
<td>0x3</td>
</tr>
<tr>
<td>0x10c</td>
<td>0x11</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>给出所示操作数的值：</p>
<table>
<thead>
<tr>
<th>操作数</th>
<th>值</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>%rax</td>
<td>0x100</td>
<td>寄存器寻址</td>
</tr>
<tr>
<td>0x104</td>
<td>0xAB</td>
<td>直接寻址</td>
</tr>
<tr>
<td>$0x108</td>
<td>0x108</td>
<td>立即数寻址</td>
</tr>
<tr>
<td>(%rax)</td>
<td>0xFF</td>
<td>间接寻址，内存地址 0x100</td>
</tr>
<tr>
<td>4(%rax)</td>
<td>0xAB</td>
<td>变址寻址，内存地址 0x104</td>
</tr>
<tr>
<td>9(%rax,%rdx)</td>
<td>0x11</td>
<td>变址寻址，内存地址 0x10c</td>
</tr>
<tr>
<td>260(%rcx,%rdx)</td>
<td>0x13</td>
<td>变址寻址，内存地址 0x108。十进制 264 用十六进制表示就是 0x108</td>
</tr>
<tr>
<td>0xFC(,%rcx, 4)</td>
<td>0xFF</td>
<td>变址寻址，内存地址 0x100</td>
</tr>
<tr>
<td>(%rax,%rdx, 4)</td>
<td>0x11</td>
<td>变址寻址，内存地址 0x10c</td>
</tr>
</tbody>
</table>
<h3 id="数据传送指令">数据传送指令</h3>
<p>数据传送指令（Move）是将数据从一个位置复制到另一个位置的指令，它有两个操作数：源操作数和目的操作数。</p>
<ul>
<li>源操作数指定的值是一个立即数，存储在寄存器（register）中或者内存（memory）中。</li>
<li>目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址。</li>
<li>X86-64 限制传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令。第一条指令将源值加载到寄存器中，第二条将寄存器的值写入目的位置。</li>
</ul>
<p>寄存器部分的大小必须与指令最后一个字符（&lsquo;b&rsquo;, &lsquo;w&rsquo;, &rsquo;l&rsquo; 或 &lsquo;q&rsquo;）指定的大小匹配，如：</p>
<pre tabindex="0"><code>movl $0x4050, %eax         Immediate -- Register, 4 bytes
movb $-17, (%rsp)          Immediate -- Memory,   1 bytes
movb (%rdi, %rcx), %al     Memory -- Register,    1 bytes
movw %bp, %sp              Register -- Register,  2 bytes
movq %rax, -12(%rbp)       Register -- Memory,    8 bytes
</code></pre><p>可以看到上面的 movl 指令是传送 4 个字节的数据到寄存器中，所以寄存器用 32 位的 <code>%eax</code>。同样的，movb 指令是传送 1 个字节的数据，寄存器用 8 位的 <code>%al</code>。后面的 <code>%bp</code>、<code>%sp</code>、<code>%rax</code> 也都是与指令最后一个字符指定的大小相匹配的。</p>
<p>当指令以寄存器为目的操作数时，对于生成小于 8 字节的指令，寄存器中剩下的字节会怎样处理呢？对此有两条规则：</p>
<ul>
<li>生成 1 字节和 2 字节数字的指令会保持剩下的字节不变。</li>
<li>生成 4 字节的指令会把高位 4 个字节置为 0。
<ul>
<li>movl 指令以寄存器作为目的操作数时，它会将寄存器的高 4 字节置为 0。</li>
</ul>
</li>
</ul>
<p>例如：</p>
<pre tabindex="0"><code>movabsq $0x0011223344556677, %rax      %rax = 0011223344556677
movb    $-1, %al                       %rax = 00112233445566FF
movw    $-1, %ax                       %rax = 001122334455FFFF
movl    $-1, %eax                      %rax = 00000000FFFFFFFF
movq    $-1, %rax                      %rax = FFFFFFFFFFFFFFFF
</code></pre><p>第一条 <code>movabsq</code> 指令传送绝对的四字，能够以任意 64 位立即数作为源操作数，并且只以寄存器作为目的操作数。在这里它把寄存器 %rax 初始化为位模式 0011223344556677。</p>
<blockquote>
<p>数据传送指令中有一条 cltq 指令。这条指令没有操作数：它总是以寄存器 %eax 为源操作数，%rax 为符号扩展结果的目的操作数。它的效果与指令 movslq %eax, %rax 完全一致。</p>
</blockquote>
<p>下面结合 C 程序来看一个数据传送的示例：</p>
<p>C 代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">exchange</span>(<span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>p, <span style="color:#66d9ef">long</span> y) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> x <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>xp;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>xp <span style="color:#f92672">=</span> y;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> x;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>汇编代码：</p>
<pre tabindex="0"><code>    long exchange(long *xp, long y)
    xp in %rdi, y in %rsi

1   exchange:
2     movq  (%rdi), %rax      Get x at xp. Set as return value.
3     movq  %rsi, (%rdi)      Store y at xp.
4     ret                     Return
</code></pre><p>我们看到函数 exchange 由三条指令实现：两条数据传送（movq），加上一条返回函数被调用点的指令（ret）。</p>
<p>当过程开始执行时，过程参数 xp 和 y 分别存储在寄存器 %rdi 和 %rsi 中。然后，指令 2 从内存中读出 x，把它存放到寄存器 %rax 中，直接实现了 C 程序中的 x=*xp 操作。指令 3 将 y 写入到寄存器 %rdi 中的 xp 指向的内存位置，直接实现了操作 *xp=y。</p>
<p>从这个段汇编代码中我们可以看到这么两点：</p>
<ul>
<li>C 语言中所谓的“指针”其实就是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用（$Imm(r_b,r_i,s)$)中使用这个寄存器。</li>
<li>局部变量（如：x）通常保存在寄存器中，而不是内存中。访问寄存器比访问内存要快得多。</li>
</ul>
<p>有关 C 指针的一些示例：</p>
<pre tabindex="0"><code>char *p;
p = &amp;a;  // p 存储的是地址。C 操作符 &amp; 称为“取址” 操作符，它创建一个指针。

char b = *p; // 读取 p 所指向位置中的值，并将它存放到变量 b 中。C 操作符 * 执行指针的间接引用。
*p = c; // 将 c 的值写到 p 所指向的位置。这也是指针间接引用的一种形式。
</code></pre>
		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/cs">cs</a></li>
					
				</ul>
			</nav>
			
			
		</div>
	</article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/x-29" title="GitHub"><i data-feather="github"></i></a><a class="soc" href="https://twiiter.com/x-29/" title="Twitter"><i data-feather="twitter"></i></a><a class="soc" href="https://gitlab.com/x-29/" title="GitLab"><i data-feather="gitlab"></i></a></div>
  <div class="footer-info">
    2022  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>


<script>
  feather.replace()
</script></div>
    </body>
</html>
