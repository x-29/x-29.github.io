<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>深入理解计算机系统(csapp)笔记-程序的机器级表示 - CS里的X-29</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="这是深入理解计算机系统(Computer Systems A Programmer&#39;s Perspective 3rd)第三章的学习笔记." />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="深入理解计算机系统(csapp)笔记-程序的机器级表示" />
<meta property="og:description" content="这是深入理解计算机系统(Computer Systems A Programmer&#39;s Perspective 3rd)第三章的学习笔记." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://x-29.github.io/post/2022-05-csapp-notes-ch3/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-05-16T10:12:20+08:10" />
<meta property="article:modified_time" content="2022-05-16T10:12:20+08:10" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="深入理解计算机系统(csapp)笔记-程序的机器级表示"/>
<meta name="twitter:description" content="这是深入理解计算机系统(Computer Systems A Programmer&#39;s Perspective 3rd)第三章的学习笔记."/>
<script src="https://x-29.github.io/js/feather.min.js"></script>
	
	
        <link href="https://x-29.github.io/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://x-29.github.io/css/main.40ca3a860425083862b7ebd55447caec5c4384573f0cb098b8d06a91e8dace2e.css" />
	
	

	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>
        
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://x-29.github.io/">CS里的X-29</a>
	</div>
	<nav>
		
		<a href="/">首页</a>
		
		<a href="/post">文章</a>
		
		<a href="/about">关于</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">深入理解计算机系统(csapp)笔记-程序的机器级表示</h1>
			<div class="meta">Posted on May 16, 2022</div>
		</div>
		

		<section class="body">
			<p>计算机执行「机器代码」，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。</p>
<p>汇编代码表示非常接近于机器代码。与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。理解汇编代码以及它与原始 C 代码的联系，是理解计算机如何执行程序的关键一步。</p>
<h2 id="程序编码">程序编码</h2>
<p>假设一个 C 程序，有两个文件 p1.c 和 p2.c。用下面的 Unix 命令编译这些代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>linux&gt; gcc -Og -o p p1.c p2.c
</span></span></code></pre></div><p>命令 gcc 指的是 GCC C 编译器，这是 Linux 上默认的编译器。</p>
<p>gcc 命令实际上会调用一整套的程序，将源代码转换成可执行代码。</p>
<ul>
<li>首先，调用「C 预处理器」扩展源代码，插入所有用 <code>#include</code> 命令指定的文件，并扩展所有用 <code>#define</code> 声明指定的宏。</li>
<li>其次，调用「编译器」产生两个源文件的汇编代码，名字分别为 <code>p1.s</code> 和 <code>p2.s</code>。</li>
<li>接下来，调用「汇编器」将汇编代码转换成二进制「目标代码」文件 <code>p1.o</code> 和 <code>p2.o</code>。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。</li>
<li>最后，调用「链接器」将两个目标代码文件与实现库函数的代码合并，并产生最终的「可执行」代码文件 p。可执行代码是机器代码的第二种形式。</li>
</ul>
<hr>
<p>计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，其中两种抽象尤为重要：</p>
<ol>
<li>由「指令集体系结构或指令集架构（Instruction Set Architecture，ISA）」来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。</li>
<li>机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数值。</li>
</ol>
<p>C语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单地将内存看成一个很大、按字节寻址的数组。</p>
<ul>
<li>C 语言中的聚合数据类型，例如数组和结构，在机器代码中用一组连续的字节来表示。</li>
<li>对标量数据类型，汇编代码也不区分有符号或无符号，不区分各种类型的指针，甚至不区分指针和整数。</li>
</ul>
<p>在 gcc 命令上使用 &ldquo;-S&rdquo; 选项，可以产生一个汇编文件，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>linux&gt; gcc -Og -S mstore.c
</span></span></code></pre></div><p>执行这条命令，将会使 GCC 运行编译器，产生一个汇编文件 <code>mstore.s</code>，但不做进一步的工作。（通常情况下，它还会继续调用汇编器产生目标代码文件）。</p>
<p>使用 “-c“ 选项，GCC 会执行编译并汇编代码，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>linux&gt; gcc -Og -c mstore.c
</span></span></code></pre></div><p>这会产生目标代码文件 mstore.o，它是二进制格式的，所以我们无法直接查看。</p>
<p>要想查看机器代码文件的内容，可以使用「反汇编器」程序，例如，在 Linux 系统中，带 &lsquo;-d&rsquo; 选项的 objdump 命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>linux&gt; objdump -d mstore.o
</span></span></code></pre></div><p>查看机器代码文件的内容，我们会发现「<strong>机器执行的程序只是一个字节序列，它是对一系列指令的编码</strong>」。例如：</p>
<pre tabindex="0"><code>53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3
</code></pre><p>这些字节分成若干组，每组有 1 ～ 5 个字节。<strong>每组都是一条指令</strong>。例如 <code>53</code> 是 <code>push %rbx</code> 指令，<code>48 89 d3</code> 是指令 <code>mov %rdx, %rbx</code>。机器对产生这些指令的源代码几乎一无所知。</p>
<hr>
<p>汇编代码格式有两种：ATT 格式和 Intel 格式。</p>
<ul>
<li>GCC、objdump 用得是 ATT 格式的汇编代码。</li>
<li>Microsoft 的工具，以及 Intel 的文档，都是使用 Intel 格式的汇编代码。</li>
</ul>
<p>Intel 和 ATT 格式的一些主要不同点：</p>
<ul>
<li>Intel 代码省略了指示大小的后缀。如指令 push 和 mov，而不是 pushq 和 movq。</li>
<li>Intel 代码省略了寄存器名字前面的 &lsquo;%&rsquo; 符号，用的是 rbx，而不是 %rbx。</li>
<li>Intel 代码用不同的方式来描述内存中的位置，例如 &lsquo;QWORD PTR [rbx]&rsquo;，而不是 &lsquo;(%rbx)&rsquo;。</li>
<li>在有多个操作数的指令中，列出的操作数的顺序相反。</li>
</ul>
<h2 id="数据格式">数据格式</h2>
<p>由于是从 16 位体系结构扩展成 32 位的，Intel 用术语「字（word）」表示 16 位数据类型。因此，称 32 位数为「双字（double words）」，64 位数为「四字（quad words）」。</p>
<p>C 语言基本数据类型对应的 x86-64 表示：</p>
<figure><img src="/images/c-data-types-x86.jpg"
         alt="C 语言数据类型在 x86-64 中的大小" width="600"/><figcaption>
            <p>C 语言数据类型在 x86-64 中的大小</p>
        </figcaption>
</figure>

<p>如图所示，大多数 GCC 生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。</p>
<p>例如，数据传输指令的 4 个变种：</p>
<ul>
<li>movb，传送字节</li>
<li>movw，传送字</li>
<li>movl，传送双字</li>
<li>movq，传送四字。</li>
</ul>
<h2 id="访问信息">访问信息</h2>
<p>一个 x86-64 的 CPU 包含一组 16 个存储「64 位」值的「通用目的寄存器」。这些寄存器用来「存储整数数据和指针」。</p>
<blockquote>
<p>每个 CPU core 都有各自的寄存器。</p>
</blockquote>
<p>如图：</p>
<figure><img src="/images/integer-registers.jpg"
         alt="整数寄存器"/><figcaption>
            <p>整数寄存器</p>
        </figcaption>
</figure>

<p>所有 16 个寄存器的低位部分都可以作为字节、字（16位）、双字（32位）和四字（64位）数字访问，即：</p>
<ul>
<li>字节级操作可以访问最低的字节（8位）。</li>
<li>16 位操作可以访问最低的 2 个字节（16位）。</li>
<li>32 位操作可以访问最低的 4 个字节（32位）。</li>
<li>64 位操作可以访问整个寄存器。</li>
</ul>
<p>程序计数器是特殊的寄存器，通常称为 PC，在 x86-64 中用 %rip 表示，它给出将要执行的下一条指令在内存中的地址。</p>
<blockquote>
<p>在常见的程序里不同的寄存器扮演不同的角色，其中最特别的是「栈指针 %rsp」，它用来指明运行时栈的结束位置。</p>
</blockquote>
<p>有一组标准的编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数的返回值，以及存储局部和临时数据。</p>
<h3 id="寻址方式">寻址方式</h3>
<p>大多数指令有一个或多个操作数（operand）。指令的操作数分为三种类型：</p>
<ul>
<li>立即数（immediate），用来表示常数值。如 <code>$-577</code>，<code>$0x1F</code>。</li>
<li>寄存器（register），表示某个寄存器的内容。</li>
<li>内存引用 ，它会根据计算出来的地址（通常称为有效地址）访问某个内存位置，也就是读取内存位置所存放的值。</li>
</ul>
<p>内存引用有多种不同的形式，最常用的形式为：$Imm(r_b，r_i，s)$。这样的引用有四个组成部分：</p>
<ul>
<li>一个立即数偏移量 $Imm$。</li>
<li>一个基址寄存器 $r_b$。</li>
<li>一个变址寄存器 $r_i$。</li>
<li>一个比例因子 $s$。$s$ 必须是 1、2、4 或者 8。</li>
</ul>
<p>它所表示的地址可以这样计算出来：</p>
<p>$$Imm+R[r_b]+R[r_i] \cdot s$$</p>
<p>符号说明：符号 $r_a$ 表示任意寄存器 $a$，$R[r_a]$ 表示它的值。这是将寄存器集合看成一个数组 $R$，用寄存器标识作为索引。</p>
<p>其他形式都是这种形式的特殊情况，只是省略了某些部分，相当于这些部分是 0。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>格式</th>
<th>操作数类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接（绝对）寻址（Direct/Absolute Addressing Mode））</td>
<td>$Imm$</td>
<td>Memory</td>
<td>只使用 $Imm$ 寻址，例如 movl 0x20, %eax。把地址 0x20 处的 32 位数传送到 eax 寄存器。注意与立即数寻址的区别，这里是直接的内存地址。</td>
</tr>
<tr>
<td>间接寻址（Indirect Addressing Mode）</td>
<td>($r_b$)</td>
<td>Memory</td>
<td>只使用 $r_b$ 寻址。例如 movl (%eax), %ebx。把 eax 寄存器的值看做内存地址，把内存中这个地址处的 32 位数传送到 ebx 寄存器。<strong>注意与 movl %eax, %ebx 区分开来</strong>。</td>
</tr>
<tr>
<td>(基址+偏移量)寻址（Base Pointer Addressing Mode）</td>
<td>$Imm(r_b)$</td>
<td>Memory</td>
<td>只使用 $Imm$ 和 $r_b$ 寻址，例如 movl 4(%eax), %ebx。用于访问结构体成员比较方便，例如一个结构体的基地址保存在 eax 寄存器中，其中一个成员在结构体内的偏移量是 4 字节，要把这个成员读上来就可以用这条指令</td>
</tr>
<tr>
<td>变址寻址（Indexed Addressing Mode）</td>
<td>$(r_b,r_i)、Imm(r_b,r_i)$、$(,r_i,s)、Imm(,r_i,s)$、$(r_b,r_i,s)$、$Imm(r_b，r_i,s)$</td>
<td>Memory</td>
<td>例如 movl items(,%edi,4), %eax 就属于这种寻址方式，用于访问数组元素比较方便</td>
</tr>
<tr>
<td>立即数寻址（Immediate Mode）</td>
<td>$Imm$</td>
<td>立即数</td>
<td>就是指令中有一个操作数是立即数，例如 <code>movl $12, %eax</code>中的 $12，这其实跟寻址没什么关系，但也算作一种寻址方式。</td>
</tr>
<tr>
<td>寄存器寻址（Register Addressing Mode）</td>
<td>$r_a$</td>
<td>Register</td>
<td>就是指令中有一个操作数是寄存器，例如movl $12, %eax 中的 %eax，这跟内存寻址没什么关系，但也算作一种寻址方式。</td>
</tr>
</tbody>
</table>
<p>看几个例子，加深理解，假设下面的值存放在指明的内存地址和寄存器中：</p>
<table>
<thead>
<tr>
<th>内存地址</th>
<th>值</th>
<th>寄存器</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x100</td>
<td>0xFF</td>
<td>%rax</td>
<td>0x100</td>
</tr>
<tr>
<td>0x104</td>
<td>0xAB</td>
<td>%rcx</td>
<td>0x1</td>
</tr>
<tr>
<td>0x108</td>
<td>0x13</td>
<td>%rdx</td>
<td>0x3</td>
</tr>
<tr>
<td>0x10c</td>
<td>0x11</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>给出所示操作数的值：</p>
<table>
<thead>
<tr>
<th>操作数</th>
<th>值</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>%rax</td>
<td>0x100</td>
<td>寄存器寻址</td>
</tr>
<tr>
<td>0x104</td>
<td>0xAB</td>
<td>直接寻址</td>
</tr>
<tr>
<td>$0x108</td>
<td>0x108</td>
<td>立即数寻址</td>
</tr>
<tr>
<td>(%rax)</td>
<td>0xFF</td>
<td>间接寻址，内存地址 0x100</td>
</tr>
<tr>
<td>4(%rax)</td>
<td>0xAB</td>
<td>变址寻址，内存地址 0x104</td>
</tr>
<tr>
<td>9(%rax,%rdx)</td>
<td>0x11</td>
<td>变址寻址，内存地址 0x10c</td>
</tr>
<tr>
<td>260(%rcx,%rdx)</td>
<td>0x13</td>
<td>变址寻址，内存地址 0x108。十进制 264 用十六进制表示就是 0x108</td>
</tr>
<tr>
<td>0xFC(,%rcx, 4)</td>
<td>0xFF</td>
<td>变址寻址，内存地址 0x100</td>
</tr>
<tr>
<td>(%rax,%rdx, 4)</td>
<td>0x11</td>
<td>变址寻址，内存地址 0x10c</td>
</tr>
</tbody>
</table>
<h3 id="数据传送指令">数据传送指令</h3>
<p>数据传送指令（Move）是将数据从一个位置复制到另一个位置的指令，它有两个操作数：源操作数和目的操作数。</p>
<ul>
<li>源操作数指定的值是一个立即数，存储在寄存器（register）中或者内存（memory）中。</li>
<li>目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址。</li>
<li>X86-64 限制传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令。第一条指令将源值加载到寄存器中，第二条将寄存器的值写入目的位置。</li>
</ul>
<p>寄存器部分的大小必须与指令最后一个字符（&lsquo;b&rsquo;, &lsquo;w&rsquo;, &rsquo;l&rsquo; 或 &lsquo;q&rsquo;）指定的大小匹配，如：</p>
<pre tabindex="0"><code>movl $0x4050, %eax         Immediate -- Register, 4 bytes
movb $-17, (%rsp)          Immediate -- Memory,   1 bytes
movb (%rdi, %rcx), %al     Memory -- Register,    1 bytes
movw %bp, %sp              Register -- Register,  2 bytes
movq %rax, -12(%rbp)       Register -- Memory,    8 bytes
</code></pre><p>可以看到上面的 movl 指令是传送 4 个字节的数据到寄存器中，所以寄存器用 32 位的 <code>%eax</code>。同样的，movb 指令是传送 1 个字节的数据，寄存器用 8 位的 <code>%al</code>。后面的 <code>%bp</code>、<code>%sp</code>、<code>%rax</code> 也都是与指令最后一个字符指定的大小相匹配的。</p>
<p>当指令以寄存器为目的操作数时，对于生成小于 8 字节的指令，寄存器中剩下的字节会怎样处理呢？对此有两条规则：</p>
<ul>
<li>生成 1 字节和 2 字节数字的指令会保持剩下的字节不变。</li>
<li>生成 4 字节的指令会把高位 4 个字节置为 0。
<ul>
<li>movl 指令以寄存器作为目的操作数时，它会将寄存器的高 4 字节置为 0。</li>
</ul>
</li>
</ul>
<p>例如：</p>
<pre tabindex="0"><code>movabsq $0x0011223344556677, %rax      %rax = 0011223344556677
movb    $-1, %al                       %rax = 00112233445566FF
movw    $-1, %ax                       %rax = 001122334455FFFF
movl    $-1, %eax                      %rax = 00000000FFFFFFFF
movq    $-1, %rax                      %rax = FFFFFFFFFFFFFFFF
</code></pre><p>第一条 <code>movabsq</code> 指令传送绝对的四字，能够以任意 64 位立即数作为源操作数，并且只以寄存器作为目的操作数。在这里它把寄存器 %rax 初始化为位模式 0011223344556677。</p>
<p>在将较小的源值传送到较大的目的时，需要先对源值做扩展：</p>
<ul>
<li><code>MOVZ S, R</code> 类的指令是做零扩展，用 0 填充。</li>
<li><code>MOVS S, R</code> 类的指令是做符号扩展，用符号为来填充。</li>
</ul>
<p>例如，%dl = AA，执行 movzbl %dl, %eax 后 %eax = 000000AA。movzbl 指令会先对 %dl 的值做零扩展到 32 位（命令中的字符 l 指明了目的的大小，b 表示源值的大小），也就是前 24 位填充 0，再将值传送到 %eax 中。执行 movsbl %dl, %eax 后 %eax=FFFFFFAA。</p>
<blockquote>
<p>数据传送指令中有一条 cltq 指令。这条指令没有操作数：它总是以寄存器 %eax 为源操作数，%rax 为符号扩展结果的目的操作数。它的效果与指令 movslq %eax, %rax 完全一致。</p>
</blockquote>
<p>下面结合 C 程序来看一个数据传送的示例：</p>
<p>C 代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">exchange</span>(<span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>p, <span style="color:#66d9ef">long</span> y) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> x <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>xp;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>xp <span style="color:#f92672">=</span> y;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> x;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>汇编代码：</p>
<pre tabindex="0"><code>    long exchange(long *xp, long y)
    xp in %rdi, y in %rsi

1   exchange:
2     movq  (%rdi), %rax      Get x at xp. Set as return value.
3     movq  %rsi, (%rdi)      Store y at xp.
4     ret                     Return
</code></pre><p>我们看到函数 exchange 由三条指令实现：两条数据传送（movq），加上一条返回函数被调用点的指令（ret）。</p>
<p>当过程开始执行时，过程参数 xp 和 y 分别存储在寄存器 %rdi 和 %rsi 中。然后，指令 2 从内存中读出 x，把它存放到寄存器 %rax 中，直接实现了 C 程序中的 x=*xp 操作。指令 3 将 y 写入到寄存器 %rdi 中的 xp 指向的内存位置，直接实现了操作 *xp=y。</p>
<p>从这个段汇编代码中我们可以看到这么两点：</p>
<ul>
<li>C 语言中所谓的“指针”其实就是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用（$Imm(r_b,r_i,s)$)中使用这个寄存器。</li>
<li>局部变量（如：x）通常保存在寄存器中，而不是内存中。访问寄存器比访问内存要快得多。</li>
</ul>
<p>有关 C 指针的一些示例：</p>
<pre tabindex="0"><code>char *p;
p = &amp;a;        // p 存储的是地址。C 操作符 &amp; 称为“取址” 操作符，它创建一个指针。

char b = *p;   // 读取 p 所指向位置中的值，并将它存放到变量 b 中。C 操作符 * 执行指针的间接引用。
*p = c;        // 将 c 的值写到 p 所指向的位置。这也是指针间接引用的一种形式。
</code></pre><h3 id="压入和弹出栈数据">压入和弹出栈数据</h3>
<p>「栈」是一个种数据结构，可以添加或者删除值，不过要遵循“后进先出”的原则。通过 push 操作把数据压入栈中，通过 pop 操作弹出（删除）数据。pop 操作的值永远是最近被压入而且仍然在栈中的值。</p>
<p>在 x86-64 中，程序栈存放在内存中某个区域。<code>pushq</code> 指令把数据压入到栈中，<code>popq</code> 指令从栈中弹出数据。这两条指令都只有一个操作数。</p>
<figure><img src="/images/push-pop-instructions.jpg"
         alt="入栈和出栈指令。操作数 S：表示压入栈的数据源，操作数 D：表示弹出的数据目的" width="600"/><figcaption>
            <p>入栈和出栈指令。操作数 S：表示压入栈的数据源，操作数 D：表示弹出的数据目的</p>
        </figcaption>
</figure>

<p>将一个四字的值压入栈中，首先要将栈指针减 8，然后将值写到新的栈地址。因此，指令 pushq %rbp 的行为等价于下面两条指令：</p>
<pre tabindex="0"><code>subq $8, %rsp        Decrement stack Pointer
movq %rbp, (%rsp)    Store %rbp on stack
</code></pre><p>弹出一个四字的操作，首先是从栈顶位置读出数据，然后将栈指针加 8。因此，指令 popq %rax 等价于下面两条指令：</p>
<pre tabindex="0"><code>movq (%rsp), %rax      Read %rax from stack
addq $8, %rsp          Increment stack pointer
</code></pre><p>栈总是从一端压入或弹出数据。这一端称之为「栈顶」。</p>
<p>在 x86-64 中，「<strong>栈向低地址方向增长，栈顶元素的地址是所有栈元素地址中最低的</strong>」。栈指针 %rsp 保存着栈顶元素的地址。所以压栈是减小栈指针（寄存器 %rsp）的值，并将数据存放到内存中，而出栈是从内存中读数据，并增加栈指针的值。</p>
<p>看一个栈操作的例子。最开始是 %rsp 为 0x108，%rax 为 0x123。</p>
<figure><img src="/images/stack-operation.jpg"
         alt="栈操作" width="600"/><figcaption>
            <p>栈操作</p>
        </figcaption>
</figure>

<p>执行指令 <code>pushq %rax</code>，首先将 %rsp 减去 8，得到 0x100，然后把值 0x123 存放到内存地址 0x100 处。</p>
<p>执行完 pushq 指令后，接着就执行 <code>popq %rdx</code> 指令，这时先从内存中读出值 0x123，再写到寄存器 %rdx 中，最后，寄存器 %rsp 的值增加 8，回到了 0x108。</p>
<p>我们可以看到，<strong>%rsp 指向的地址总是栈顶</strong>。</p>
<p>栈和程序代码以及其他形式的程序数据都是放在同一个内存中的，<strong>程序可以用标准的内存寻址方法访问栈内的任意位置</strong>。例如，假设栈顶元素是四字，指令 movq 8(%rsp), %rdx 会将第二个四字从栈中复制到寄存器 %rdx。</p>
<h2 id="算术和逻辑操作">算术和逻辑操作</h2>
<p>在 x86-64 中的算术和逻辑操作，可以分为四组：加载有效地址、一元操作、二元操作和移位。二元操作有两个操作数，一元操作只有一个操作数。</p>
<figure><img src="/images/integer-arithmetic-operations.jpg"
         alt="整数算术操作" width="600"/><figcaption>
            <p>整数算术操作</p>
        </figcaption>
</figure>

<p>加载有效地址（Load effective address) 指令 <code>leaq S, D</code>:</p>
<ul>
<li>S 是地址表达式。</li>
<li>D 是一个寄存器。</li>
</ul>
<p>leaq 指令是将 D 设置为 S 表达式计算出来的地址。例如，leaq (%rdx, %rcx, 4), %rax，它会将表达式 <code>R[%rdx] + R[%rcx] * 4</code> 计算出来的地址，写入到寄存器 %rax 中。</p>
<p>需要特别注意：leaq 指令的第一个操作数 S，只做数学计算，不做内存引用。</p>
<p>用一个例子来对 leaq 和 movq 指令做个比较，能更好的理解它。</p>
<figure><img src="/images/leaq-vs-movq.jpg"
         alt="leaq vs movq" width="600"/><figcaption>
            <p>leaq vs movq</p>
        </figcaption>
</figure>

<p>这种只做数学运算不做内存引用的特点，使得 leaq 指令在一些简单的算术表达式中很有用处。</p>
<p>例如，有这么一个 C 函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">arith</span> (<span style="color:#66d9ef">long</span> x, <span style="color:#66d9ef">long</span> y, <span style="color:#66d9ef">long</span> z) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> t1 <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> y;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> t2 <span style="color:#f92672">=</span> z <span style="color:#f92672">+</span> t1;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> t3 <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> t4 <span style="color:#f92672">=</span> y <span style="color:#f92672">*</span> <span style="color:#ae81ff">48</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> t5 <span style="color:#f92672">=</span> t3 <span style="color:#f92672">+</span> t4;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> rval <span style="color:#f92672">=</span> t2 <span style="color:#f92672">*</span> t5;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> rval;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>编译时，该函数的算术运算会以 leaq 来实现。汇编代码如下：</p>
<pre tabindex="0"><code>  long arith (long x, long y, long z)
  x in %rdi, y in %rsi, z in %rdx

arith:
  leaq  (%rdi, %rsi), %rax            #t1 = x + y
  addq  %rdx, %rax                    #t2 = z + t1;
  leaq  (%rsi, %rsi, 2), %rdx         #y+2y=3y
  salq  $4, %rdx                      #t4 = 3y * 16 = y * 48
  leaq  4(%rdi, %rdx), %rcx           #t5 = 4 + x + t4 = t3 + t4
  imulq %rcx, %rax                    #return t2 * t5
  ret
</code></pre><hr>
<p><code>subq %rax, %rdx </code> 指令，可以解读成 &ldquo;从 %rdx 中减去 %rax&rdquo;。subq 指令有两个操作数：</p>
<ul>
<li>第一个操作数是源操作数，可以是立即数、寄存器或是内存位置。</li>
<li>第二个操作数是目的操作数，它既是源又是目的，可以是寄存器或是内存位置。当为内存位置时，处理器必须<strong>从内存读出值</strong>，执行操作，再把结果写回内存。</li>
</ul>
<p>例如，给出内存地址和寄存器的情况的如下：</p>
<pre tabindex="0"><code>Memory Address  |  Value            Register |  Value
---------------------------       -----------------------
  0x100         |   0xFF              %rax   |  0x100
  0x108         |   0xAB              %rcx   |  0x1
  0x110         |   0x13              %rdx   |  0x3
</code></pre><p>执行指令</p>
<pre tabindex="0"><code>Instruction          |  Destination  |  Value
-----------------------------------------------
  addq %rcx, (%rax)  |   0x100       |  0x100
  subq %rdx, 8(%rax) |   0x108       |  0xA8
</code></pre><p>目的操作数 (%rdx)、8(%rax) 都为内存地址，要先从内存中读出值，它们的值分别为 0xFF、0xAB，执行操作后，再把结果写回到内存。最后，内存地址 [0x100] 的值为 0x100，内存地址 [0x108] 的值为 0xA8。</p>
<hr>
<p><code>sal、shl</code> 为左移位指令，两者都是将右边填上 0。</p>
<p><code>sar</code> 为算术右移，填符号为。</p>
<p><code>shr</code> 为逻辑右移，填上 0。</p>
<p>移位操作的源操作数为移位量，可以是一个立即数，或者放在单字节寄存器 %cl 中。目的操作数为要移位的数，可以是一个寄存器或是一个内存位置。</p>
<p>例如：</p>
<pre tabindex="0"><code>sal $4, %rax
sar %cl, %rax
</code></pre><hr>
<p><code>xorq %rdx, %rdx</code>，这条指令会将寄存器 %rdx 设置为 0。对于任意 x，x^x = 0。</p>
<h2 id="控制">控制</h2>
<p>C 语言中的条件语句、循环语言和分支语言，要求有条件的执行，根据测试的结果决定操作执行的顺序。机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。</p>
<p>除了整数寄存器，CPU 还维护着一组「<strong>单个位</strong>（single bit）」的「条件码」（condition code）寄存器，它们描述了最近算术或逻辑操作的情况。可以检查这些寄存器来执行条件分支指令。</p>
<p>最常用的条件码有：</p>
<ul>
<li>CF：进位标志。最近的操作使最高位产生了进位。可以用来检查无符号操作是否溢出。</li>
<li>ZF：零标志。最近的操作得出的结果为 0。</li>
<li>SF：符号标志。最近的操作得到的结果为负数。</li>
<li>OF：溢出标志。最近的操作导致一个补码溢出。</li>
</ul>
<p>除了 leaq 指令不改变任何条件码，前面（图：<em>整数算术操作</em>）列出的算术和逻辑操作指令都会设置条件码。</p>
<ul>
<li>对于逻辑操作，例如 XOR，进位标志（CF）和溢出标志（OF）会设置为 0.</li>
<li>对于移位操作，进位标志将设置为最后一个被移出的位，而溢出标志设置为 0。</li>
<li>INC 和 DEC 指令会设置溢出和零标志，但不会改变进位标志。</li>
</ul>
<p>另外，CMP 和 TEST 这两类指令也会设置条件码，但它们不会改变任何其他的寄存器，就是说不会更新目的寄存器。比如，<code>cmp S1, S2 </code>指令根据两个操作数之差（S2-S1）来设置条件码，它不会改变 S2 的值。</p>
<p><code>test S1, S2</code> 指令的结果是基于 S1&amp;S2。典型的用法是，两个操作数是一样，比如，testq %rax, %rax 指令用来检查 %rax 是负数、零，还是正数。或者其中一个操作数是一个掩码，用来指示哪些为应该被测试。</p>
<hr>
<p>条件码通常不会直接读取，常用的使用方法有三种：</p>
<ul>
<li>可以根据条件码的某种组合将一个字节设置为 0 或者 1。</li>
<li>可以条件跳转到程序的某个其他的部分。</li>
<li>可以有条件地传送数据。</li>
</ul>
<p>SET 指令就是根据条件码的某种组合，将一个字节设置为 0 或者 1。</p>
<figure><img src="/images/setx.jpg"
         alt="SET 指令" width="600"/><figcaption>
            <p>SET 指令</p>
        </figcaption>
</figure>

<ul>
<li>SET 指令的目的操作数是低位单字节寄存器（如 al、dl）之一，或者是一个字节的内存位置。</li>
<li>SET 指令不会修改寄存器的剩余字节。
<ul>
<li>通常用 <code>movzbl</code> 指令来将高 32 位设置为 0。</li>
<li>我们知道，在 x86-64 中，任何为寄存器生成 32 位（4 字节）值的指令，也会将寄存器的高位部分（最高 4 个字节）设置为 0。比如，movl、movzbl、movsbl。</li>
</ul>
</li>
</ul>
<p>例如，有 C 代码：</p>
<pre tabindex="0"><code>int gt(long x, long y) {
  return x &gt; y;
}
</code></pre><p>它的汇编指令如下：</p>
<pre tabindex="0"><code>  int get(long x, long y)
  x in %rdi, y int %rsi

gt:
  cmpq    %rsi, %rdi  # compare x:y
  setg    %al         # al = x &gt; y
  movzbl  %al, %eax   # Zero rest of %rax
  ret
</code></pre><p>先是执行比较指令，根据计算（y - x）设置条件码。然后，setg 指令根据条件码的组合（~(SF^0F)&amp;~ZF），将 %al 设置为 0 或 1。最后，movzbl 指令将高位填充为 0 传送到 %rax 作为结果返回。</p>
<hr>
<p>正常情况下，指令按照它们出现的顺序一条一条地执行。跳转（jump）指令会导致执行切换到程序中一个全新的位置。</p>
<ul>
<li>它根据条件码跳转到代码的不同部分。</li>
<li>跳转的目的地是一个地址。在汇编代码中，通常用一个标号（Label）指明。</li>
</ul>
<p><code>jmp</code> 指令是无条件跳转。它可以是直接跳转，即跳转目标是作为指令的一部分编码的；也可以是间接跳转，即跳转目标是从寄存器或内存位置中读出的。</p>
<p>例如，直接跳转，用一个标号作为跳转目标：</p>
<pre tabindex="0"><code>jmp .L1     # L1 为标号。
</code></pre><p>间接跳转，在 “*” 号后面跟一个操作数指示符：</p>
<pre tabindex="0"><code>jmp *%rax   # 用寄存器 %rax 中的值作为跳转目标

jmp *(%rax) # 以 %rax 中的值作为读地址，从内存中读出跳转目标
</code></pre><p>详细的跳转指令表：</p>
<figure><img src="/images/jump.jpg"
         alt="跳转指令"/><figcaption>
            <p>跳转指令</p>
        </figcaption>
</figure>

<p>除 jmp 之外，表中其他的跳转指令都是有条件的，它们根据条件码的某种组合，跳转或继续执行代码序列中下一条指令。</p>
<p>跳转目标在汇编和链接时会进行编码，最常用的编码方法是「PC-relative」（PC 相对的）。<strong>它会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码</strong>。另外一种编码方法是给出 “绝对” 地址，用 4 个字节直接指定目标。汇编器和链接器会选择适当的编码方法。</p>
<p>下面是一个 PC-relative 的例子，假设有一个函数的汇编代码如下：</p>
<pre tabindex="0"><code>   movq  %rdi, %rax
   jmp   .L2
 .L3:
   sarq  %rax
 .L2
   testq %rax, %rax
   jg    .L3
   rep；ret
</code></pre><p>汇编器产生的 &ldquo;.o&rdquo; 格式的反汇编代码如下：</p>
<pre tabindex="0"><code>1    0:    48 89 f8          mov   %rdi,%rax
2    3:    eb 03             jmp   8 &lt;loop+0x8&gt;
3    5:    48 d1 f8          sar   %rax
4    8:    48 85 c0          test  %rax,%rax
5    b:    7f f8             jg    5 &lt;loop+0x5&gt;
6    d:    f3 c3             repz retq
</code></pre><p>从反汇编的代码中可以看到，第 2 行和第 5 行中跳转指令的跳转目标分别指明为 0x8 和 0x5。观察指令的字节编码，会看到第一条跳转指令的目标编码（在第二个字节中）为 0x03。把它加上 0x5（也就是下一条指令的地址），就得到跳转目标地址 0x8，也就是第 4 行指令的地址。类似地，第二条跳转指令的目标编码是 0xf8，将它加上 0xd（第 6 行指令的地址），得到跳转目标地址 0x5，也就是第 3 行指令的地址。</p>
<p>下面是经过链接器链接后的程序反编译代码：</p>
<pre tabindex="0"><code>1    4004d0:    48 89 f8          mov   %rdi,%rax
2    4004d3:    eb 03             jmp   4004d8 &lt;loop+0x8&gt;
3    4004d5:    48 d1 f8          sar   %rax
4    4004d8:    48 85 c0          test  %rax,%rax
5    4004db:    7f f8             jg    4004d5 &lt;loop+0x5&gt;
6    4004dd:    f3 c3             repz retq
</code></pre><p>链接之后，这些指令被「重定位」到不同的地址，但是第 2 行和第 5 行中跳转目标的编码并没有变。</p>
<hr>
<h3 id="实现条件分支">实现条件分支</h3>
<p>条件分支的实现方式有两种：</p>
<ul>
<li>使用「控制」的条件转移实现。
<ul>
<li>当条件满足时，程序沿着一条执行路径执行，当条件不满足时，就走另一条路径。</li>
<li>这种机制，在现代处理器上，非常低效。</li>
</ul>
</li>
<li>使用「数据」的条件转移实现
<ul>
<li>计算一个条件操作的两种结果，然后根据条件是否满足从中选取一个。</li>
<li>这种策略只有在一些受限制的情况中才可行，一旦可行，就可以用一条简单的「条件传送」指令来实现它，条件传送指令更符合现代处理器的性能特性。</li>
</ul>
</li>
</ul>
<p>例如，一个计算两个数之差的 C 函数如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">absdiff</span>(<span style="color:#66d9ef">long</span> x, <span style="color:#66d9ef">long</span> y) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> result;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">&gt;</span> y)
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> x<span style="color:#f92672">-</span>y;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> y<span style="color:#f92672">-</span>x;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用条件控制实现的汇编代码。编译命令：gcc –Og -S –fno-if-conversion control.c</p>
<pre tabindex="0"><code>  long absdiff(long x, long y)
  x in %rdi, y in %rsi

absdiff:
  cmpq    %rsi, %rdi  # Compare x:y
  jle     .L4
  movq    %rdi, %rax
  subq    %rsi, %rax
  ret
.L4:      # x &lt;= y
  movq    %rsi, %rax
  subq    %rdi, %rax
  ret
</code></pre><p>使用条件数据传送实现的汇编代码</p>
<pre tabindex="0"><code>  long absdiff(long x, long y)
  x in %rdi, y in %rsi

absdiff：
  movq    %rdi, %rax  # x
  subq    %rsi, %rax  # result = x-y
  movq    %rsi, %rdx
  subq    %rdi, %rdx  # else_val = y-x
  compq   %rsi, %rdi  # Compare x:y
  cmovle  %rdx, %rax  # if &lt;=, result = else_val
  ret
</code></pre><p>基于条件数据传送的代码比基于条件控制转移的代码性能要好的原因是：处理器<strong>无需预测</strong>测试的结果<strong>就可以执行条件传送</strong>。</p>
<p>现代处理器通过使用「流水线」（pipelining）技术来获得高性能。在流水线中，一条指令的处理要经过一系列的「阶段」，每个阶段执行所需操作的一小部分（比如，从内存取指令、确定指令类型、从内存读数据、执行算术运算、向内存写数据，以及更新程序计数器）。流水线技术通过重叠连续指令的步骤，从而获得高性能。例如，在取一条指令的同时，执行它前面一条指令的算术运算。要做到这一点，要求能够事先确定要执行的指令序列，这样才能保证流水线中充满待执行的指令。当机器遇到「条件跳转」（也就是“分支”）时，只有当分支条件求值完成之后，才能决定分支往哪边走。现代处理器采用非常精密的「分支预测逻辑」来猜测每条跳转指令是否会执行。分支预测是否正确，成了性能好坏的关键。现代处理器设计试图达到 90% 以上的预测成功率。同条件跳转不同，处理器<strong>无需预测</strong>测试的结果<strong>就可以执行条件传送</strong>。处理器只是读源值（可能是从内存中），检查条件码，然后要么更新目的寄存器，要么保持不变。</p>
<p>详细的条件传送指令表：</p>
<figure><img src="/images/cmovx.jpg"
         alt="条件传送指令" width="600"/><figcaption>
            <p>条件传送指令</p>
        </figcaption>
</figure>

<p>每条指令都有两个操作数：源寄存器或者内存地址 S，和目的寄存器 R。当传送条件满足时，指令把源值 S 复制到目的 R。</p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/cs">cs</a></li>
					
				</ul>
			</nav>
			
			
		</div>
	</article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/x-29" title="GitHub"><i data-feather="github"></i></a><a class="soc" href="https://twiiter.com/x-29/" title="Twitter"><i data-feather="twitter"></i></a><a class="soc" href="https://gitlab.com/x-29/" title="GitLab"><i data-feather="gitlab"></i></a></div>
  <div class="footer-info">
    2022  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>


<script>
  feather.replace()
</script></div>
    </body>
</html>
