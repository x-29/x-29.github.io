<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>计算机网络(Computer Networking)笔记(一) - CS里的X-29</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="计算机网络(Computer Networking: A Top-Down Approach)学习笔记." />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="计算机网络(Computer Networking)笔记(一)" />
<meta property="og:description" content="计算机网络(Computer Networking: A Top-Down Approach)学习笔记." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://x-29.github.io/post/2022-05-computer-networking-notes/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-05-23T23:56:18+08:00" />
<meta property="article:modified_time" content="2022-05-23T23:56:18+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="计算机网络(Computer Networking)笔记(一)"/>
<meta name="twitter:description" content="计算机网络(Computer Networking: A Top-Down Approach)学习笔记."/>
<script src="https://x-29.github.io/js/feather.min.js"></script>
	
	
        <link href="https://x-29.github.io/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://x-29.github.io/css/main.40ca3a860425083862b7ebd55447caec5c4384573f0cb098b8d06a91e8dace2e.css" />
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://x-29.github.io/">CS里的X-29</a>
	</div>
	<nav>
		
		<a href="/">首页</a>
		
		<a href="/post">文章</a>
		
		<a href="/about">关于</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">计算机网络(Computer Networking)笔记(一)</h1>
			<div class="meta">Posted on May 23, 2022</div>
		</div>
		

		<section class="body">
			<p>这是<a href="https://book.douban.com/subject/26176870/">《计算机网络自顶向下方法 第6版》</a>一书的读书笔记的第一部分。</p>
<p><a href="../2022-05-computer-networking-notes-part2">第二部分</a></p>
<h2 id="一-计算机网络和因特网">一 计算机网络和因特网</h2>
<p><em>从整体上粗线条地勾画出计算机网络地概貌。</em></p>
<h3 id="因特网">因特网</h3>
<p>因特网是一个世界范围地计算机网络，即它是一个互联了遍及全世界地数以亿计的计算机设备的网络。这些设备包括传统的桌面 PC、Linux 工作站已经现在的智能手机、平板电脑、游戏机、家用电器等，我们称之为<strong>主机</strong>（host）或<strong>端系统</strong>（end system）</p>
<ul>
<li>端系统 (end system) 通过通信链路 (communication link) 和分组交换机（packet switch）连接到一起。通信链路根据物理媒体组成可以分为铜轴电缆、铜线、光纤和无线电频谱。不同的链路以不同的速率传输数据，链路的传输速率以 <code>bit/s</code> 度量（或者 bps）。</li>
<li>一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节。由此形成的信息包称为<strong>分组</strong> (packet）。这些分组通过网络发送到目的端系统。</li>
<li>分组交换机从它的一条<em>入</em>通信链路接收到达的分组，并从它的一条<em>出</em>通信链路转发该分组。交换机主要有两类：<code>路由器（router）</code>和<code>链路层交换机（link-layer switch）</code>。
<ul>
<li>从发送端系统到接收端系统，一个分组（packet）所经历的一系列通信链路和分组交换机称为该网络的<strong>路径</strong>(route 或 path)。</li>
</ul>
</li>
<li>端系统、分组交换机和其他因特网部件都要运行一系列<strong>协议</strong>（protocol），这些协议控制因特网中信息的接收和发送。
<ul>
<li>e.g，TCP，IP，HTTP，Skype，802.11</li>
</ul>
</li>
<li>因特网的标准由 <strong>IETF</strong>（Internet Engineering Task Force）研发。
<ul>
<li>IETF 的标准文档称为 <strong>RFC</strong>（Request For Comment）。</li>
</ul>
</li>
</ul>
<p>因特网也可以被看作为应用程序提供服务的基层设施，应用程序可以是 Web，Email，电子商务等。应用程序只需调用端系统提供的 API，就可通过因特网进行数据传输。</p>
<h3 id="协议">协议</h3>
<p><strong>协议</strong>（protocol）定义了在两个或多个通信实体之间交换的报文<code>格式</code>和<code>次序</code>，以及报文发送和/或接收一条报文或其他事件<code>所采取的动作</code>。</p>
<p>因特网广泛地使用了协议，不同的协议用于完成不同的通信任务。</p>
<h3 id="因特网的部件网络边缘接入网和网络核心">因特网的部件：网络边缘、接入网和网络核心</h3>
<p>端系统也称为主机，位于因特网的边缘。</p>
<ul>
<li>主机被进一步划分为客户端（client）和服务器（server）。客服端通常是桌面 PC、移动 PC和智能手机等；而服务器是更为强大的机器，用于存储和发布 Web 页面、流视频等，如今，通常用于大型数据中心（data center）。</li>
</ul>
<p>接入网是指端系统连接到其边缘路由器（edge router）的物理链路。</p>
<ul>
<li>边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器。</li>
<li>如今，宽带住宅接入技术包括数字用户线（DSL)、电缆、光纤到户（FTTH）；企业（公司、学校）接入最流行的是以太网和 WiFi 两种接入技术，利用局域网（LAN）将端用户连接到边缘路由器；广域无线因特网接入技术采用了 3G/4G。</li>
</ul>
<p>网络核心是由连接因特网端系统的分组交换机和链路构成的网状网络。</p>
<ul>
<li>为了从源端系统向目的端系统发送一个报文，源将长报文划分成较小的数据块，称之为<strong>分组</strong>（packet)。在源和目的之间，每个分组都通过通信链路和分组交换机（packet switch）传送。</li>
<li>分组以等于链路最大传输速率的速度传输通过通信链路。</li>
<li>如果某源端系统或分组交换机经过一条链路发送一个 <em>L</em> bit 的分组，链路的传输速率为 <em>R</em> bit/s，那么传输该分组的时间为 <em>L/R</em> /s。</li>
</ul>
<p>大多数分组交换机在链路的输入端使用<code>存储转发传输</code>（store-and-forward transmission）机制。这意味着交换机必须接收到整个分组，才向输出链路传输。（之前接收到的比特先缓存（即 “存储”）起来，仅当已经接收完了该分组的所有比特后，才开始向出链路传输（即 “转发”）该分组）</p>
<blockquote>
<p>一个端到另一个端的时延 = 2<em>L/R</em>（假设传播时延为 0）。</p>
</blockquote>
<p>每个分组交换机都有多条链路与之相连。对于每条相连的链路，该分组交换机具有一个输出缓存（output buffer）（也称为输出队列，用于存储路由器准备发往那条链路的分组。如果在一段时间内，链路的到达速率（以比特为单位）超过链路的传输速率：</p>
<ul>
<li>分组将会在输出缓存中排队，等待在链路上传输。(排队等待就会出现排队时延）</li>
<li>如果输出缓存填满，分组可能被丢弃（丢失）。</li>
</ul>
<p>每台路由器都有一个<code>转发表</code>，将目的地址（或目的地址的一部分）映射成输出链路。当分组到达路由器时，路由器以目的地址搜索其转发表，找到对应的输出链路，将分组导向该输出链路。端到端选路过程类似于一个不使用地图而喜欢问路的汽车司机，每到一个地点，就打听下一个地点的路线。</p>
<h3 id="时延">时延</h3>
<p>当分组从一个结点（主机或路由器）沿着一条路径到达后继结点（主机或路由器），该分组在沿途的每个结点将会经受几种不同类型的时延：</p>
<p><img src="/images/img_202.jpg" alt="结点时延"></p>
<ul>
<li>结点处理时延（nodal processing delay）
<ul>
<li>检查比特级别的差错</li>
<li>决定将分组导向何处</li>
<li>高速路由器的处理时延通常 &lt; msec (微秒或更低)。</li>
</ul>
</li>
<li>排队时延（queuing delay）
<ul>
<li>分组在链路上等待传输的时间</li>
<li>依赖于路由器的拥塞程度</li>
<li>时延在毫秒到微秒级别</li>
</ul>
</li>
<li>传输时延（transmission delay）
<ul>
<li>路由器将分组推出所需要的时间</li>
<li><em>L</em>：表示分组长度（bit)</li>
<li><em>R</em>: 表示链路带宽，即从路由器 A 到路由器 B 的链路传输速率（bps)。对于一条 10Mbps 的以太网链路，速率 <em>R</em>=10Mbps；对于 100Mbps 的以太网链路，速率 <em>R</em>=100Mbps。</li>
<li>传输时延 = <em>L/R</em>，通常在毫秒到微秒级别。</li>
</ul>
</li>
<li>传播时延（propagation delay）
<ul>
<li>一个比特从一台路由器向另一台路由器传播所需要的时间</li>
<li><em>d</em>: 表示物理链路的长度，即两台路由器之间的距离</li>
<li><em>s</em>: 表示链路的传播速率，取决于链路的物理媒体（即光纤、双绞铜线等）</li>
<li>传播时延=<em>d/s</em>，毫秒级别。</li>
</ul>
</li>
</ul>
<blockquote>
<p>结点时延 = 结点处理时延 + 排队时延 + 传输时延 + 传播时延。</p>
</blockquote>
<h3 id="因特网的协议栈">因特网的协议栈</h3>
<p>因特网的协议栈由 5 个层次组成：物理层(Physical)、链路层(Link)、网络层(Network)、运输层(Transport)和应用层(Application)。</p>
<ul>
<li>应用层包括许多协议，例如 HTTP, IMAP, SMTP, DNS，它们分布在多个端系统上。一个端系统中的应用程序使用应用层协议与另一个端系统中的应用程序交换信息的分组。这种位于应用层的信息分组称为报文 (message)。</li>
<li>传输层负责在端系统中的应用程序之间传输应用层的报文 (message)，传输层的协议有两个，即 TCP 和 UDP。传输层的分组称为报文段 (segment)。</li>
<li>网络层负责将称为数据报（datagram）的网络层分组从一台主机路由到另一台主机。网络层最著名的协议是 IP 协议，所以通常也被间称为 IP 层。</li>
<li>链路层的任务是在相邻的网络元素之间传输链路层分组。包括的协议有：Ethernet, 802.11 (WiFi), PPP。链路层分组称为帧。</li>
<li>物理层的任务是将帧中的一个一个比特（bit）从一个结点移动到下一个结点。</li>
</ul>
<p><img src="/images/img_201.jpg" alt="主机、路由器和链路层交换机，每个包含了不同的层，反映了不同的功能"></p>
<p>如图，数据从发送端系统（source）的协议栈一路向下，然后向上和向下经过中间的链路层交换机和路由器的协议栈，进而向上到达接收端系统（distination）的协议栈。位于下层的都会对上一层的报文进行封装，附加自己的首部信息。例如，运输层收到应用层的报文，附加上自己的首部信息构成运输层报文段。运输层报文段因此封装了应用层报文。</p>
<h2 id="二-应用层">二 应用层</h2>
<p><em>学习应用层协议的概念和实现方面的知识。</em></p>
<h3 id="应用层协议原理">应用层协议原理</h3>
<p>现代网络应用程序使用两种主流的体系结构：客户/服务器体系结构（Client/Server）和对等（P2P）体系结构。</p>
<p>在客户/服务器体系结构中，有一台总是打开的主机称为<code>服务器</code>，它服务于称为<code>客户</code>的主机的请求。一个经典的例子是 Web 应用程序，其中总是打开的专用 Web 服务器服务于浏览器（运行在客户主机上）的请求。值得注意的是利用客户/服务器体系结构，客户相互之间不直接通信，如 Web 应用程序中的两个浏览器并不之间通信。使用客户/服务器体系结构的著名的应用程序包括 Web，FTP、Telnet 和电子邮件。</p>
<p>在 P2P 体系机构中，应用程序对专用服务器的依赖很少，它在间断连接的主机对之间直接通信，这些主机对被称为对等方。因为这种对等方通信不必通过专门的服务器，该体系结构被称为对等方到对等方的。使用 P2P 体系机构的流行应用包括 BT，迅雷，Skype 和 IPTV。</p>
<hr>
<p>在操作系统的术语中，进行通信的实际上是进程（process）而不是程序。一个进程k以被认为是运行在端系统中的一个程序，网络应用程序由成对进程组成，这些进程通过跨越计算机网络交换报文而相互通信。例如，在 Web 应用程序中，一个客户浏览器进程与另一台 Web 服务器进程交换报文。在一个 P2P 文件共享系统中，文件从一个对等方中的进程传输到另一个对等方中的进程。</p>
<p>进程通过一个称为套接字（socket）的软件接口向网络发送报文和从网络接收报文。看一个类比，把进程类比于一座房子，而它的套接字可以类比于它的门。当一个进程想向位于另外一台主机上的另一个进程发送报文是，它把报文推出该门（套接字）。该发送进程假定该门到另外一侧之间有运输的基础设施，该设施将把报文传送到目的进程的门口。一旦该报文抵达目的主机，它通过接收进程的门（套接字）传递，然后接受进程对该报文进行处理。</p>
<p><img src="/images/processes-communicating.jpg" alt="进程与socket"></p>
<p>如图，套接字是同一台主机内应用程序层与传输层之间的接口。由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的 API。</p>
<hr>
<p>在一台主机上运行的进程为了向另一台主机上运行的进程发送分组，它需要知道两个信息：一是接收主机的地址，二是主机上的接收进程。在因特网中，主机由一个 32 位的 IP 地址标识，主机上运行的进程用端口号标识。例如，向一台 Web 服务器（gaia.cs.umass.edu）发送 HTTP 请求，那么发送端需要知道这台 Web 服务器的 IP 地址是 128.119.245.12，接收进程的端口号是 80。</p>
<hr>
<p>因特网为应用程序提供了两个运输层协议，即 TCP 和 UDP。它们为应用程序提供了不同的服务。</p>
<p>TCP服务包括了面向连接服务和可靠数据传输服务。当某个应用程序选择 TCP 作为运输协议时，这个应用程序就获得了 TCP 的这两种服务。</p>
<ul>
<li>面向连接的服务：在应用层数据报文开始流动之前，TCP 让客户和服务器先握手，相互交换运输层控制信息，握手之后，就在两个进程的套接字之间建立起一条 TCP 连接，这条连接是全双工的，连接双方的进程可以在此连接上同时发送和接收报文。当结束报文发送时，这条连接必须要断开。</li>
<li>可靠的数据传输服务：通信进程能够依靠 TCP，无差错、按适当顺序交付所有发送的数据。当应用程序的一端将字节流传进套接字时，它能够依靠 TCP 将相同的字节流交付给接收方的套接字，而没有字节的丢失和冗余。</li>
</ul>
<p>TCP 协议还具有拥塞控制机制，当发送方和接收方之间的网络出现拥塞时，TCP 的拥塞控制机制会抑制发送进程。</p>
<p>UDP 是一种不提供不必要服务的轻量级运输协议，它仅提供最小的服务。</p>
<ul>
<li>UDP 是无连接的，在两个进程通信前没有握手过程。</li>
<li>UDP 提供一种不可靠数据传输服务，当一个进程将报文发送进 UDP 套接字时，UDP 协议不会保证报文能到达接收进程。不仅如此，到达接收进程的报文也可能是乱序到达的。</li>
</ul>
<p>UDP 没有拥塞控制机制，发送端可以用任意速率向下层（网络层）发送数据（实际情况可能会因文中间链路的带宽限制或拥塞，端到端的吞吐量可能小于这种速率）。</p>
<hr>
<p>应用层协议 (application-layer protocol) 定义了运行在不同主机上的应用程序进程如何相互传递报文。特别是定义了：</p>
<ul>
<li>交换的报文类型，例如请求报文和响应报文。</li>
<li>各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的。</li>
<li>字段的语义，即这些字段中包含的信息的含义。</li>
<li>一个进程何时以及如何发送报文，对报文进行响应的规则。</li>
</ul>
<p>网络应用和应用层协议是有区别的。应用层协议只是网络应用的一部分，例如，Web 是一种客户/服务器应用，它允许客户按照需求从 Web 服务器获取文档。该 Web 应用有很多组成部分，包括文档格式的标准（即 HTML）、Web 浏览器（如 Firefox，Chrome）、Web server (如 Apache、Nginx），以及一个应用层协议。Web 的应用层协议是 HTTP，它定义了在浏览器和 Web 服务器之间传输的报文格式和序列。因此 <code>HTTP 协议只是 Web 应用的一个部分</code>（尽管是重要的部分）。</p>
<h3 id="http-协议">HTTP 协议</h3>
<p>Web 的应用层协议是<strong>超文本传输协议</strong>（HyperText Transfer Protocol, HTTP），它是 Web 的核心，在 [RFC 1945] 和 [RFC 2616] 中定义。</p>
<p>HTTP 由两个程序实现：一个是客户程序（称为 <strong>Web 客户</strong>，如 Firefox、Chrome）和一个服务器程序（称为 <strong>Web 服务器</strong>， 如 Apache、Nginx）。客户程序和服务器程序运行在不同的主机上，通过交换 HTTP 报文进行会话。HTTP 定义了这些报文的结构以及客户和服务器进行报文交换的方式。</p>
<p>一些 Web 术语：</p>
<blockquote>
<p>Web 页面，也叫文档，是由对象组成的。</p>
</blockquote>
<blockquote>
<p>一个对象（object) 只是一个文件，如一个 HTML 文件、一个 JPEG 图形文件，它们可以通过一个 URL 地址定位到。</p>
</blockquote>
<blockquote>
<p>每个 URL 地址有两部分组成：存放对象的服务器主机名和对象的路径名。例如：URL 地址 <a href="http://www.someSchoool.edu/someDepartment/picture.gif">http://www.someSchoool.edu/someDepartment/picture.gif</a>，其中的 <a href="https://www.someSchool.edu">www.someSchool.edu</a> 是主机名，/someDepartment/picture.gif 是路径名。</p>
</blockquote>
<p><img src="/images/http-request-response.jpg" alt="HTTP 的请求-响应行为"></p>
<p>客户和服务器的交换过程，如图所示。当用户请求一个 Web 页面（如点击一个超链接）时，浏览器向服务器发出对该页面中所包含对象的 HTTP 请求报文，服务器接收到请求并用包含这些对象的 HTTP 响应报文进行响应。</p>
<p>HTTP 使用 TCP 作为它的支撑运输协议。HTTP 客户首先发起一个与服务器的 TCP 连接。一旦连接建立，该浏览器和服务器进程就可以通过套接字接口访问 TCP。客户端的套接字是客户进程与 TCP 连接之间的门，在服务器端的套接字接口则是服务器进程与 TCP 连接之间的门。客户向它的套接字接口发送 HTTP 请求报文并从它的套接字接口接收 HTTP 响应报文。同样地，服务器从它的套接字接口接收 HTTP 请求报文和向它的套接字接口发送 HTTP 响应报文。<strong>一旦客户向它的套接字接口发送了一个请求报文，该报文就脱离了客户控制并进入 TCP 的控制</strong>。</p>
<p>HTTP 服务器不保存关于客户的任何信息，所以说 HTTP 是一个无状态协议（stateless protocol）。</p>
<p><strong>往返时间</strong>（Round-Trip Time, RTT）是指一个短分组从客户到服务，然后再返回到客户所花费的时间。RTT 包括分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理时延。</p>
<h3 id="http-报文格式">HTTP 报文格式</h3>
<p>HTTP 规范 [RFC 1945；RFC 2616] 包含了对 HTTP 报文格式的定义。HTTP 报文有两种：</p>
<ul>
<li>请求报文</li>
<li>响应报文</li>
</ul>
<p>一个典型的 HTTP 请求报文，如下：</p>
<pre tabindex="0"><code>GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agen: Mozilla/5.0
Accept-language: fr
</code></pre><p>HTTP 请求报文是 ASCII 文本，第一行叫做请求行（request line），其后的行叫做首部行（header line）。</p>
<p>请求行有 3 个字段：</p>
<ol>
<li>方法字段。方法字段的取值包括 GET、POST、HEAD、PUT 和 DELETE。绝大部分的 HTTP 请求报文时延 GET 方法。</li>
<li>URL 字段。指定请求对象的标识。</li>
<li>HTTP 版本字段。自解释的。</li>
</ol>
<p>请求报文的每一行都以回车+换行（\r\n）结束，行内的字段之间以空格隔开。首部行可以有多行，最后必须以一个空行（\r\n）表明首部行的结束。</p>
<figure><img src="/images/http-request-general-format.jpg"
         alt="一个 HTTP 请求报文的通用格式"/><figcaption>
            <p>一个 HTTP 请求报文的通用格式</p>
        </figcaption>
</figure>

<p>从 HTTP 请求报文的通用格式上，可以看到在首部行后面还有一个实体体（entity body）。在方法为 POST 时，就会用到这个实体体字段，它包含了用户在表单字段中输入的值。<strong>注意：实体体和首部行之间有一个空行（回车+换行）</strong>。</p>
<p>一个典型的 HTTP 响应报文，如下：</p>
<pre tabindex="0"><code>HTTP/1.1 200 OK
Connection: close
Date: Tue, 09 Aug 2011 15:44 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html

(data data data data ....)
</code></pre><p>HTTP 响应报文一共有三个部分，第一行是状态行（status line），其后是首部行（header line），最后是实体体（entity body）。实体体部分是报文的主要部分，它包含了所请求的对象本身（表示为 data data data data &hellip;.）。</p>
<p>状态行有 3 个字段：协议版本字段、状态码和相应状态短语。其中，状态码及其相应的短语指示了请求的结果。</p>
<p>一些常见的状态码和相关的短语：</p>
<blockquote>
<ul>
<li>200 OK: 请求成功，信息在返回的响应报文中。</li>
<li>301 Moved Permanently: 请求的对象已经被永久转移，新的 URL 定义在响应报文的 Location: 首部中。客户软件将自动获取新的 URL。</li>
<li>400 Bad Request: 一个通用差错码，指示该请求不能被服务器理解。</li>
<li>404 Not Found: 被请求的文档不在服务器上。</li>
<li>505 HTTP Version NOT Supported: 服务器不支持请求报文使用的 HTTP 协议版本。</li>
</ul>
</blockquote>
<figure><img src="/images/http-response-general-format.jpg"
         alt="一个 HTTP 响应报文的通用格式"/><figcaption>
            <p>一个 HTTP 响应报文的通用格式</p>
        </figcaption>
</figure>

<p>用 Telnet 来测试一下 HTTP:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ telnet cis.poly.edu <span style="color:#ae81ff">80</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>GET /~ross/ HTTP/1.1
</span></span><span style="display:flex;"><span>Host: cis.poly.edu
</span></span></code></pre></div><p>(在输入最后一行后连续按两次回车。）这就打开一个到主机 cis.poly.edu 的 80 端口的 TCP 连接，并发送一个 HTTP 请求报文。</p>
<h3 id="电子邮件">电子邮件</h3>
<p>因特网电子邮件系统有 3 个主要的组成部分：用户代理（user agent）、邮件服务器（mail server）和简单邮件传输协议（Simple Mail Transfer Protocol, SMTP）。</p>
<p>邮件的发送过程是：邮件从发送方的用户代理开始，传输到发送方到邮件服务器，再传输到接收方的邮件服务器，然后被分发到接收方的邮箱中（每个接收方在邮件服务器上有一个邮箱）。在发送方的邮件服务器不能将邮件传输到接收方的邮件服务器时，邮件将会被保留在发送方的邮件服务器的报文队列中等待再次发送。</p>
<p>SMTP 是因特网电子邮件中主要的应用层协议。它使用 TCP 可靠数据传输服务，从发送方的邮件服务器向接收方的邮件服务器发送邮件。SMTP 有两个部分（sides）：运行在发送方邮件服务器的客服端（client side）和运行在接收方邮件服务器的服务器端（server side）。每台邮件服务器上既运行 SMTP 的客户端也运行 SMTP 的服务器端。当一个邮件服务器向其他邮件服务器发送邮件时，它就表现为 SMTP 的客户；当邮件服务器从其他邮件服务器上接收邮件时，它就表现为一个 SMTP 的服务器。</p>
<p><img src="/images/alice-send-message-to-bob.jpg" alt=""></p>
<p>如图，从 Alice 给 Bob 发送一条报文的场景，来看 SMTP 的基本操作。</p>
<ol>
<li>Alice 用她的用户代理给 “bob@someschool.edu&quot; 撰写报文。</li>
<li>Alice 的用户代理把报文发送到她的邮件服务器，该报文被放置在报文队列中。</li>
<li>Alice 的邮件服务器上的 SMTP 客户创建一条到 Bob 的邮件服务器上的 SMTP 服务器的 TCP 连接。</li>
<li>在经过一些初始 SMTP 握手后，SMTP 客户通过这条 TCP 连接发送报文。</li>
<li>在 Bob 的邮件服务器上，SMTP 服务器端接收报文，然后将报文放入 Bob 的邮箱中。</li>
<li>Bob 用他的用户代理阅读报文。</li>
</ol>
<p>可以看到，SMTP 将一个报文从发送邮件服务器传送到接收邮件服务，分为了三个阶段：</p>
<figure><img src="/images/smtp-transfer.jpg"/>
</figure>

<ol>
<li>握手（SMTP handshaking)。客户 SMTP (运行在发送邮件服务器上) 建立一个到服务器 SMTP (运行在接收邮件服务器上) 的 TCP 连接后，服务器和客户执行<strong>应用层</strong>的握手，在握手阶段，客户指示发送方的邮件地址和接收方的邮件地址。</li>
<li>传送报文（SMTP transfer）。一旦 SMTP 客户和服务器完成握手之后，客户就发送报文。SMTP 依赖 TCP 提供的可靠数据传输服务无差错地将邮件投递到接收服务器。</li>
<li>关闭连接（SMTP closure)。客户发送完报文后，它指示 TCP 关闭连接。</li>
</ol>
<hr>
<p>一个典型的邮件报文格式，如下：</p>
<pre tabindex="0"><code>From: alice@crepes.fr
To: bob@hamburger.edu
Subject: Searching for the meaning of life.

data data data ...
</code></pre><p>一个邮件报文包含了报文首部（message header）和报文体（message body）。报文首部必须包含 <code>Form:</code> 和 <code>To:</code> 首部行。在报文首部之后，紧接着是一个空白行，然后是以 ASCII 格式表示的报文体。</p>
<hr>
<p>用户代理不能使用 SMTP 取回邮件报文，因为取报文是一个拉操作，而 SMTP 是一个推协议。所以需要引入一个邮件访问协议来解决这个问题。</p>
<p>目前流行的邮件访问协议，包括第三版邮件协议（Post Office Protocol-Version 3, POP3）、因特网邮件访问协议（Internet Mail Access Protocol，IMAP）以及 HTTP。</p>
<p>基于 Web（如 Gmail、Yahoo）收取邮件的一般采用 HTTP 协议，基于邮件客户端（如 Outlook）会采用 POP3 或 IMAP 协议。HTTP 和 IMAP 都允许用户远程在邮件服务器上创建文件夹，移动报文。</p>
<h3 id="dns-因特网的目录服务">DNS-因特网的目录服务</h3>
<p>因特网上的主机和人类一样，可以使用多种方式识别。识别主机的一个方法是用它的<strong>主机名</strong>（hostname），如 <a href="https://www.google.com">www.google.com</a>，www.facebook.com，这些名字便于人们记忆，缺点是不适用于路由器，基于此，主机也可以用 <strong>IP 地址</strong>识别。</p>
<p>域名系统（Domain Name System, DNS）的主要任务是将主机名转换为 IP 地址。DNS 是：</p>
<ul>
<li>一个由分层的 DNS 服务器（DNS server）实现的分布式数据库</li>
<li>一个使得主机能够查询分布式数据库的应用层协议。</li>
</ul>
<p>DNS 服务器通常是运行 BIND（Berkeley Internet Name Domain）软件的 UNIX 机器。DNS 协议运行在 UDP 之上，使用 53 号端口。</p>
<p>为了扩展性，DNS 使用了大量的 DNS 服务器，它们以层次结构组织，并且分布在全世界范围内。大致来说，有 3 种类型的 DNS 服务器：</p>
<ul>
<li>根 DNS 服务器（root DNS servers）。提供 TLD 服务器的 IP 地址。</li>
<li>顶级域（top-level domain，TLD) DNS 服务器。每个顶级域（如 com、org 和 net) 和所有国家的顶级域（如 uk、ca 和 fr) 都有 TLD 服务器（或服务器集群）。TLD 服务器提供了权威 DNS 服务器的 IP 地址 。</li>
<li>权威 DNS 服务器（authoritative DNS servers)。组织自己的 DNS 服务器，提供主机名到 IP 地址的映射。</li>
</ul>
<figure><img src="/images/the-hierarchy-of-dns-servers.jpg"
         alt="部分 DNS 服务器的层次结构"/><figcaption>
            <p>部分 DNS 服务器的层次结构</p>
        </figcaption>
</figure>

<p>举例说明 DNS 服务器交互的方式，假定 DNS 的客户端需要确定主机名为 <code>www.amazon.com</code> 的 IP 地址：</p>
<ul>
<li>首先，客户端查询<code>根 DNS 服务器</code>找到 .com 的 TLD 服务器的 IP 地址。</li>
<li>然后，客户端查询<code>.com TLD 服务器</code>获取 amazon.com 的权威 DNS 服务器的 IP 地址。</li>
<li>最后，客户端查询<code>amazon.com 的权威 DNS 服务器</code>获得主机名为 <a href="https://www.amazon.com">www.amazon.com</a> 的 IP 地址。</li>
</ul>
<p>在 DNS 服务器层次结构之外，还有一个重要的<strong>本地 DNS 服务器</strong>， 当主机发出 DNS 查询请求时，请求先发送到该主机的本地 DNS 服务器，本地 DNS 服务器起着代理的作用，它将请求转发到 DNS 服务器层次结构中。例如，主机 cse.nyu.edu 想知道主机 gaia.cs.umass.edu 的 IP 地址。它首先向它的本地 DNS 服务器 dns.nyu.edu 发送一个 DNS 查询报文，之后由本地 DNS 服务器将报文转发到根 DNS 服务器，在迭代查询 TLD 服务器和权威 DNS 服务器后，本地 DNS 服务器向主机 cse.nye.edu 返回 gaia.cs.umass.edu 的 IP 地址。</p>
<p>共同实现 DNS 分布式数据库的所有 DNS 服务器存储了<strong>资源记录</strong>（Resource Record, RR)。每个 DNS 回答报文包含了一个条或多条资源记录。</p>
<p>RR 的格式：(Name, Value, Type, TTL)。TTL 表示记录的生存时间，Name 和 Value 的值取决于 Type：</p>
<ul>
<li>Type=A。Name 是主机名，Value 是 IP 地址。</li>
<li>Type=NS。Name 是个域（如：foo.com），Value 是此域的权威 DNS 服务器的主机名。</li>
<li>Type=CNAME。Name 是主机别名，Value 是规范主机名（主机真实名）。</li>
<li>Type=MX。Name 是邮件服务器别名，Value 是邮件服务器规范主机名。</li>
</ul>
<p>注册一个新的域名(如：networkutopia.com)，需要：</p>
<ol>
<li>向注册登记机构提供权威 DNS 服务器的名字和 IP 地址。
<ul>
<li>假如名字和 IP 分别是 dns1.networkutopia.com, 212.212.212.1。</li>
</ul>
</li>
<li>注册登记机构将 NS 和 A 记录输入到 .com TLD 服务器
<ul>
<li>(networkutopia.com, dns1.networkutopia.com, NS)</li>
<li>(dns1.networkutopia.com, 212.212.212.1, A)</li>
</ul>
</li>
</ol>
<h2 id="三-运输层">三 运输层</h2>
<p><em>理解运输层服务背后的原理</em></p>
<p>运输层协议为运行在不同主机上的应用程序进程之间提供了逻辑通信（logic communicating)。</p>
<p>运输层协议是在端系统中实现的。在发送端系统中，运输层将从应用程序进程接收到的报文转换成运输层分组，运输层分组称为<strong>报文段</strong>(segment)。然后，运输层将这些报文段传递给网络层。</p>
<p>因特网为应用程序提供了两种截然不同的可用运输层协议，即：</p>
<ul>
<li><strong>UDP</strong>（用户数据报协议），为调用它的应用程序提供了一种不可靠、无连接的服务。</li>
<li><strong>TCP</strong>（传输控制协议），为调用它的应用程序提供了一种可靠的、面向连接的服务。</li>
</ul>
<p>网络层为主机之间提供了逻辑通信。网络层最著名的协议是网际协议（IP），它是尽力而为交付服务。就是说，IP 尽它“最大的努力”在通信的主机之间交付报文段，但不做任何确保。它不确保报文的交付，不保证报文段的按序交付，不保证报文段中数据完整性。因此，称为 IP 为不可靠服务。</p>
<h3 id="多路复用multiplexing和多路分解demultiplexing">多路复用（Multiplexing）和多路分解（Demultiplexing）</h3>
<p>一个进程有一个或多个套接字（socket），每个套接字都有唯一的标识符，它相当于从网络向进程传递数据和从进程向网络传递数据的一扇门。在接收主机中的运输层实际上并没有直接将数据交付给进程，而是将数据交给了一个中间的套接字。</p>
<p>将运输层报文段中的数据交付到正确的套接字的工作称为运输层的<strong>多路分解</strong>（demultiplexing）。从主机上不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，再将报文段传递到网络层的工作称为运输层的<strong>多路复用</strong>（multiplexing）。</p>
<p><img src="/images/transport-layer-multiplexing-and-demultiplexing.jpg" alt="运输层的多路复用与多路分解"></p>
<p>如图，多路分解是一台接收主机会收到多个地方（多路，如: p3 和 p4）传送过来的报文段，这些报文段到达运输层后，运输层通过查看它们的报文段首部从而将数据交到（分解）对应的套接字（如：p3 到 p1, p4 到 p2)。多路复用是一台发送主机会向多个地方（多路，如：p3 和 p4）发送数据，这些数据经套接字到达运输层后，运输层对它们进行封装生成报文段，并传送到网络层。</p>
<p>一个 UDP 套接字是由一个二元组来标识的，该二元组包含一个目的 IP 地址和一个目的端口号。如果两个 UDP 报文段有不同的源 IP 地址和/或源端口号，但具有相同的目的 IP 地址和目的端口号，那么两个报文段将通过相同的目的套接字定向到同一个目的进程。</p>
<p>TCP 套接字是由一个四元组（源 IP 地址，源端口号，目的 IP 地址，目的端口号）来标识的。当一个 TCP 报文段从网络到达一台主机时，该主机的运输层使用全部 4 个值来将报文段定向（分解）到相应的套接字。两个具有不同源 IP 地址或源端口号的 TCP 报文段将被定向到两个不同的套接字。</p>
<h3 id="udp-协议">UDP 协议</h3>
<p>UDP 在 [RFC 768] 中定义，它是做了运输协议能够做的最少工作，除了复用/分解功能及少量的差错检测外，它几乎没有对 IP 增加别的东西。</p>
<ul>
<li>UDP 是无连接的，发送端和接收端之间不需要握手，即可进行数据传输。</li>
<li>UDP 报文段可能会丢失，送达的报文段也可能是无序的。</li>
</ul>
<p>UDP 一般用在：</p>
<ul>
<li>DNS</li>
<li>流媒体</li>
<li>SNMP</li>
</ul>
<p>UDP 报文结构，如下：</p>
<figure><img src="/images/udp-segment-structure.jpg"
         alt="UDP 报文段结构"/><figcaption>
            <p>UDP 报文段结构</p>
        </figcaption>
</figure>

<p>UDP 首部只有 4 个字段，每个字段占 2 个字节。长度（Length）字段指明了 UDP 报文段的字节数（首部+数据）。校验和（Checksum）字段用于检查报文段中是否出现了差错（例如，由于链路中的噪声干扰或者存储在路由器中时引入的问题，某个或某些 bit 是否发生了改变）。</p>
<p>校验和字段值的一种计算方式：对报文段中所有 16 比特字的和进行反码运算，求和时遇到的任何溢出都被回卷。</p>
<p><img src="/images/checksum-example.jpg" alt=""></p>
<p>这种方式计算出来的校验和是一种弱保护校验和，如图，在发生位翻转时，校验和没有改变。</p>
<h3 id="可靠数据传输原理">可靠数据传输原理</h3>
<p>可靠数据传输为上层提供的服务的抽象是：数据可以通过一条可靠的信道进行传输。</p>
<p>可靠数据传输协议的复杂性取决于不可靠通道的特征（分组丢失、损坏、重新排序数据）。</p>
<ul>
<li>发送者和接收者不知道彼此的状态，例如，是否收到消息？</li>
<li>除非，通过消息传达。</li>
</ul>
<p>用有限状态机（Finite-State Machine，FSM）来定义发送者和接收者。</p>
<p><img src="/images/finite-state-machine.jpg" alt=""></p>
<p>FSM 描述图中的箭头指示了协议从一个状态转换到另一个状态。引起转换的<strong>事件</strong>显示在表示转换的横线上方，事件发生时所采取的<strong>动作</strong>显示在横线下方。</p>
<blockquote>
<p>rdt 表示可靠数据传输协议（<strong>r</strong>eliable <strong>d</strong>ata <strong>t</strong>ransfer protocol）。udt 表示不可靠数据传输（<strong>u</strong>nreliable <strong>d</strong>ata <strong>t</strong>ransfer）。pkt 表示分组（packet）。</p>
</blockquote>
<p><strong>1. rdt1.0：经完全可靠信道的可靠数据传输</strong></p>
<ul>
<li>底层信道是完全可靠的
<ul>
<li>没有位错误</li>
<li>分组不会丢失</li>
</ul>
</li>
<li>发送方和接收方有各自的 FSM
<ul>
<li>发送方将数据发送到底层信道</li>
<li>接收方从底层信道读取数据</li>
</ul>
</li>
</ul>
<figure><img src="/images/rdt1.0-a.jpg"
         alt="rdt1.0 的 FSM"/><figcaption>
            <p>rdt1.0 的 FSM</p>
        </figcaption>
</figure>

<p>发送方和接收方的 FSM 都只有一个状态。FSM 的初始状态用虚线表示。</p>
<p>在发送方，rdt 只通过 rdt_send(data) 事件接受来自较高层的数据，产生一个包含该数据的分组（经由 make_pkt(data)动作)，并将分组发送到信道。</p>
<p>在接收方，rdt 通过 rdt_rcv(packet) 事件从底层信道接收一个分组，从分组中取出数据（经由 extract(packet, data)动作），并将数据上传给较高层（通过 deliver_data(data)动作)。</p>
<p>这个简单的协议，所有的分组是从发送方流向接收方；有了完成可靠的底层信道，接收方不需要提供任何反馈信息给发送方，因为不必担心出现差错。</p>
<p><strong>2. rdt2.0: 经具有比特差错信道的可靠数据传输</strong></p>
<p>底层信道更为实际的模型是分组中的比特可能受损。在分组的传输、传播或缓存过程中，这种比特差错通常会出现在网络的物理部件中。</p>
<p>协议要处理存在比特差错的情况，需要增加三种功能：</p>
<ul>
<li>差错检测。需要一种机制使得接收方能够检测到何时出现了比特差错。例如，校验和。</li>
<li>接收方反馈。接收方要明确告诉发送方已接收分组（ACK）或分组出现差错（NAK）。</li>
<li>重传。接收方收到有差错的分组时，发送方将重传该分组。</li>
</ul>
<figure><img src="/images/rdt2.0-a.jpg"
         alt="rdt2.0 的 FSM"/><figcaption>
            <p>rdt2.0 的 FSM</p>
        </figcaption>
</figure>

<p>如图，rdt2.0 的发送方有了两个状态，在左边的状态中，发送方协议正等待来自上层传下来的数据。</p>
<ul>
<li>当产生 rdt_send(data) 事件时，发送方将产生一个包含待发送数据的分组（sndpkt），带有校验和。</li>
<li>然后，经由 udt_send(sndpkt) 操作发送该分组。</li>
</ul>
<p>在右边的状态中，发送方协议等待来自接收方的 ACK 或 NAK 分组。</p>
<ul>
<li>如果收到一个 ACK 分组（rdt_cv(rcvpkt) &amp;&amp; isACK(rcvpkt) 对应该事件），则发送方知道最近发送的分组已经被正确接收，因此协议返回到等待来自上层的数据状态。</li>
<li>如果收到一个 NAK 分组，该协议重传最后一个分组并等待接收方为响应重传分组而回送的 ACK 和 NAK。</li>
</ul>
<p>rdt2.0 接收方的 FSM 仍然只有一个状态。当分组到达时，要么回答一个 ACK，要么回答一个 NAK，取决于收到的分组是否受损。rdt_rcv(rcvpkt) &amp;&amp; corrupt(rcvpkt) 对应于收到一个分组并发现有错的事件。</p>
<blockquote>
<p>rdt2.0 这样的协议称为停等协议（stop-and-wait)，发送者发送一个分组，然后等待接收者的响应。</p>
</blockquote>
<p>rdt2.0 存在的一个致命缺陷是：没有考虑 ACK/NAK 受损该怎么处理。</p>
<ul>
<li>发送者不知道接收者发生了什么。接收者也不知道所发送的 ACK/NAK 是否被发送方正确接收。</li>
<li>重传，可能会出现分组重复（接收者不知道接收到的分组是新的，还是一次重传）。</li>
</ul>
<p>解决分组重复问题的方法：</p>
<ul>
<li>发送方为每个分组增加一个序号。</li>
<li>接收方丢弃（不交付）重复的分组。</li>
</ul>
<p>有了分组序号后，如果在收到受损的分组，接收方可以不再发送 NAK，而是对上次正确接收到的分组发送一个 ACK。发送方接收到对同一个分组的两个 ACK 后，就知道接收方没有正确接收到跟在被确认两次的分组后面的分组。</p>
<figure><img src="/images/rdt2.2-a.jpg"
         alt="改进版的 FSM"/><figcaption>
            <p>改进版的 FSM</p>
        </figcaption>
</figure>

<p>接收方的 make_pkt() 包含了参数 ACK 0 或 ACK 1。发送方的 isAck() 中包含了参数 0 或 1。</p>
<p><strong>3. rdt3.0: 经具有比特差错的丢包信道可靠数据传输</strong></p>
<p>除了比特受损外，底层通道还会丢包。因此，协议必须处理另外两个问题：</p>
<ul>
<li>怎样检查丢包？</li>
<li>发生丢包后该做些什么？</li>
</ul>
<p>解决方法是：发送方传输一个分组后等待一个 &ldquo;合理&rdquo; 的时间，在这个时间之后还没有收到接收方的响应（无论是分组丢失，还是 ACK 丢失，或者只是该分组或 ACK 过度延时），它都认为是分组已丢失，就重传该分组。</p>
<p>为了实现基于时间的重传机制，需要一个<strong>倒计数定时器</strong>（countdown timer），在一个 &ldquo;合理&rdquo; 的时间后，可中断发送方。对此，发送方要做到：1）每次发送一个分组（包括第一次分组和重传分组）时，就启动一个定时器。2）响应定时器中断（采取适当的动作）。3）终止定时器。</p>
<figure><img src="/images/rdt3.0-a.jpg"
         alt="rdt3.0 发送方的 FSM"/><figcaption>
            <p>rdt3.0 发送方的 FSM</p>
        </figcaption>
</figure>

<blockquote>
<p>归纳，一个可靠数据传输协议的技术要点：</p>
<ul>
<li>校验和</li>
<li>序号</li>
<li>定时器</li>
<li>ACK</li>
</ul>
</blockquote>
<h3 id="流水线可靠数据传输协议">流水线可靠数据传输协议</h3>
<p>rdt 这种停等协议（发送一个分组后就停下来，等收到接收方的响应后再发送下一个分组）最大的问题是性能。</p>
<p>例如，在发送速率为 1Gbps 的链路上，发送方发送一个1000字节（8000比特）的分组只要 0.008ms，但等到接收方的确认后才发送下一个分组，假设 RTT 时间为 30ms，那么发送方的利用率就只有 <code>0.008/(30+0.008)=0.00027</code>，很明显，这个网络协议限制了物理资源的利用。</p>
<p>流水线技术，允许发送方发送多个分组而不需要等待确认，提高了发送方的利用率，对可靠数据传输协议带来的影响是：</p>
<ul>
<li>必须增加<code>序号</code>的范围。每个传输中的分组必须有一个唯一的序号，而且也许有多个在传输中未确认的分组。</li>
<li>必须<code>缓存</code>多个分组。发送方最低限度应当能缓存那些已发送但没有确认的分组，接收方或许也需要缓存那些已正确接收的分组。</li>
<li>所需要的序号范围和对缓存的要求，取决于数据传输协议如何处理丢失、损坏及延时过大的分组。解决流水线的差错恢复有两种基本方法：<strong>回退 N 步</strong>（Go-Back-N，GBN）和<strong>选择重传</strong>（Selective Repeat, SR）。</li>
</ul>
<p><strong>1. 回退 N 步</strong></p>
<ul>
<li>发送方在流水线中最大允许 N 个未确认的分组。N 称为窗口长度。
<ul>
<li>当收到分组序号为 n 的 ACK 后，发送方将窗口滑动到 n + 1 开始。</li>
</ul>
</li>
<li>接收方只发送累计 ACK（cumulative ack）。
<ul>
<li>如果分组失序就丢弃，不发送 ACK。</li>
</ul>
</li>
<li>发送方仅使用一个定时器，这个定时器可以当作是最早发送但未被确认的分组所使用的定时器。
<ul>
<li>当定时器过期时，重传所有未确认的分组。</li>
</ul>
</li>
</ul>
<figure><img src="/images/gbn-sender-sequence-a.jpg"
         alt="在 GBN 中发送方看到的序号空间"/><figcaption>
            <p>在 GBN 中发送方看到的序号空间</p>
        </figcaption>
</figure>

<p>如图，基序号(base）为最早的未确认分组的序号，下一个序号（nextseqnum）为最小的未使用序号（即下一个待发送分组的序号）。GBN 协议的序号范围分割成 4 段：</p>
<ul>
<li>[0, base-1] 段内的序号对应于已经发送并被确认的分组。</li>
<li>[base, nextseqnum - 1] 段内的序号对应已经发送但还未被确认的分组。</li>
<li>[nextseqnum, base + N - 1] 段内的序号用于那些要被立即发送的分组，如果有数据来自上层的话。</li>
<li>大于或等于 base + N 的序号不能使用，直到当前流水线中的未确认的分组（特别是序号为 base 的分组）已得到确认为止。（窗口滑动）</li>
</ul>
<blockquote>
<p>一个分组的序号存储在分组首部的一个固定的字段中。如果分组序号字段的比特数是 <em>k</em>，则该序号范围是[0, 2^k - 1]。在一个有限的序号范围内，所有涉及序号的运算必须使用模 2^k 运算。（即序号空间可被看作是一个长度为 2^k 的环，其中序号 2^k - 1 紧接着序号 0）。</p>
</blockquote>
<figure><img src="/images/gbn-sender-fsm.jpg"
         alt="GBN 发送方的 FSM 描述"/><figcaption>
            <p>GBN 发送方的 FSM 描述</p>
        </figcaption>
</figure>

<p>GBN 发送方的动作：</p>
<ul>
<li>上层调用事件发生。发送方首先检查发送窗口是否已满，即是否有 <em>N</em> 个已发送但未被确认的分组。如果窗口未满，则产生一个分组并发送给下层。如果窗口已满，则将数据缓存。</li>
<li>收到一个 ACK 事件发生。收到 ACK(n)，即表明接收方已正确接收序号为 n 和 n 之前的所有分组。</li>
<li>超时事件发生。发送方仅使用一个定时器，如果出现超时，重传所有已发送但未被确认的分组。</li>
</ul>
<figure><img src="/images/gbn-receiver-fsm.jpg"
         alt="GBN 接收方的 FSM 描述"/><figcaption>
            <p>GBN 接收方的 FSM 描述</p>
        </figcaption>
</figure>

<p>GBN 接收方的动作：</p>
<ul>
<li>如果一个序号为 n 的分组被正确接收到，并且按序（即上次交付给上层的数据是序号 n - 1 的分组），则接收方为分组 n 发送一个 ACK，并将分组中的数据交付给上层。</li>
<li>其他所有情况，接收方都会丢弃该分组，并为最近按序接收的分组重新发送 ACK。</li>
</ul>
<p><strong>2. 选择重传</strong></p>
<p>单个分组的差错能够引起 GBN 重传大量的分组，SR 让发送方仅重传那些它怀疑在接收方出错（即丢失或受损）的分组，从而避免不必要的重传。</p>
<ul>
<li>发送方在流水线中最大允许 N 个未确认的分组。</li>
<li>接收方逐个地确认正确接收的分组（逐个发送 ACK），不管分组是否按序。</li>
<li>发送方为每个未确认的分组维护一个定时器。</li>
</ul>
<figure><img src="/images/sr-sequence.jpg"
         alt="选择重传 (SR) 发送方和接收方的序号空间"/><figcaption>
            <p>选择重传 (SR) 发送方和接收方的序号空间</p>
        </figcaption>
</figure>

<p>SR 发送方的动作：</p>
<ul>
<li>从上层收到数据。如果下一个序号在窗口内可用，则打包数据并发送。</li>
<li>超时。每个分组拥有自己的定时器，一旦超时就重传分组，并重新启动定时器。</li>
<li>收到 ACK。如果收到 ACK，倘若该分组序号在窗口内，则 SR 发送方将那个被确认的分组标记为已接收。如果该分组的序号等于 send_base，则窗口基序号向前移动到具有最小序号的未确认分组处。如果窗口移动了并且有序号落在窗口内的未发送分组，则发送这些分组。</li>
</ul>
<p>SR 接收方的动作：</p>
<ul>
<li>序号在 [rcv_base，rcv_base + <em>N</em> - 1] 内的分组被正确接收。
<ul>
<li>发送 ACK(n) 给发送方。</li>
<li>如果该分组以前没收到过，则缓存该分组。</li>
<li>如果该分组的序号等于接收窗口的基序号（rcv_base），则该分组以及以前缓存的序号连续的（起始于 rcv_base 的）分组交付给上层。然后，接收窗口按向前移动分组的编号向上交付这些分组。</li>
</ul>
</li>
<li>序号在 [rcv_base - <em>N</em>，rcv_base - 1] 内的分组被正确接收。
<ul>
<li>发送 ACK(n) 给发送方。 即使该分组是接收方以前已确认过的分组。</li>
</ul>
</li>
<li>其他情况。
<ul>
<li>忽略该分组</li>
</ul>
</li>
</ul>
<h3 id="tcp-协议">TCP 协议</h3>
<p>TCP 是因特网运输层的面向连接的可靠的运输协议。它的特点：</p>
<ul>
<li>总是点对点的。单个发送者与单个接收者连接。</li>
<li>可靠的，有序的字节流。没有“消息边界”。</li>
<li>全双工的。
<ul>
<li>在同一个连接上数据可以双向流动。</li>
<li>数据大小受限于最大报文段长度（Maximum Segment Size, MSS）。通常 MSS 是 1460 字节。</li>
</ul>
</li>
<li>提供累计确认。</li>
<li>使用流水线传输。窗口大小是由 TCP 拥塞控制和流量控制决定的。</li>
<li>面向连接的。数据交换之前要握手（交换控制信息），初始化发送方和接收方的状态。</li>
<li>数据流量是可控的。发送方不会压垮接收方。</li>
</ul>
<blockquote>
<p>TCP 协议只在端系统中运行，其连接状态完全保留在两个端系统中。</p>
</blockquote>
<p>TCP 报文段结构：</p>
<p><img src="/images/tcp-segment-structure.jpg" alt="TCP 报文段结构"></p>
<p>报文段由首部字段和一个数据字段（application data）组成。数据字段包含一块应用数据，其大小是可变的。首部字段包含源端口号和目的端口号，它们各占 16 位。还包含了：</p>
<ul>
<li>32 位的序号字段（sequence number）和 32 位的确认号字段（acknowledgment number）。</li>
<li>16 位的接收窗口字段（receive window）。用于流量控制。</li>
<li>4 位的首部长度字段（header length）。</li>
<li>可选与变长的选项字段（option）。</li>
<li>6 位的标志字段（flag）。
<ul>
<li>ACK 位指示确认字段中的值是有效的，即该报文段包含一个对已被成功接收报文段的确认。</li>
<li>RST、SYN 和 FIN 位用于连接建立和拆除。</li>
<li>PSH 位指示接收方立即将数据交给上层。</li>
<li>URG 位指示报文段里存在“紧急”的数据。</li>
</ul>
</li>
<li>16 位的紧急数据指针字段。（其中，PSH、URG 位和紧急数据指针在实践中没有使用）</li>
</ul>
<h4 id="tcp-序号和确认号">TCP 序号和确认号</h4>
<p>序号和确认号字段是 TCP 可靠传输的关键部分。</p>
<p>TCP 把数据看成一个无结构的、有序的字节流。序号是建立在传送的字节流上，而<em>不是</em>建立在传送的报文段的序列之上。</p>
<blockquote>
<p>一个报文段的序号（sequence number for a segment）就是该报文段第一个字节的字节流编号。</p>
</blockquote>
<p><img src="/images/dividing-file-data-into-tcp-segments.jpg" alt=""></p>
<p>假设主机 A 上的一个进程通过一个 TCP 连接向主机 B 上的一个进程发送一个数据流。主机 A 中的 TCP 将隐式地对数据流中的每个字节编号。假定数据流由一个包含 500,000 字节的文件组成，其 MSS 为 1000 字节，数据流的第一个字节编号为 0。如上图，TCP 将为该数据流构建 500 个报文段，第一个报文段的序号为 0（第一个字节的编号是 0），第二个报文段的序号为 1000（第一个字节的编号是 1000），第三个报文段的序号为 2000（第一个字节的编号是 2000），以此类推。每一个序号被填入到相应 TCP 报文段首部的序号字段中。</p>
<blockquote>
<p>确认号是期望从另一端收到的下一个字节的序号。</p>
</blockquote>
<p>确认号用来告诉对方应该传送哪个数据。假设 A 主机已收到了一个 B 主机的包含字节 0 ～ 535 的报文段，以及另一个包含字节 900 ～ 1000 的报文段。由于某种原因，主机 A 还没有收到字节 536 ~ 899 的报文。A 在发往 B 的下一个报文段中的确认字段的值将设为 536。因为 TCP 只确认该流中第一个丢失的字节之前的字节，所以 TCP 被称为提供累计确认（cumulativ acknowledgment）。</p>
<figure><img src="/images/tcp-sequence-number-and-acks.jpg"
         alt="TCP 序号和确认号"/><figcaption>
            <p>TCP 序号和确认号</p>
        </figcaption>
</figure>

<p>对于报文段失序到达，TCP RFC 没有明确规处理规则，而是留给了 TCP 的实现者。有两种基本的选择：</p>
<ol>
<li>接收方立即丢弃失序报文段</li>
<li>接收方保留失序的字节，并等待缺少的字节以填补该间隔。（实践中，采用的方法）</li>
</ol>
<p>初始序号，并不一定是从 0 开始，TCP 连接的双方都可以随机的选择。</p>
<h4 id="tcp-提供的可靠数据传输服务">TCP 提供的可靠数据传输服务</h4>
<p>TCP 在 IP 不可靠的尽力而为服务之上创建了一种可靠数据传输服务（reliable data transfer service）。</p>
<ul>
<li>流水线传输报文段</li>
<li>累计确认</li>
<li>单一的重传定时器</li>
</ul>
<p>TCP 发送方响应 3 个与发送和重传有关的主要事件：</p>
<ul>
<li>从上层应用程序接收数据
<ul>
<li>一旦事件发生，TCP 从应用程序接收数据，将数据封装在一个报文段中，并把该报文段交给 IP 层。</li>
<li>报文段的第一个数据字节的字节流编号是这个报文段的序号。</li>
<li>如果定时器没有运行，则当报文段被传给 IP 时，TCP 就启动该定时器。
<ul>
<li>该定时器的过期间隔是 TimeoutInterval。</li>
</ul>
</li>
</ul>
</li>
<li>超时
<ul>
<li>重传引起超时的报文段</li>
<li>重启定时器（定时器的超时间隔不再是 TimeoutInterval，而是先前的两倍）</li>
</ul>
</li>
<li>收到接收方的确认报文段（ACK）
<ul>
<li>如果这个 ACK 确认了一个或多个先前未确认的报文段
<ul>
<li>发送方更新它的 SendBase 变量。（滑动窗口）</li>
<li>如果还有未确认的报文段，就启动定时器。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如果发送方收到相同数据的 3 个冗余 ACK（之前已经收到过 1 个，现在又收到 3 个，也就是 4 次 ACK），说明在这个已被确认的报文段之后可能有 3 个报文段已经丢失。因此，TCP 执行快速重传（fast retransmit），即重传最早未被确认的报文段，不用等到超时事件发生。</p>
<h4 id="tcp-提供的流量控制服务">TCP 提供的流量控制服务</h4>
<p>TCP 连接的每一个端都有自己的发送缓存和接收缓存。TCP 连接收到正确、按序的字节后，它就将数据放入接收缓存。如果网络层送达数据的速度超过了应用层从接收缓存中读取数据的速度，接收缓存就可能会溢出。对此，TCP 提供了流量控制服务（flow-control service）来消除这种速率不匹配引起的缓存溢出。</p>
<ul>
<li>TCP 让发送方维护一个接收窗口（receive window）变量。这个变量告诉发送方，接收方还有多少可用的缓存空间。TCP 是全双工通信，在连接两端的发送方都各自维护了一个接收窗口。</li>
</ul>
<figure><img src="/images/tcp-receiver-side-buffer.jpg"
         alt="接收窗口（rwnd）和接收缓存（RcvBuffer）"/><figcaption>
            <p>接收窗口（rwnd）和接收缓存（RcvBuffer）</p>
        </figcaption>
</figure>

<ul>
<li>TCP 接收方通过 TCP 首部字段 rwnd 告诉发送方它的接收缓存还有多少可用空间。</li>
<li>发送方控制未确认的数据量在值 rwnd 以内，以保证不会使接收方的接收缓存溢出。</li>
<li>当接收方的接收窗口为 0 时，发送方还会继续发送<strong>只有一个字节数据的报文段</strong>。目的是在接收方释放出缓存空间后，能通过确认此报文通知发送方继续发送报文段。</li>
</ul>
<h4 id="tcp-连接管理">TCP 连接管理</h4>
<p>交换数据之前，发送方（客户端）和接收方（服务器端）要先“握手”：</p>
<ul>
<li>同意建立连接，双方都要知道对方愿意建立连接。</li>
<li>同意连接参数（eg: 初始序号）</li>
</ul>
<figure><img src="/images/tcp-3-way-handshake.jpg"
         alt="TCP 三次握手：报文段交换"/><figcaption>
            <p>TCP 三次握手：报文段交换</p>
        </figcaption>
</figure>

<figure><img src="/images/tcp-3-way-handshake-fsm.jpg"
         alt="TCP 三次握手的 FSM 描述"/><figcaption>
            <p>TCP 三次握手的 FSM 描述</p>
        </figcaption>
</figure>

<p>TCP 建立连接的 3 次握手：</p>
<ul>
<li>第一步：客户端的 TCP 向服务器端的 TCP 发送一个 SYN 报文段。
<ul>
<li>报文段不包含应用层数据。</li>
<li>首部中的 SYN 标志位置为 1。</li>
<li>随机选择一个初始序号（client_isn），放置在首部序号字段中。</li>
</ul>
</li>
<li>第二步：服务器端根据收到的 TCP SYN 报文段，为此次的 TCP 连接分配 TCP 缓存和变量，并向客户端的 TCP 发送一个允许连接的 SYNACK 报文段。
<ul>
<li>报文段也不包含应用层数据。</li>
<li>首部中的 SYN 标志位置为 1，ACK 标志位置为 1。</li>
<li>确认号字段的值置为 client_isn + 1。</li>
<li>随机选择一个初始序号（server_isn），放置在首部序号字段中。</li>
</ul>
</li>
<li>第三步：客户端收到 TCP SYNACK 报文段，也给此次的 TCP 的连接分配缓存和变量，并向服务器端的 TCP 发送一个确认报文段，完成连接建立。
<ul>
<li>报文段的首部中的 ACK 标志位置为 1，确认字段置为 server_isn + 1。表示确认了服务器的 SYNACK 报文段。</li>
<li>报文段中可以携带应用层数据。</li>
</ul>
</li>
</ul>
<hr>
<p>数据交换完成后，连接可能就不需要了，这时，发送方和接收方的任何一方都能选择终止连接。</p>
<figure><img src="/images/tcp-closing-a-connection.jpg"
         alt="关闭一条 TCP 连接"/><figcaption>
            <p>关闭一条 TCP 连接</p>
        </figcaption>
</figure>

<p>TCP 连接关闭（假设客户端应用程序决定要关闭连接）：</p>
<ul>
<li>客户 TCP 向服务器 TCP 发送一个终止连接的报文段，其首部中的 FIN 标志位为 1。</li>
<li>服务器 TCP 收到这个特殊报文段后，向客户 TCP 回送一个确认报文段。</li>
<li>然后，服务器 TCP 向客户 TCP 发送自己的终止连接的报文段，其首部的 FIN 标志位置为 1。</li>
<li>最后，客户 TCP 对服务器 TCP 的终止报文进行确认，连接关闭。</li>
</ul>
<p>关闭连接过程中，客户 TCP 状态的变化：</p>
<ul>
<li>客户 TCP 向服务器 TCP 发送一个带有 FIN 标志位为 1 的 TCP 报文段
<ul>
<li>进入 FIN_WAIT_1 状态，等待服务器的确认报文段。</li>
<li>可以接收数据但不能发送数据。</li>
</ul>
</li>
<li>客户 TCP 收到服务端的确认报文段
<ul>
<li>进入 FIN_WAI_2 状态，等待服务器关闭连接的报文段（即 FIN 标志位置为 1 的报文段）。</li>
</ul>
</li>
<li>客户收到服务器关闭连接的报文段
<ul>
<li>确认报文，并进入 TIME_WAIT 状态。</li>
<li>等待一段时间，连接正式关闭。</li>
</ul>
</li>
</ul>
<blockquote>
<p>当连接终止后，两台主机上用于该连接的所有“资源”（即缓存和变量）都将被释放了。</p>
</blockquote>
<h4 id="拥塞控制原理">拥塞控制原理</h4>
<p>拥塞是指网络拥塞，就是太多的分组发送到网络（路由器）上，而且传输速率太快，以至于网络（路由器）无法处理。</p>
<p>出现网络拥塞后的表现：</p>
<ul>
<li>长时间的延迟（分组在路由器缓存中排队）。</li>
<li>丢包（路由器缓存溢出了）。</li>
</ul>
<p>拥塞的情况及其代价：</p>
<ul>
<li>情况一：当分组的到达速率接近链路容量（传输速率）时，分组将会在路由器中经历巨大的排队时延。</li>
<li>情况二：发送方在分组延迟到达时会重传分组（超时/重传机制），这就使得路由器要利用其链路带宽来转发不必要的分组副本（重传的分组）。</li>
<li>情况三：在多跳路由路径的情况下，当分组被丢弃时，任何用于该分组的上游路由器的传输能力和缓存都被浪费了。例如，分组途径一、二跳路由器后，在第三跳路由器上由于拥塞而被丢弃了，那么一、二跳路由器的传输容量和缓存实际就是浪费掉了。</li>
</ul>
<p>拥塞控制的两种方式：</p>
<ol>
<li>端到端的拥塞控制
<ul>
<li>网络层没有为运输层拥塞控制机制提供显式的支持。</li>
<li>端系统必须通过观察网络行为（如分组丢包与时延）来推断网络是否存在拥塞。</li>
<li>TCP 是采用这种方式。</li>
</ul>
</li>
<li>网络辅助的拥塞控制
<ul>
<li>路由器向发送方提供了关于网络中拥塞状态的显式反馈。</li>
</ul>
</li>
</ol>
<h4 id="tcp-拥塞控制">TCP 拥塞控制</h4>
<p>TCP 拥塞控制常被称为加性增、乘性减（Additive-Increase, Multiplicative-Decrease, AIMD）拥塞控制。</p>
<ul>
<li>所采用的方法：当发送方检测到拥塞时（丢包事件出现），就降低发送速率，否则就增加发送速率。
<ul>
<li>加性增：在检测到丢包之前，发送速率每个 RTT (往返时间）增加 1 个 MSS。</li>
<li>乘性减：每次丢包事件出现，发送速率减半。</li>
</ul>
</li>
</ul>
<p>TCP 拥塞控制跟踪一个变量，即拥塞窗口（congestion window），表示为 cwnd。它对一个 TCP 发送方能向网络中发送流量的速率进行了限制。在一个发送方中未被确认的数据量不会超过 cwnd（拥塞窗口） 与 rwnd（接收窗口）中的最小值，即：</p>
<figure><img src="/images/tcp-cwnd.jpg"/>
</figure>

<pre tabindex="0"><code>LastByteSent - LastByteAcked &lt;= min {cwnd, rwnd}
</code></pre><p>TCP 拥塞控制算法，包含 3 个主要部分：</p>
<ol>
<li>慢启动。初始速率较慢，但呈指数增长，其目的就是尽快找到上限。
<ul>
<li>cwnd 的初始大小为 1 MSS，每当收到一个新的确认（收到 ACK）就增加 1 个 MSS。
<ul>
<li>初始 cwnd = 1MSS，可以发送一个 MSS 的数据，成功确认后，cwnd = 2MSS；</li>
<li>此时可以发送两个 MSS 大小的数据了，都成功确认后，cwnd = 4MSS；</li>
<li>此时可以发送四个 MSS 大小的数据了，都成功确认后，cwnd = 8MSS；</li>
<li>这样下去，每过一个 RTT（往返时间），发送速率（cwnd 的值）就翻倍，呈指数增长。（<strong>由于 TCP 是一次性将窗口内的所有报文段发出，所以所有报文段都到达并被确认的时间，近似的等于一个 RTT</strong>）。
<img src="/images/tcp-slow-start.jpg" alt="TCP 慢启动"></li>
</ul>
</li>
<li>何时改变慢启动的这种指数增长呢，有几种方式：
<ul>
<li>第一种：在慢启动的过程中，发生了数据传输超时引起的丢包事件（即拥塞），此时 TCP 发送方将 cwnd 设置 1 MSS 并重新开始慢启动过程，还将状态变量的值 ssthresh（慢启动阀值）设置为 cwnd/2，即当检测到拥塞时将 ssthresh 设为 cwnd 值的一半。这个过程可以理解为试探 ssthresh 的上限。</li>
<li>第二种：直接与 ssthresh 的值相关联，因为在第一种方式下，sshthresh 的值已经设为 cwnd 的值一半，若 cwnd 的值在增加到 &gt;= ssthresh 时，还继续使 cwnd 翻番可能有些鲁莽。因此，在 cwnd 的值 = ssthresh 时，结束慢启动并转移到拥塞避免模式。</li>
<li>第三种：如果检查到 3 个冗余 ACK（<strong>出现超时和收到接收方的 3 个 ACK 都认为是出现丢包事件，即拥塞</strong>），这时 TCP 执行快速重传并转移到快速恢复状态；同时，ssthresh = cwnd / 2，cwnd = ssthresh + 3MSS；</li>
</ul>
</li>
</ul>
</li>
<li>拥塞避免。速率缓慢，线性增长。
<ul>
<li>每过一个 RTT，只将 cwnd 的值增加 1 个 MSS
<ul>
<li>TCP 发送方无论何时收到一个新的确认，就将 cwnd 增加 MSS * (MSS/cwnd) 字节。</li>
<li>假设 MSS 是 1460 字节并且 cwnd 是 14600 字节（也就是 10 个 MSS），则在一个 RTT 内发送 10 个报文段（TCP 是一次性将窗口内的所有报文段发出）。每接收到一个报文段的 ACK，cwnd 增加 1/10 MSS。</li>
</ul>
</li>
<li>何时结束这种线性增长呢，分为两种情况：
<ul>
<li>第一种：与慢启动一样，出现超时时，cwnd 的值被设为 1 MSS，ssthresh 更新为 cwnd/2，并转移到慢启动状态。</li>
<li>第二种：接收到 3 个冗余 ACK 时，将 ssthresh 的值改为 cwnd/2， cwnd 的值设为 sshthresh + 3MSS，并转移到快速恢复状态。</li>
</ul>
</li>
</ul>
</li>
<li>快速恢复。慢启动和拥塞控制是 TCP 强制要实现的，而快速恢复只是推荐实现，并非是必需的。
<ul>
<li>在快速恢复中，每收到一个冗余的 ACK，cwnd 的值增加一个 MSS，其余不变。</li>
<li>若收到丢失报文段的一个 ACK（不是冗余 ACK）时，则 cwnd 被置为 ssthresh，然后转移到拥塞避免模式。</li>
<li>如果出现超时事件，ssthresh 的值将被修改为 cwnd / 2，cwnd 被置为 1 MSS，并转移到慢启动状态。</li>
</ul>
</li>
</ol>
<p>TCP 拥塞控制的 FSM 描述:</p>
<p><img src="/images/tcp-congestion-control-fsm.jpg" alt="TCP 拥塞控制的 FSM 描述"></p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/networking">networking</a></li>
					
				</ul>
			</nav>
			
			
		</div>
	</article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/x-29" title="GitHub"><i data-feather="github"></i></a><a class="soc" href="https://twiiter.com/x-29/" title="Twitter"><i data-feather="twitter"></i></a><a class="soc" href="https://gitlab.com/x-29/" title="GitLab"><i data-feather="gitlab"></i></a></div>
  <div class="footer-info">
    2022  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>


<script>
  feather.replace()
</script></div>
    </body>
</html>
