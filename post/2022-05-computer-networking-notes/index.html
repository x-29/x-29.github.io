<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>计算机网络(Computer Networking)笔记 - CS里的X-29</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="计算机网络(Computer Networking: A Top-Down Approach)学习笔记." />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="计算机网络(Computer Networking)笔记" />
<meta property="og:description" content="计算机网络(Computer Networking: A Top-Down Approach)学习笔记." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://x-29.github.io/post/2022-05-computer-networking-notes/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-05-23T23:56:18+08:00" />
<meta property="article:modified_time" content="2022-05-23T23:56:18+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="计算机网络(Computer Networking)笔记"/>
<meta name="twitter:description" content="计算机网络(Computer Networking: A Top-Down Approach)学习笔记."/>
<script src="https://x-29.github.io/js/feather.min.js"></script>
	
	
        <link href="https://x-29.github.io/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://x-29.github.io/css/main.40ca3a860425083862b7ebd55447caec5c4384573f0cb098b8d06a91e8dace2e.css" />
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://x-29.github.io/">CS里的X-29</a>
	</div>
	<nav>
		
		<a href="/">首页</a>
		
		<a href="/post">文章</a>
		
		<a href="/about">关于</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">计算机网络(Computer Networking)笔记</h1>
			<div class="meta">Posted on May 23, 2022</div>
		</div>
		

		<section class="body">
			<p>这是<a href="https://book.douban.com/subject/26176870/">《计算机网络自顶向下方法 第6版》</a>一书的读书笔记。</p>
<h2 id="一-计算机网络和因特网">一 计算机网络和因特网</h2>
<p><em>从整体上粗线条地勾画出计算机网络地概貌。</em></p>
<h3 id="因特网">因特网</h3>
<p>因特网是一个世界范围地计算机网络，即它是一个互联了遍及全世界地数以亿计的计算机设备的网络。这些设备包括传统的桌面 PC、Linux 工作站已经现在的智能手机、平板电脑、游戏机、家用电器等，我们称之为<strong>主机</strong>（host）或<strong>端系统</strong>（end system）</p>
<ul>
<li>端系统 (end system) 通过通信链路 (communication link) 和分组交换机（packet switch）连接到一起。通信链路根据物理媒体组成可以分为铜轴电缆、铜线、光纤和无线电频谱。不同的链路以不同的速率传输数据，链路的传输速率以 <code>bit/s</code> 度量（或者 bps）。</li>
<li>一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节。由此形成的信息包称为<strong>分组</strong> (packet）。这些分组通过网络发送到目的端系统。</li>
<li>分组交换机从它的一条<em>入</em>通信链路接收到达的分组，并从它的一条<em>出</em>通信链路转发该分组。交换机主要有两类：<code>路由器（router）</code>和<code>链路层交换机（link-layer switch）</code>。
<ul>
<li>从发送端系统到接收端系统，一个分组（packet）所经历的一系列通信链路和分组交换机称为该网络的<strong>路径</strong>(route 或 path)。</li>
</ul>
</li>
<li>端系统、分组交换机和其他因特网部件都要运行一系列<strong>协议</strong>（protocol），这些协议控制因特网中信息的接收和发送。
<ul>
<li>e.g，TCP，IP，HTTP，Skype，802.11</li>
</ul>
</li>
<li>因特网的标准由 <strong>IETF</strong>（Internet Engineering Task Force）研发。
<ul>
<li>IETF 的标准文档称为 <strong>RFC</strong>（Request For Comment）。</li>
</ul>
</li>
</ul>
<p>因特网也可以被看作为应用程序提供服务的基层设施，应用程序可以是 Web，Email，电子商务等。应用程序只需调用端系统提供的 API，就可通过因特网进行数据传输。</p>
<h3 id="协议">协议</h3>
<p><strong>协议</strong>（protocol）定义了在两个或多个通信实体之间交换的报文<code>格式</code>和<code>次序</code>，以及报文发送和/或接收一条报文或其他事件<code>所采取的动作</code>。</p>
<p>因特网广泛地使用了协议，不同的协议用于完成不同的通信任务。</p>
<h3 id="因特网的部件网络边缘接入网和网络核心">因特网的部件：网络边缘、接入网和网络核心</h3>
<p>端系统也称为主机，位于因特网的边缘。</p>
<ul>
<li>主机被进一步划分为客户端（client）和服务器（server）。客服端通常是桌面 PC、移动 PC和智能手机等；而服务器是更为强大的机器，用于存储和发布 Web 页面、流视频等，如今，通常用于大型数据中心（data center）。</li>
</ul>
<p>接入网是指端系统连接到其边缘路由器（edge router）的物理链路。</p>
<ul>
<li>边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器。</li>
<li>如今，宽带住宅接入技术包括数字用户线（DSL)、电缆、光纤到户（FTTH）；企业（公司、学校）接入最流行的是以太网和 WiFi 两种接入技术，利用局域网（LAN）将端用户连接到边缘路由器；广域无线因特网接入技术采用了 3G/4G。</li>
</ul>
<p>网络核心是由连接因特网端系统的分组交换机和链路构成的网状网络。</p>
<ul>
<li>为了从源端系统向目的端系统发送一个报文，源将长报文划分成较小的数据块，称之为<strong>分组</strong>（packet)。在源和目的之间，每个分组都通过通信链路和分组交换机（packet switch）传送。</li>
<li>分组以等于链路最大传输速率的速度传输通过通信链路。</li>
<li>如果某源端系统或分组交换机经过一条链路发送一个 <em>L</em> bit 的分组，链路的传输速率为 <em>R</em> bit/s，那么传输该分组的时间为 <em>L/R</em> /s。</li>
</ul>
<p>大多数分组交换机在链路的输入端使用<code>存储转发传输</code>（store-and-forward transmission）机制。这意味着交换机必须接收到整个分组，才向输出链路传输。（之前接收到的比特先缓存（即 “存储”）起来，仅当已经接收完了该分组的所有比特后，才开始向出链路传输（即 “转发”）该分组）</p>
<blockquote>
<p>一个端到另一个端的时延 = 2<em>L/R</em>（假设传播时延为 0）。</p>
</blockquote>
<p>每个分组交换机都有多条链路与之相连。对于每条相连的链路，该分组交换机具有一个输出缓存（output buffer）（也称为输出队列，用于存储路由器准备发往那条链路的分组。如果在一段时间内，链路的到达速率（以比特为单位）超过链路的传输速率：</p>
<ul>
<li>分组将会在输出缓存中排队，等待在链路上传输。(排队等待就会出现排队时延）</li>
<li>如果输出缓存填满，分组可能被丢弃（丢失）。</li>
</ul>
<p>每台路由器都有一个<code>转发表</code>，将目的地址（或目的地址的一部分）映射成输出链路。当分组到达路由器时，路由器以目的地址搜索其转发表，找到对应的输出链路，将分组导向该输出链路。端到端选路过程类似于一个不使用地图而喜欢问路的汽车司机，每到一个地点，就打听下一个地点的路线。</p>
<h3 id="时延">时延</h3>
<p>当分组从一个结点（主机或路由器）沿着一条路径到达后继结点（主机或路由器），该分组在沿途的每个结点将会经受几种不同类型的时延：</p>
<p><img src="/images/img_202.jpg" alt="结点时延"></p>
<ul>
<li>结点处理时延（nodal processing delay）
<ul>
<li>检查比特级别的差错</li>
<li>决定将分组导向何处</li>
<li>高速路由器的处理时延通常 &lt; msec (微秒或更低)。</li>
</ul>
</li>
<li>排队时延（queuing delay）
<ul>
<li>分组在链路上等待传输的时间</li>
<li>依赖于路由器的拥塞程度</li>
<li>时延在毫秒到微秒级别</li>
</ul>
</li>
<li>传输时延（transmission delay）
<ul>
<li>路由器将分组推出所需要的时间</li>
<li><em>L</em>：表示分组长度（bit)</li>
<li><em>R</em>: 表示链路带宽，即从路由器 A 到路由器 B 的链路传输速率（bps)。对于一条 10Mbps 的以太网链路，速率 <em>R</em>=10Mbps；对于 100Mbps 的以太网链路，速率 <em>R</em>=100Mbps。</li>
<li>传输时延 = <em>L/R</em>，通常在毫秒到微秒级别。</li>
</ul>
</li>
<li>传播时延（propagation delay）
<ul>
<li>一个比特从一台路由器向另一台路由器传播所需要的时间</li>
<li><em>d</em>: 表示物理链路的长度，即两台路由器之间的距离</li>
<li><em>s</em>: 表示链路的传播速率，取决于链路的物理媒体（即光纤、双绞铜线等）</li>
<li>传播时延=<em>d/s</em>，毫秒级别。</li>
</ul>
</li>
</ul>
<blockquote>
<p>结点时延 = 结点处理时延 + 排队时延 + 传输时延 + 传播时延。</p>
</blockquote>
<h3 id="因特网的协议栈">因特网的协议栈</h3>
<p>因特网的协议栈由 5 个层次组成：物理层(Physical)、链路层(Link)、网络层(Network)、运输层(Transport)和应用层(Application)。</p>
<ul>
<li>应用层包括许多协议，例如 HTTP, IMAP, SMTP, DNS，它们分布在多个端系统上。一个端系统中的应用程序使用应用层协议与另一个端系统中的应用程序交换信息的分组。这种位于应用层的信息分组称为报文 (message)。</li>
<li>传输层负责在端系统中的应用程序之间传输应用层的报文 (message)，传输层的协议有两个，即 TCP 和 UDP。传输层的分组称为报文段 (segment)。</li>
<li>网络层负责将称为数据报（datagram）的网络层分组从一台主机路由到另一台主机。网络层最著名的协议是 IP 协议，所以通常也被间称为 IP 层。</li>
<li>链路层的任务是在相邻的网络元素之间传输链路层分组。包括的协议有：Ethernet, 802.11 (WiFi), PPP。链路层分组称为帧。</li>
<li>物理层的任务是将帧中的一个一个比特（bit）从一个结点移动到下一个结点。</li>
</ul>
<p><img src="/images/img_201.jpg" alt="主机、路由器和链路层交换机，每个包含了不同的层，反映了不同的功能"></p>
<p>如图，数据从发送端系统（source）的协议栈一路向下，然后向上和向下经过中间的链路层交换机和路由器的协议栈，进而向上到达接收端系统（distination）的协议栈。位于下层的都会对上一层的报文进行封装，附加自己的首部信息。例如，运输层收到应用层的报文，附加上自己的首部信息构成运输层报文段。运输层报文段因此封装了应用层报文。</p>
<h2 id="二-应用层">二 应用层</h2>
<p><em>学习应用层协议的概念和实现方面的知识。</em></p>
<h3 id="应用层协议原理">应用层协议原理</h3>
<p>现代网络应用程序使用两种主流的体系结构：客户/服务器体系结构（Client/Server）和对等（P2P）体系结构。</p>
<p>在客户/服务器体系结构中，有一台总是打开的主机称为<code>服务器</code>，它服务于称为<code>客户</code>的主机的请求。一个经典的例子是 Web 应用程序，其中总是打开的专用 Web 服务器服务于浏览器（运行在客户主机上）的请求。值得注意的是利用客户/服务器体系结构，客户相互之间不直接通信，如 Web 应用程序中的两个浏览器并不之间通信。使用客户/服务器体系结构的著名的应用程序包括 Web，FTP、Telnet 和电子邮件。</p>
<p>在 P2P 体系机构中，应用程序对专用服务器的依赖很少，它在间断连接的主机对之间直接通信，这些主机对被称为对等方。因为这种对等方通信不必通过专门的服务器，该体系结构被称为对等方到对等方的。使用 P2P 体系机构的流行应用包括 BT，迅雷，Skype 和 IPTV。</p>
<hr>
<p>在操作系统的术语中，进行通信的实际上是进程（process）而不是程序。一个进程k以被认为是运行在端系统中的一个程序，网络应用程序由成对进程组成，这些进程通过跨越计算机网络交换报文而相互通信。例如，在 Web 应用程序中，一个客户浏览器进程与另一台 Web 服务器进程交换报文。在一个 P2P 文件共享系统中，文件从一个对等方中的进程传输到另一个对等方中的进程。</p>
<p>进程通过一个称为套接字（socket）的软件接口向网络发送报文和从网络接收报文。看一个类比，把进程类比于一座房子，而它的套接字可以类比于它的门。当一个进程想向位于另外一台主机上的另一个进程发送报文是，它把报文推出该门（套接字）。该发送进程假定该门到另外一侧之间有运输的基础设施，该设施将把报文传送到目的进程的门口。一旦该报文抵达目的主机，它通过接收进程的门（套接字）传递，然后接受进程对该报文进行处理。</p>
<p><img src="/images/processes-communicating.jpg" alt="进程与socket"></p>
<p>如图，套接字是同一台主机内应用程序层与传输层之间的接口。由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的 API。</p>
<hr>
<p>在一台主机上运行的进程为了向另一台主机上运行的进程发送分组，它需要知道两个信息：一是接收主机的地址，二是主机上的接收进程。在因特网中，主机由一个 32 位的 IP 地址标识，主机上运行的进程用端口号标识。例如，向一台 Web 服务器（gaia.cs.umass.edu）发送 HTTP 请求，那么发送端需要知道这台 Web 服务器的 IP 地址是 128.119.245.12，接收进程的端口号是 80。</p>
<hr>
<p>因特网为应用程序提供了两个运输层协议，即 TCP 和 UDP。它们为应用程序提供了不同的服务。</p>
<p>TCP服务包括了面向连接服务和可靠数据传输服务。当某个应用程序选择 TCP 作为运输协议时，这个应用程序就获得了 TCP 的这两种服务。</p>
<ul>
<li>面向连接的服务：在应用层数据报文开始流动之前，TCP 让客户和服务器先握手，相互交换运输层控制信息，握手之后，就在两个进程的套接字之间建立起一条 TCP 连接，这条连接是全双工的，连接双方的进程可以在此连接上同时发送和接收报文。当结束报文发送时，这条连接必须要断开。</li>
<li>可靠的数据传输服务：通信进程能够依靠 TCP，无差错、按适当顺序交付所有发送的数据。当应用程序的一端将字节流传进套接字时，它能够依靠 TCP 将相同的字节流交付给接收方的套接字，而没有字节的丢失和冗余。</li>
</ul>
<p>TCP 协议还具有拥塞控制机制，当发送方和接收方之间的网络出现拥塞时，TCP 的拥塞控制机制会抑制发送进程。</p>
<p>UDP 是一种不提供不必要服务的轻量级运输协议，它仅提供最小的服务。</p>
<ul>
<li>UDP 是无连接的，在两个进程通信前没有握手过程。</li>
<li>UDP 提供一种不可靠数据传输服务，当一个进程将报文发送进 UDP 套接字时，UDP 协议不会保证报文能到达接收进程。不仅如此，到达接收进程的报文也可能是乱序到达的。</li>
</ul>
<p>UDP 没有拥塞控制机制，发送端可以用任意速率向下层（网络层）发送数据（实际情况可能会因文中间链路的带宽限制或拥塞，端到端的吞吐量可能小于这种速率）。</p>
<hr>
<p>应用层协议 (application-layer protocol) 定义了运行在不同主机上的应用程序进程如何相互传递报文。特别是定义了：</p>
<ul>
<li>交换的报文类型，例如请求报文和响应报文。</li>
<li>各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的。</li>
<li>字段的语义，即这些字段中包含的信息的含义。</li>
<li>一个进程何时以及如何发送报文，对报文进行响应的规则。</li>
</ul>
<p>网络应用和应用层协议是有区别的。应用层协议只是网络应用的一部分，例如，Web 是一种客户/服务器应用，它允许客户按照需求从 Web 服务器获取文档。该 Web 应用有很多组成部分，包括文档格式的标准（即 HTML）、Web 浏览器（如 Firefox，Chrome）、Web server (如 Apache、Nginx），以及一个应用层协议。Web 的应用层协议是 HTTP，它定义了在浏览器和 Web 服务器之间传输的报文格式和序列。因此 <code>HTTP 协议只是 Web 应用的一个部分</code>（尽管是重要的部分）。</p>
<h3 id="http-协议">HTTP 协议</h3>
<p>Web 的应用层协议是<strong>超文本传输协议</strong>（HyperText Transfer Protocol, HTTP），它是 Web 的核心，在 [RFC 1945] 和 [RFC 2616] 中定义。</p>
<p>HTTP 由两个程序实现：一个是客户程序（称为 <strong>Web 客户</strong>，如 Firefox、Chrome）和一个服务器程序（称为 <strong>Web 服务器</strong>， 如 Apache、Nginx）。客户程序和服务器程序运行在不同的主机上，通过交换 HTTP 报文进行会话。HTTP 定义了这些报文的结构以及客户和服务器进行报文交换的方式。</p>
<p>一些 Web 术语：</p>
<blockquote>
<p>Web 页面，也叫文档，是由对象组成的。</p>
</blockquote>
<blockquote>
<p>一个对象（object) 只是一个文件，如一个 HTML 文件、一个 JPEG 图形文件，它们可以通过一个 URL 地址定位到。</p>
</blockquote>
<blockquote>
<p>每个 URL 地址有两部分组成：存放对象的服务器主机名和对象的路径名。例如：URL 地址 <a href="http://www.someSchoool.edu/someDepartment/picture.gif">http://www.someSchoool.edu/someDepartment/picture.gif</a>，其中的 <a href="https://www.someSchool.edu">www.someSchool.edu</a> 是主机名，/someDepartment/picture.gif 是路径名。</p>
</blockquote>
<p><img src="/images/http-request-response.jpg" alt="HTTP 的请求-响应行为"></p>
<p>客户和服务器的交换过程，如图所示。当用户请求一个 Web 页面（如点击一个超链接）时，浏览器向服务器发出对该页面中所包含对象的 HTTP 请求报文，服务器接收到请求并用包含这些对象的 HTTP 响应报文进行响应。</p>
<p>HTTP 使用 TCP 作为它的支撑运输协议。HTTP 客户首先发起一个与服务器的 TCP 连接。一旦连接建立，该浏览器和服务器进程就可以通过套接字接口访问 TCP。客户端的套接字是客户进程与 TCP 连接之间的门，在服务器端的套接字接口则是服务器进程与 TCP 连接之间的门。客户向它的套接字接口发送 HTTP 请求报文并从它的套接字接口接收 HTTP 响应报文。同样地，服务器从它的套接字接口接收 HTTP 请求报文和向它的套接字接口发送 HTTP 响应报文。<strong>一旦客户向它的套接字接口发送了一个请求报文，该报文就脱离了客户控制并进入 TCP 的控制</strong>。</p>
<p>HTTP 服务器不保存关于客户的任何信息，所以说 HTTP 是一个无状态协议（stateless protocol）。</p>
<p><strong>往返时间</strong>（Round-Trip Time, RTT）是指一个短分组从客户到服务，然后再返回到客户所花费的时间。RTT 包括分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理时延。</p>
<h3 id="http-报文格式">HTTP 报文格式</h3>
<p>HTTP 规范 [RFC 1945；RFC 2616] 包含了对 HTTP 报文格式的定义。HTTP 报文有两种：</p>
<ul>
<li>请求报文</li>
<li>响应报文</li>
</ul>
<p>一个典型的 HTTP 请求报文，如下：</p>
<pre tabindex="0"><code>GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agen: Mozilla/5.0
Accept-language: fr
</code></pre><p>HTTP 请求报文是 ASCII 文本，第一行叫做请求行（request line），其后的行叫做首部行（header line）。</p>
<p>请求行有 3 个字段：</p>
<ol>
<li>方法字段。方法字段的取值包括 GET、POST、HEAD、PUT 和 DELETE。绝大部分的 HTTP 请求报文时延 GET 方法。</li>
<li>URL 字段。指定请求对象的标识。</li>
<li>HTTP 版本字段。自解释的。</li>
</ol>
<p>请求报文的每一行都以回车+换行（\r\n）结束，行内的字段之间以空格隔开。首部行可以有多行，最后必须以一个空行（\r\n）表明首部行的结束。</p>
<figure><img src="/images/http-request-general-format.jpg"
         alt="一个 HTTP 请求报文的通用格式"/><figcaption>
            <p>一个 HTTP 请求报文的通用格式</p>
        </figcaption>
</figure>

<p>从 HTTP 请求报文的通用格式上，可以看到在首部行后面还有一个实体体（entity body）。在方法为 POST 时，就会用到这个实体体字段，它包含了用户在表单字段中输入的值。<strong>注意：实体体和首部行之间有一个空行（回车+换行）</strong>。</p>
<p>一个典型的 HTTP 响应报文，如下：</p>
<pre tabindex="0"><code>HTTP/1.1 200 OK
Connection: close
Date: Tue, 09 Aug 2011 15:44 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html

(data data data data ....)
</code></pre><p>HTTP 响应报文一共有三个部分，第一行是状态行（status line），其后是首部行（header line），最后是实体体（entity body）。实体体部分是报文的主要部分，它包含了所请求的对象本身（表示为 data data data data &hellip;.）。</p>
<p>状态行有 3 个字段：协议版本字段、状态码和相应状态短语。其中，状态码及其相应的短语指示了请求的结果。</p>
<p>一些常见的状态码和相关的短语：</p>
<blockquote>
<ul>
<li>200 OK: 请求成功，信息在返回的响应报文中。</li>
<li>301 Moved Permanently: 请求的对象已经被永久转移，新的 URL 定义在响应报文的 Location: 首部中。客户软件将自动获取新的 URL。</li>
<li>400 Bad Request: 一个通用差错码，指示该请求不能被服务器理解。</li>
<li>404 Not Found: 被请求的文档不在服务器上。</li>
<li>505 HTTP Version NOT Supported: 服务器不支持请求报文使用的 HTTP 协议版本。</li>
</ul>
</blockquote>
<figure><img src="/images/http-response-general-format.jpg"
         alt="一个 HTTP 响应报文的通用格式"/><figcaption>
            <p>一个 HTTP 响应报文的通用格式</p>
        </figcaption>
</figure>

<p>用 Telnet 来测试一下 HTTP:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ telnet cis.poly.edu <span style="color:#ae81ff">80</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>GET /~ross/ HTTP/1.1
</span></span><span style="display:flex;"><span>Host: cis.poly.edu
</span></span></code></pre></div><p>(在输入最后一行后连续按两次回车。）这就打开一个到主机 cis.poly.edu 的 80 端口的 TCP 连接，并发送一个 HTTP 请求报文。</p>
<h3 id="电子邮件">电子邮件</h3>
<p>因特网电子邮件系统有 3 个主要的组成部分：用户代理（user agent）、邮件服务器（mail server）和简单邮件传输协议（Simple Mail Transfer Protocol, SMTP）。</p>
<p>邮件的发送过程是：邮件从发送方的用户代理开始，传输到发送方到邮件服务器，再传输到接收方的邮件服务器，然后被分发到接收方的邮箱中（每个接收方在邮件服务器上有一个邮箱）。在发送方的邮件服务器不能将邮件传输到接收方的邮件服务器时，邮件将会被保留在发送方的邮件服务器的报文队列中等待再次发送。</p>
<p>SMTP 是因特网电子邮件中主要的应用层协议。它使用 TCP 可靠数据传输服务，从发送方的邮件服务器向接收方的邮件服务器发送邮件。SMTP 有两个部分（sides）：运行在发送方邮件服务器的客服端（client side）和运行在接收方邮件服务器的服务器端（server side）。每台邮件服务器上既运行 SMTP 的客户端也运行 SMTP 的服务器端。当一个邮件服务器向其他邮件服务器发送邮件时，它就表现为 SMTP 的客户；当邮件服务器从其他邮件服务器上接收邮件时，它就表现为一个 SMTP 的服务器。</p>
<p><img src="/images/alice-send-message-to-bob.jpg" alt=""></p>
<p>如图，从 Alice 给 Bob 发送一条报文的场景，来看 SMTP 的基本操作。</p>
<ol>
<li>Alice 用她的用户代理给 “bob@someschool.edu&quot; 撰写报文。</li>
<li>Alice 的用户代理把报文发送到她的邮件服务器，该报文被放置在报文队列中。</li>
<li>Alice 的邮件服务器上的 SMTP 客户创建一条到 Bob 的邮件服务器上的 SMTP 服务器的 TCP 连接。</li>
<li>在经过一些初始 SMTP 握手后，SMTP 客户通过这条 TCP 连接发送报文。</li>
<li>在 Bob 的邮件服务器上，SMTP 服务器端接收报文，然后将报文放入 Bob 的邮箱中。</li>
<li>Bob 用他的用户代理阅读报文。</li>
</ol>
<p>可以看到，SMTP 将一个报文从发送邮件服务器传送到接收邮件服务，分为了三个阶段：</p>
<figure><img src="/images/smtp-transfer.jpg"/>
</figure>

<ol>
<li>握手（SMTP handshaking)。客户 SMTP (运行在发送邮件服务器上) 建立一个到服务器 SMTP (运行在接收邮件服务器上) 的 TCP 连接后，服务器和客户执行<strong>应用层</strong>的握手，在握手阶段，客户指示发送方的邮件地址和接收方的邮件地址。</li>
<li>传送报文（SMTP transfer）。一旦 SMTP 客户和服务器完成握手之后，客户就发送报文。SMTP 依赖 TCP 提供的可靠数据传输服务无差错地将邮件投递到接收服务器。</li>
<li>关闭连接（SMTP closure)。客户发送完报文后，它指示 TCP 关闭连接。</li>
</ol>
<hr>
<p>一个典型的邮件报文格式，如下：</p>
<pre tabindex="0"><code>From: alice@crepes.fr
To: bob@hamburger.edu
Subject: Searching for the meaning of life.

data data data ...
</code></pre><p>一个邮件报文包含了报文首部（message header）和报文体（message body）。报文首部必须包含 <code>Form:</code> 和 <code>To:</code> 首部行。在报文首部之后，紧接着是一个空白行，然后是以 ASCII 格式表示的报文体。</p>
<hr>
<p>用户代理不能使用 SMTP 取回邮件报文，因为取报文是一个拉操作，而 SMTP 是一个推协议。所以需要引入一个邮件访问协议来解决这个问题。</p>
<p>目前流行的邮件访问协议，包括第三版邮件协议（Post Office Protocol-Version 3, POP3）、因特网邮件访问协议（Internet Mail Access Protocol，IMAP）以及 HTTP。</p>
<p>基于 Web（如 Gmail、Yahoo）收取邮件的一般采用 HTTP 协议，基于邮件客户端（如 Outlook）会采用 POP3 或 IMAP 协议。HTTP 和 IMAP 都允许用户远程在邮件服务器上创建文件夹，移动报文。</p>
<h3 id="dns-因特网的目录服务">DNS-因特网的目录服务</h3>
<p>因特网上的主机和人类一样，可以使用多种方式识别。识别主机的一个方法是用它的<strong>主机名</strong>（hostname），如 <a href="https://www.google.com">www.google.com</a>，www.facebook.com，这些名字便于人们记忆，缺点是不适用于路由器，基于此，主机也可以用 <strong>IP 地址</strong>识别。</p>
<p>域名系统（Domain Name System, DNS）的主要任务是将主机名转换为 IP 地址。DNS 是：</p>
<ul>
<li>一个由分层的 DNS 服务器（DNS server）实现的分布式数据库</li>
<li>一个使得主机能够查询分布式数据库的应用层协议。</li>
</ul>
<p>DNS 服务器通常是运行 BIND（Berkeley Internet Name Domain）软件的 UNIX 机器。DNS 协议运行在 UDP 之上，使用 53 号端口。</p>
<p>为了扩展性，DNS 使用了大量的 DNS 服务器，它们以层次结构组织，并且分布在全世界范围内。大致来说，有 3 种类型的 DNS 服务器：</p>
<ul>
<li>根 DNS 服务器（root DNS servers）。提供 TLD 服务器的 IP 地址。</li>
<li>顶级域（top-level domain，TLD) DNS 服务器。每个顶级域（如 com、org 和 net) 和所有国家的顶级域（如 uk、ca 和 fr) 都有 TLD 服务器（或服务器集群）。TLD 服务器提供了权威 DNS 服务器的 IP 地址 。</li>
<li>权威 DNS 服务器（authoritative DNS servers)。组织自己的 DNS 服务器，提供主机名到 IP 地址的映射。</li>
</ul>
<figure><img src="/images/the-hierarchy-of-dns-servers.jpg"
         alt="部分 DNS 服务器的层次结构"/><figcaption>
            <p>部分 DNS 服务器的层次结构</p>
        </figcaption>
</figure>

<p>举例说明 DNS 服务器交互的方式，假定 DNS 的客户端需要确定主机名为 <code>www.amazon.com</code> 的 IP 地址：</p>
<ul>
<li>首先，客户端查询<code>根 DNS 服务器</code>找到 .com 的 TLD 服务器的 IP 地址。</li>
<li>然后，客户端查询<code>.com TLD 服务器</code>获取 amazon.com 的权威 DNS 服务器的 IP 地址。</li>
<li>最后，客户端查询<code>amazon.com 的权威 DNS 服务器</code>获得主机名为 <a href="https://www.amazon.com">www.amazon.com</a> 的 IP 地址。</li>
</ul>
<p>在 DNS 服务器层次结构之外，还有一个重要的<strong>本地 DNS 服务器</strong>， 当主机发出 DNS 查询请求时，请求先发送到该主机的本地 DNS 服务器，本地 DNS 服务器起着代理的作用，它将请求转发到 DNS 服务器层次结构中。例如，主机 cse.nyu.edu 想知道主机 gaia.cs.umass.edu 的 IP 地址。它首先向它的本地 DNS 服务器 dns.nyu.edu 发送一个 DNS 查询报文，之后由本地 DNS 服务器将报文转发到根 DNS 服务器，在迭代查询 TLD 服务器和权威 DNS 服务器后，本地 DNS 服务器向主机 cse.nye.edu 返回 gaia.cs.umass.edu 的 IP 地址。</p>
<p>共同实现 DNS 分布式数据库的所有 DNS 服务器存储了<strong>资源记录</strong>（Resource Record, RR)。每个 DNS 回答报文包含了一个条或多条资源记录。</p>
<p>RR 的格式：(Name, Value, Type, TTL)。TTL 表示记录的生存时间，Name 和 Value 的值取决于 Type：</p>
<ul>
<li>Type=A。Name 是主机名，Value 是 IP 地址。</li>
<li>Type=NS。Name 是个域（如：foo.com），Value 是此域的权威 DNS 服务器的主机名。</li>
<li>Type=CNAME。Name 是主机别名，Value 是规范主机名（主机真实名）。</li>
<li>Type=MX。Name 是邮件服务器别名，Value 是邮件服务器规范主机名。</li>
</ul>
<p>注册一个新的域名(如：networkutopia.com)，需要：</p>
<ol>
<li>向注册登记机构提供权威 DNS 服务器的名字和 IP 地址。
<ul>
<li>假如名字和 IP 分别是 dns1.networkutopia.com, 212.212.212.1。</li>
</ul>
</li>
<li>注册登记机构将 NS 和 A 记录输入到 .com TLD 服务器
<ul>
<li>(networkutopia.com, dns1.networkutopia.com, NS)</li>
<li>(dns1.networkutopia.com, 212.212.212.1, A)</li>
</ul>
</li>
</ol>
<h2 id="三-运输层">三 运输层</h2>
<p><em>运输层的原理及这些原理在现有协议中的实现</em></p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/networking">networking</a></li>
					
				</ul>
			</nav>
			
			
		</div>
	</article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/x-29" title="GitHub"><i data-feather="github"></i></a><a class="soc" href="https://twiiter.com/x-29/" title="Twitter"><i data-feather="twitter"></i></a><a class="soc" href="https://gitlab.com/x-29/" title="GitLab"><i data-feather="gitlab"></i></a></div>
  <div class="footer-info">
    2022  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>


<script>
  feather.replace()
</script></div>
    </body>
</html>
