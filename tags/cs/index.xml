<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>cs on CS里的X-29</title>
    <link>https://x-29.github.io/tags/cs/</link>
    <description>Recent content in cs on CS里的X-29</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 19 May 2022 21:02:10 +0810</lastBuildDate><atom:link href="https://x-29.github.io/tags/cs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>深入理解计算机系统(csapp)笔记-虚拟内存</title>
      <link>https://x-29.github.io/post/2022-05-csapp-notes-ch9/</link>
      <pubDate>Thu, 19 May 2022 21:02:10 +0810</pubDate>
      
      <guid>https://x-29.github.io/post/2022-05-csapp-notes-ch9/</guid>
      <description>现代系统提供了一种对主存的抽象概念，叫做「虚拟内存（VM）」。虚拟内存提供了三个重要的能力：
 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，这相当于在主存中的是活动区域，然后根据需要从磁盘读取数据到主存或将主存数据写回到磁盘。 它为每个进程提供了一致的地址空间。 它保护了每个进程的地址空间不被其他进程破坏。  物理和虚拟寻址 计算机系统的主存被组织成一个 $M$ 个连续的字节大小的单元组成的数组。每个字节都有一个唯一的「物理地址（Physical Address，PA）。第一个字节的地址为 0，接下来的字节地址为 1，再下一个为 2，依次类推。
CPU 使用物理地址访问内存的方式称为物理寻址（physical addressing），这种寻址方式通常在单进程的简单系统中使用。比如，嵌入式微控制器、数字信号处理器。
 物理寻址
  然而，现代处理器使用「虚拟寻址（virtual addressing）」方式。
 虚拟寻址
  使用虚拟寻址，CPU 通过生成一个「虚拟地址（Virtual Address，VA）」来访问主存。这个虚拟地址在被送到主存之前先要经过「地址翻译（address translation）」转换成物理地址。地址翻译需要 CPU 硬件和操作系统相互配合，CPU 芯片上叫做「内存管理单元（Memory Management Unit，MMU）」的专用硬件，利用存放在主存中的查询表（页表）来动态翻译虚拟地址，查询表的内容由操作系统维护。
地址空间 地址空间（address space）是一个非负整数地址的有序集合。
在一个带有虚拟内存的系统中，CPU 从一个有 $N=2^n$ 个地址的地址空间中生成虚拟地址，这个地址空间称为「虚拟地址空间（virtual address space)」。一个地址空间的大小是由表示最大地址所需要的「位」数来描述的。例如，一个包含 $N=2^n$ 个地址的虚拟地址空间就叫做一个 $n$ 位地址空间。现代系统通常支持 32 位或者 64 位虚拟地址空间。
虚拟内存 概念上而言，将虚拟内存视为存储在磁盘上的 $N=2^n$ 个连续字节的数组。每个字节都有一个唯一的虚拟地址，作为到数组的索引。VM 系统将虚拟内存分割为虚拟页面（Virtual Page, VP），以虚拟页面作为传输单元，每个虚拟页面的大小为 $P=2^p$ 字节。同样地，物理内存被分割为多个物理页面（Physical Page, PP），物理页面的大小也为 $P$ 字节。
 虚拟页面往往很大，通常是 4KB～2MB。 虚拟内存页面通常缓存在物理内存中。  每个虚拟页面都可以放置在任何的物理页面中，不会有内存碎片     一个 VM 系统如何使用主存作为缓存的</description>
    </item>
    
    <item>
      <title>深入理解计算机系统(csapp)笔记-异常控制流</title>
      <link>https://x-29.github.io/post/2022-05-csapp-notes-ch8/</link>
      <pubDate>Wed, 18 May 2022 19:52:20 +0810</pubDate>
      
      <guid>https://x-29.github.io/post/2022-05-csapp-notes-ch8/</guid>
      <description>异常控制流的基本机制是用于：
 在进程和操作系统之间转移控制 在操作系统中处理 I/O 和虚拟内存 实现多进程应用程序，如 shell 和 web 服务器 实现并发  异常 异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。异常就是控制流中的突变，它将控制转移到操作系统内核，以响应某些事件（例如，处理器状态的变化）。
 内核是操作系统常驻内存的部分 异常示例：除 0，页故障，I/O 请求完成，Ctrl-C。   当处理器（CPU）检测到有事件发生时，它怎么知道要跳转到操作系统中的哪个地方呢？
答案是异常跳转表，也称为中断向量表。
 异常跳转表，其中条目 k 包含异常 k 的处理程序代码的地址
   系统中的每种类型的事件都有一个唯一的异常号 k。  一些异常号是由处理器的设计者分配的。比如，除 0、缺页、内存访问违例、断点以及算术运算溢出。 其他是由操作系统内核的设计者分配的。比如，系统调用和来自外部 I/O 设备的信号。   在系统启动时，操作系统分配和初始化异常跳转表，使得表目 k 包含异常 k 的处理程序的地址。  k 等同于异常表的索引，也称为中断向量   在运行时（当系统在执行某个程序时），处理器检测到异常编号为 k 的事件发生时，就触发异常，执行间接过程调用，跳转到 k 的处理程序。   异常跳转表的起始地址存放在一个叫做「异常表基址寄存器」的特殊 CPU 寄存器里。
 一旦硬件触发了异常，剩下的工作就是由异常处理程序在软件中完成。在异常处理程序处理完事件之后，它通过执行一条特殊的“从中断返回”指令，将适当的状态弹回到处理器的控制和数据寄存器中，可选地返回到被中断的程序，如果异常中断的是一个用户程序，就将状态恢复为「用户模式」，然后将控制返回给被中断的程序。
 异常可分为四类：
 中断（interrupt）。 陷阱（trap） 故障（fault） 终止（abort）  其中，中断是异步发生的，是来自处理器外部的 I/O设备的信号引发的。其他 3 类异常时同步发生的，是执行当前指令而引发的。这类指令叫做故障指令（faulting instruction）。</description>
    </item>
    
    <item>
      <title>深入理解计算机系统(csapp)笔记-存储器层次结构</title>
      <link>https://x-29.github.io/post/2022-05-csapp-notes-ch6/</link>
      <pubDate>Tue, 17 May 2022 15:22:10 +0810</pubDate>
      
      <guid>https://x-29.github.io/post/2022-05-csapp-notes-ch6/</guid>
      <description>存储器系统（memory system）是一个具有不同容量、成本和访问时间的存储设备的层次结构。
局部性 编写良好的计算机程序常常具有良好的局部性（locality）。也就是，程序倾向于使用地址接近或等于它们最近使用过的地址的数据和指令。有良好局部性的程序比局部性差的程序运行得更快。
局部性通常有两种不同的形式：
 时间局部性（temporal locality）。最近引用过一次的内存位置很可能在不远的将来再被多次引用。 空间局部性（spatial locality）。一个内存位置被引用了一次，那么程序很可能在不远的将来引用它相邻的内存位置。  现代计算机系统的各个层次，从硬件到操作系统、再到应用程序，它们的设计都利用了局部性。在硬件层，局部性原理允许计算机设计者通过引入小而快速的「高速缓存存储器」来保存最近被引用的指令和数据项，从而提供对主存的访问速度。
一个有良好局部性的函数：
int sumvec(int a[n]) {  int sum = 0;  for (i = 0; i &amp;lt; n; i++)  sum += a[i];  return sum; } 数据引用上，每次迭代都会重复引用 sum，所以有很好的时间局部性，同时以顺序引用模式（也称为步长为 1 的引用模式，stride-1 reference pattern）访问数组 a 的元素，因此有良好的空间局部性。
取指令上，for 循环体里的指令是按照连续的内存顺序执行的，因此循环有良好的空间局部性。又因为循环体会被执行多次，所以它也有很好的时间局部性。
一个空间局部性很差的函数：
int sum_array_cols(int a[M][N]) {  int i, j, sum = 0;   for (j = 0; j &amp;lt; N; j++)  for (i = 0; i &amp;lt; M; i++)  sum += a[i][j];  return sum; } C 数组在内存中是按照「行优先」顺序存放的，上面的函数是按照「列」顺序来扫描数组，而不是按照「行」顺序，结果就得到了步长为 N 的引用模式。步长的增大，会使得空间局部性下降。</description>
    </item>
    
    <item>
      <title>深入理解计算机系统(csapp)笔记-程序的机器级表示</title>
      <link>https://x-29.github.io/post/2022-05-csapp-notes-ch3/</link>
      <pubDate>Mon, 16 May 2022 10:12:20 +0810</pubDate>
      
      <guid>https://x-29.github.io/post/2022-05-csapp-notes-ch3/</guid>
      <description>计算机执行「机器代码」，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。
汇编代码表示非常接近于机器代码。与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。理解汇编代码以及它与原始 C 代码的联系，是理解计算机如何执行程序的关键一步。
程序编码 假设一个 C 程序，有两个文件 p1.c 和 p2.c。用下面的 Unix 命令编译这些代码：
linux&amp;gt; gcc -Og -o p p1.c p2.c 命令 gcc 指的是 GCC C 编译器，这是 Linux 上默认的编译器。
gcc 命令实际上会调用一整套的程序，将源代码转换成可执行代码。
 首先，调用「C 预处理器」扩展源代码，插入所有用 #include 命令指定的文件，并扩展所有用 #define 声明指定的宏。 其次，调用「编译器」产生两个源文件的汇编代码，名字分别为 p1.s 和 p2.s。 接下来，调用「汇编器」将汇编代码转换成二进制「目标代码」文件 p1.o 和 p2.o。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。 最后，调用「链接器」将两个目标代码文件与实现库函数的代码合并，并产生最终的「可执行」代码文件 p。可执行代码是机器代码的第二种形式。   计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，其中两种抽象尤为重要：
 由「指令集体系结构或指令集架构（Instruction Set Architecture，ISA）」来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。 机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数值。  C语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单地将内存看成一个很大、按字节寻址的数组。
 C 语言中的聚合数据类型，例如数组和结构，在机器代码中用一组连续的字节来表示。 对标量数据类型，汇编代码也不区分有符号或无符号，不区分各种类型的指针，甚至不区分指针和整数。  在 gcc 命令上使用 &amp;ldquo;-S&amp;rdquo; 选项，可以产生一个汇编文件，例如：
linux&amp;gt; gcc -Og -S mstore.</description>
    </item>
    
    <item>
      <title>深入理解计算机系统(csapp)笔记-信息的表示和处理</title>
      <link>https://x-29.github.io/post/2022-05-csapp-notes-ch2/</link>
      <pubDate>Sun, 15 May 2022 20:32:12 +0800</pubDate>
      
      <guid>https://x-29.github.io/post/2022-05-csapp-notes-ch2/</guid>
      <description>现代计算机存储和处理的信息以二值信号表示。这些微不足道的二进制数字，或者称为位（bit），形成了数字革命的基础。
三种最重要的数字表示：
 无符号（unsigned）编码基于传统的二进制表示法，表示大于或者等于零的数字。 补码（two&amp;rsquo;s-complement）编码表示有符号整数，有符号整数是可以为正或者为负的数字。 浮点数（floating-point）编码是表示实数。  计算机的这些表示法是用有限数量的位来对一个数字编码，当结果太大以至于不能表示时，某些运算就会溢出（overflow）。
信息存储 大多数计算机使用 8 位的块，或者字节（byte），作为最小的可寻址的内存单元，而不是访问内存中单独的位。
机器级程序将内存视为一个非常大的字节数组，称为虚拟内存（virtual memory）。内存的每个字节（byte）都由一个唯一的数字来标识，称为它的地址（address），所有可能地址的集合就称为虚拟地址空间（virtual address space）。
虚拟地址空间只是一个展现给机器级程序的概念性映射。实际的实现时将动态随机访问存储器（DRAM）、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。
编译器和运行时系统会将存储器空间划分为更可管理的单元，来存放不同的程序对象（program object)，即程序数据、指令和控制信息。可以用各种机制来分配和管理程序的不同部分的存储。这种管理完全是在虚拟地址空间里完成的。
 C 语言中一个指针的值（无论它指向一个整数、一个结构或是某个其他程序对象）都是某个存储块的第一个字节的虚拟地址。
 C 编译器把每个指针和类型信息联系起来，根据指针值的类型，生成不同的机器级代码来访问存储在指针所指向位置处的值。尽管 C 编译器维护着类型信息，但是它生成的实际机器级程序并不包含关于数据类型的信息。
每个程序对象可以简单地视为一个字节块，而程序本身就是一个字节序列。
 指针是 C 语言的一个重要特性。它提供了引用数据结构（包括数组）的元素的机制。与变量类似，指针也有两个方面：值和类型。它的值表示某个对象的位置，而它的类型表示那个位置上所存储对象的类型（比如整数或者浮点数）。
  十六进制表示法
 一个字节由 8 个位组成。  在二进制表示法中，它的值域是 $00000000_2$ ~ $11111111_2$。 用十进制表示，它的值域是 $0_{10}$ ~ $255_{10}$ 二进制和十进制表示法对于描述位模式来说都不非常方便。二进制表示法太冗长，十进制表示与位模式的互相转化很麻烦。代替的方法是用十六进制表示。   用十六进制数来表示位模式。  使用数字 ‘0’～‘9’ 以及字符 ‘A‘～‘F’ 来表示 16 个可能的值，即 0 ~ 15。 一个字节的值域为 $00_{16}$~$FF_{16}$     在 C 语言中，以 0x 或 0X 开头的数字常量被认为是十六进制的值。字符 &amp;lsquo;A&amp;rsquo; ~ &amp;lsquo;F&amp;rsquo; 既可以是大写，也可以是小写。</description>
    </item>
    
  </channel>
</rss>
