<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>cs on CS里的X-29</title>
    <link>https://x-29.github.io/tags/cs/</link>
    <description>Recent content in cs on CS里的X-29</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 16 May 2022 10:12:20 +0810</lastBuildDate><atom:link href="https://x-29.github.io/tags/cs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>深入理解计算机系统(csapp)笔记-程序的机器级表示</title>
      <link>https://x-29.github.io/post/2022-05-csapp-notes-ch3/</link>
      <pubDate>Mon, 16 May 2022 10:12:20 +0810</pubDate>
      
      <guid>https://x-29.github.io/post/2022-05-csapp-notes-ch3/</guid>
      <description>计算机执行「机器代码」，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。
汇编代码表示非常接近于机器代码。与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。理解汇编代码以及它与原始 C 代码的联系，是理解计算机如何执行程序的关键一步。
程序编码 假设一个 C 程序，有两个文件 p1.c 和 p2.c。用下面的 Unix 命令编译这些代码：
linux&amp;gt; gcc -Og -o p p1.c p2.c 命令 gcc 指的是 GCC C 编译器，这是 Linux 上默认的编译器。
gcc 命令实际上会调用一整套的程序，将源代码转换成可执行代码。
 首先，调用「C 预处理器」扩展源代码，插入所有用 #include 命令指定的文件，并扩展所有用 #define 声明指定的宏。 其次，调用「编译器」产生两个源文件的汇编代码，名字分别为 p1.s 和 p2.s。 接下来，调用「汇编器」将汇编代码转换成二进制「目标代码」文件 p1.o 和 p2.o。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。 最后，调用「链接器」将两个目标代码文件与实现库函数的代码合并，并产生最终的「可执行」代码文件 p。可执行代码是机器代码的第二种形式。   计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，其中两种抽象尤为重要：
 由「指令集体系结构或指令集架构（Instruction Set Architecture，ISA）」来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。 机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数值。  C语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单地将内存看成一个很大、按字节寻址的数组。
 C 语言中的聚合数据类型，例如数组和结构，在机器代码中用一组连续的字节来表示。 对标量数据类型，汇编代码也不区分有符号或无符号，不区分各种类型的指针，甚至不区分指针和整数。  在 gcc 命令上使用 &amp;ldquo;-S&amp;rdquo; 选项，可以产生一个汇编文件，例如：
linux&amp;gt; gcc -Og -S mstore.</description>
    </item>
    
    <item>
      <title>深入理解计算机系统(csapp)笔记-信息的表示和处理</title>
      <link>https://x-29.github.io/post/2022-05-csapp-notes-ch2/</link>
      <pubDate>Sun, 15 May 2022 20:32:12 +0800</pubDate>
      
      <guid>https://x-29.github.io/post/2022-05-csapp-notes-ch2/</guid>
      <description>现代计算机存储和处理的信息以二值信号表示。这些微不足道的二进制数字，或者称为位（bit），形成了数字革命的基础。
三种最重要的数字表示：
 无符号（unsigned）编码基于传统的二进制表示法，表示大于或者等于零的数字。 补码（two&amp;rsquo;s-complement）编码表示有符号整数，有符号整数是可以为正或者为负的数字。 浮点数（floating-point）编码是表示实数。  计算机的这些表示法是用有限数量的位来对一个数字编码，当结果太大以至于不能表示时，某些运算就会溢出（overflow）。
信息存储 大多数计算机使用 8 位的块，或者字节（byte），作为最小的可寻址的内存单元，而不是访问内存中单独的位。
机器级程序将内存视为一个非常大的字节数组，称为虚拟内存（virtual memory）。内存的每个字节（byte）都由一个唯一的数字来标识，称为它的地址（address），所有可能地址的集合就称为虚拟地址空间（virtual address space）。
虚拟地址空间只是一个展现给机器级程序的概念性映射。实际的实现时将动态随机访问存储器（DRAM）、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。
编译器和运行时系统会将存储器空间划分为更可管理的单元，来存放不同的程序对象（program object)，即程序数据、指令和控制信息。可以用各种机制来分配和管理程序的不同部分的存储。这种管理完全是在虚拟地址空间里完成的。
 C 语言中一个指针的值（无论它指向一个整数、一个结构或是某个其他程序对象）都是某个存储块的第一个字节的虚拟地址。
 C 编译器把每个指针和类型信息联系起来，根据指针值的类型，生成不同的机器级代码来访问存储在指针所指向位置处的值。尽管 C 编译器维护着类型信息，但是它生成的实际机器级程序并不包含关于数据类型的信息。
每个程序对象可以简单地视为一个字节块，而程序本身就是一个字节序列。
 指针是 C 语言的一个重要特性。它提供了引用数据结构（包括数组）的元素的机制。与变量类似，指针也有两个方面：值和类型。它的值表示某个对象的位置，而它的类型表示那个位置上所存储对象的类型（比如整数或者浮点数）。
  十六进制表示法
 一个字节由 8 个位组成。  在二进制表示法中，它的值域是 $00000000_2$ ~ $11111111_2$。 用十进制表示，它的值域是 $0_{10}$ ~ $255_{10}$ 二进制和十进制表示法对于描述位模式来说都不非常方便。二进制表示法太冗长，十进制表示与位模式的互相转化很麻烦。代替的方法是用十六进制表示。   用十六进制数来表示位模式。  使用数字 ‘0’～‘9’ 以及字符 ‘A‘～‘F’ 来表示 16 个可能的值，即 0 ~ 15。 一个字节的值域为 $00_{16}$~$FF_{16}$     在 C 语言中，以 0x 或 0X 开头的数字常量被认为是十六进制的值。字符 &amp;lsquo;A&amp;rsquo; ~ &amp;lsquo;F&amp;rsquo; 既可以是大写，也可以是小写。</description>
    </item>
    
  </channel>
</rss>
