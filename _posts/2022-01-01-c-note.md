---
title: C 笔记
published: true
date: 2022-01-01 10:00:00 -0000
---
## C 笔记

这是 [《Linux C编程一站式学习》](https://book.douban.com/subject/6025290/)一书的读书笔记。
### 一

程序由一系列指令组成，指令包括：

- 输出
- 输入
- 基本运算
- 测试和分支
- 循环（递归）

编写程序就是这样一个过程：
> 把复杂的任务分解成子任务，把子任务再分解成更简单的任务，层层分解，直到最后简单得可以用以上指令来完成。


- - -

一种平台就是一种体系结构，就是一种指令集，就是一种机器语言。


- - -

计算机只能执行低级语言中的指令（汇编语言的指令要先转成机器码才能执行），高级语言要执行就必须先翻译成低级语言。翻译的方式有两种：1) 编译 2）解释。

1）编译执行的过程：

`source code` --> `complier` --> `executable` -> `loader` --> `输出结果`

把源代码全部翻译成机器指令，再加上一些描述信息，生成一个可执行文件，可执行文件可以被操作系统加载运行。

2） 解释执行的过程：

`source code` --> `interpeter` --> `结果`

解释器读取源代码解释执行，程序运行的结果出现在屏幕上。

虚拟机执行过程：

`source code` --> `complier` --> `byte code` --> `interpeter` --> `结果`

- - -

编程语言是一种形式语言，是专门设计用来表达计算过程的形式语言。

形式语言有严格的语法(Syntax)规则。语法规则是由符号（Token）和结构（structure）的规则所组成。

- 关于 Token 的规则称为词法（Lexical）规则。
- 关于结构的规则称为语法（Grammar）规则。

- - -

程序中的错误叫做 Bug。找到 Bug 并加以纠正的过程叫做调试（Debug）。

程序中的 Bug 分为：

- 编译时错误
- 运行时错误
- 逻辑错误
- 语义错误


### 二

C89 是最早的C语言规范，于 1989 年提出，1990 年首先由 ANSI 推出，后来被采纳位 ISO 国际标准(ISO/IEC9899:1990)，因而有时也称为 C90。

C89 是最广泛采用的C语言标准。

C99 标准在 1999 年推出。

- - -

注释不能嵌套使用，C语言的注释符为 /* 和 */。

单行注释符 // 在 C99 中标准化。

- - -

转义序列是在编译时处理的，而转换说明是在运行时处理的。

```
printf("%d\n", a);

\n --- 转义序列
%d --- 转换说明
```

- - -

变量的类型决定了它所占有的存储空间的大小。

在C语言中用声明（Declaration）来规定变量的名字和类型。

C 语言中的声明有三种：变量声明、函数声明和类型声明。声明分为“是定义（Definition）的声明” 和 “不是定义的声明”。分配存储空间的声明同时也是定义，不分配存储空间的声明不是定义。

- - - 

理解一个概念不是把定义背下来就行了，一定要理解它的外延和内涵，也就是什么情况属于这个概念，什么情况下不属于这个概念，什么情况虽然属于这个概念，但一般推荐的做法（Best practice）是要尽量避免这种情况，这才算是真正理解了。

- - -

定义一个变量，就是分配一块存储空间并给它命名；给一个变量赋值，就是把一个值保存到这块存储空间中。

变量一定要先声明后使用，这样编译才知道如何读写这块存储空间。

变量的定义和赋值可以一步完成，这称为变量的初始化。初始化是一种特殊的声明，而不是一种赋值语句。

变量的最小存储单元是字节（Byte）。

- - -

任何表达式都有值和类型两个基本属性。

等号（=）左边的表达式要求表示一个存储位置，而不是一个值。

表达式所表示的存储位置称为左值（lvalue），允许放在等号（=）左边，如变量就是可以做左值。


## 三

> 在运用逻辑推理时一定要注意，不要把必要条件当充要条件。

函数调用也是一种表达式。

log(1.0) 这个表达式是由操作数 log 和函数调用运算符 () 括号组成。

函数调用运算符是一种后缀运算符，() 括号及其中的参数是操作数 log 的后缀。

操作数 log 是一个函数名，它的类型是一种函数类型 (Function Type)。

- - -

C 标准主要由两部分组成，一部分描述 C 的语法，另一部分描述 C 标准库。

C 标准库定义来一组标准头文件，每个头文件中包含一些相关的函数、变量、类型声明和宏定义。要在一个平台上支持 C 语言，不仅要实现 C 编译器，还要实现 C 标准库，这样的实现才算符号 C 标准。

在 Linux 平台上最广泛使用的 C 函数库是 glibc, 其中包括 C 标准库的实现，也包括系统函数。

- - -

main 函数的返回值是返回给操作系统的，因为 main 函数是被操作系统调用的。

- - -

函数的定义：返回值类型  函数名(参数列表)  函数体。

非定义的函数声明：返回值类型  函数名(参数列表)。

- - -

形参相当于函数中定义的变量，调用函数传递参数的过程相当于定义形参变量并且用实参的值来初始化。

- - -

每次调用函数时，局部变量都表示不同的存储空间。

局部变量在每次函数调用时分配空间，在每次函数返回是释放存储空间。

全局变量定义在函数体之外，在程序运行时分配存储空间，在程序结束时释放存储空间。

局部变量会覆盖全局变量。

局部变量可以用类型相等的任意表达式来初始化，全局变量只能用常量表达式来初始化。

局部变量在定义时不初始化，则初始值是不确定的，所以局部变量在使用之前一定要先赋值。


## 四

语句块中的变量和函数的局部变量作用域不同。

整数除法运算要向 0 取整：5 / 2 = 2。

% 运算符的结果总是与被除数同号。

C 语言规定，else 总是和它上面最近的一个 if 配对。

在 C 语言中通常用 int 型来表示布尔类型: 非 0 表示真，0 表示假。

- - - 

函数返回一个值相当于定一个和返回值类型相同的临时变量并用 return 后面的表达式来初始化。

函数的返回值不是左值，或者说函数调用表达式不能做左值。

- - -

封装就是为了服用。把解决各种小问题的代码封装成函数，在解决第一个大问题时可以用这些函数，在解决第二个大问题时可以复用这些函数。

解决问题的过程是把大问题分解成小问题，小问题在分解更小的问题。这个过程在代码中体现为函数的分层设计：

- 底层函数解决很小的问题。
- 上层函数调用底层函数来解决更大的问题。

- - -

如果定义一个概念需要用到这个概念本身，我们称它的定义是递归的。

自己直接或间接调用自己的函数称为递归函数。

递归函数的正确性可以用数学归纳法来证明，证明：

- 1）Base case 正确
- 2）递推关系正确

写递归函数时一定要记得写 Base Case，否则即使递推关系正确，整个函数也不正确。

递归和循环是等价的，用循环能做的事用递归都能做，反之亦然。

> 递归是计算机的精髓所在，也是编程语言的精髓所在。

- - -

每次调用函数时分配参数和局部变量的存储空间，退出函数是释放它们的存储空间。

函数参数和局部变量的存储空间在栈上分配。

每个函数调用的参数和局部变量的存储空间称为一个栈帧（Stack Frame）。

操作系统为程序的运行预留了一块栈空间，函数调用是就在这个栈空间里分配栈帧，函数返回时就释放栈帧。


## 五、六、七

如果把 ++i 这个表达式看作一个函数调用，除了传入一个参数，返回一个值（等于参数值加 1）之外，还产生一个 Side Effect，就是把变量 i 的值增加了 1。

如果把 i++ 这个表达式看作一个函数调用，传入一个参数返回一个值，返回值就等于参数值（而不是参数值加 1），此外也产生一个 Side Effect，就是把变量 i 的值增加了 1。

- - -

学习一门编程语言是要特别注意三个方面：

1. 这门语言提供了哪些 Primitive，比如基本运算符、表达式和语句, 基本类型。
2. 这门语言提供了哪些组合规则，比如基本类型如何组合成复合类型。
3. 这门语言提供了哪些抽象机制，包括数据抽象和过程抽象。

## 八

数组（Array）也是一种复合数据类型，它由一系列相同类型的元素组成。

和结构体相似，数组元素的存储空间也是相邻的。

定义一个由 4 个 int 型元素组成的数组 count：
```
int count[4];
```
数组下标的表达式不仅可以表示存储单元的值，也可以表示存储单元本身，就是说可以做左值，如：
```
count[0] = 7;
count[1] = count[2] * 2;
++count[2];
```

- - -

在 C 语言中，后缀运算符的优选级最高，单目运算符次之。

- - -

数组不能相互赋值或初始化，也不能用数组类型作为函数的参数或返回值。

- - -

数组类型做右值，自动转换成指向数组首元素的指针。

在函数原型中，如果参数写成数组的形式，则该参数实际上是指针类型。

- - -

define 定义是在预处理阶段处理，而枚举是在编译阶段处理的。

- - -

NULL 表示空指针。

- - -

字符串字面值和数组类型相似，它的每个元素是字符型的。

每个字符串末尾都有一个字符‘\0’做结束符。\0 是 ASCII 码中的 Null 字符。

字符串字面值所代表的存储空间是只读的，不允许修改。
```
"Hello"[0] = 'A'     (x)
```

字符串字面值做右值使用时，自动转换成指向首元素的指针。

- - -

字符数组可以用一个字符串字面值来初始化，如：
```
char str[10] = "Hello";
```
str 的后 4 个元素没有指定，自动初始化为 '\0'，即 Null 字符。

> 写代码最重要的是选择正确的数据结构来组织信息，设计控制流程和算法尚在其次，只要数据结构选择正确，其他代码自然而然就变得容易理解和维护了。

一个数组的元素可以是另一个数组，这样就构成了多维数组。

定义并初始化一个二维数组：

```
int a[3][2] = {1, 2, 3, 4, 5};
```
数组 a 有 3 个元素：a[0]、a[1]、a[2]。每个元素也是一个数组，例如 a[0] 是一个数组，它有两个元素 a[0][0]、a[0][1]，这两个元素的类型是 int，值分别是 1, 2。

*概念模型*
```
   |  0    1
---|---------
0  |  1    2
1  |  3    4
2  |  5    0
-------------
```
从概念模型上看，这个二维数组是三行两列的表格，元素的两个下标分别是行号和列号。

*物理模型*

```
 a[0][0]  a[0][1]  a[1][0]  a[1][1]  a[2][0]  a[2][1]
-------------------------------------------------------
|   1   |    2    |   3   |   4    |   5    |    0    |
-------------------------------------------------------
```

从物理模型上看，这 6 个元素在存储器中仍然是连续存储的。

## 九

编码风格

- 用 tab 缩进，tab 最好设成是 8 个空格的长度。
- 函数内的注释要尽可能少用。写注释主要是为了说明代码“能做什么”，比如函数接口定义，而不是为了说明“怎么做”，只要代码写得足够清晰，“怎么做”是一目了然的。
- 复杂的结构体定义比函数更需要注释。
- 标识符命名
  - 变量、函数采用全小写加下划线的方式命名
  - 常量（比如宏定义和枚举常量）采用全大写加下划线的方式命名。
- 每个函数都应该设计得尽可能简单，实现一个函数只是为了做好一件事情。
- 执行函数就是执行一个动作，函数名通常应包含动词。

## 十二

> 算法 + 数据结构 = 程序

数据结构（Data structure）是数据的组织方式。

一个问题中数据的存储方式和访问方式就决定了解决问题可以采用什么样的算法，要设计一个算法就要同时设计相应的数据结构来支持这种算法。

- - -

堆栈是一种数据结构，它的特点是 LIFO（后进先出）。

堆栈有两个操作：push 和 pop

push 称为入栈，向栈顶添加元素。pop 称为出栈，取出当前栈顶的元素。

还有一个栈顶指针，总是指向栈顶的下一个元素。

- - -

深度优先搜索（DFS）的特点：每次探索完各个方向相邻的点之后，取其中一个相邻的走下去，一直走到无路可走了再退回来，取另一个相邻的点再走下去。

- - -

有什么样的数据结构就决定了可以用什么样的算法，同样，有什么样的算法就决定了可以用什么样的数据结构。设计算法和设计数据结构这两件工作是紧密联系的。

- - -

队列，有两个基本操作:

- Enqueue（入队），将元素添加到队尾。
- Dequeue（出队），从队头取出元素并返回。

有两个指针：

- head，总是指向队头。
- tail, 总是指向队尾的下一个元素。

特点：FIFO（先进先出）。

- - -

广度优先搜索（BFS）的特点是：沿各个方向同时展开搜索，每个可以走通的方向轮流往前走一步。

## 十三

计算机是用数字电路搭成的，数字电路只有 1 和 0 两种状态，所以计算机使用二进制是最自然的计数方式。

不管用哪种计数方式，数的大小并没有变，十进制的 1 + 1 等于 2，二进制的 1 + 1 等于 10，二进制的 [10] 和 十进制的 2，大小是相等的。

- - -

计算机采用逻辑电路计算两个 bit（位）的加法。

逻辑电路有门电路和导线组成，同一条导线上在某一个时刻的电压值只能是高和低两种状态之一，分别用 1 和 0 表示。

导线的电压值进入门电路的输入端，经过逻辑运算后在门电路的输出端输出运算结果的电压值。

任何复杂的加减乘除运算都可以分解成简单的逻辑运算。

- - -

XOR（异或），两个操作数相同则结果为 0，两个操作数不同则结果为 1。

- - -

对于一个二进制数（A3A2A1A0），最左边的 A3 位称为最高位（Most significant Bit，MSB），最右边的 A0 位称为最低位（Least Significant Bit，LSB）。

- - -

二进制小数：(0.A1A2A3...)2 = A1 x 2-1 + A2x2-2 + A3 x 2-3 + ...

- - -

八进制，十六进制是程序员为了书写二进制数方便而发明的简便写法。

- - -

计算机的加法器在做完计算之后，根据最高位产生的进位设置进位标志，同时，根据最高位和次高位产生的进位的异或（XOR）设置溢出标志。至于这个加法到底是有符号加法还是无符号加法则取决于程序怎么理解了（C语言支持无符号数和有符号数，Java 语言只支持有符号数）。

## 十四

> C 标准的理论基础之一：优先考虑效率，可移植性在其次。

不带 signed 或 unsigned 关键字的 char 型是无符号数还是有符号数，是由实现来定义的（Implementation Defined），在 x86 平台的 gcc 定义有符号的。

C 语言与平台和编译器是密不可分的。

在 C 标准中没有明确规定的地方会用 Implementation-defined、Unspecified 或 Undefined 来表述。

- Implementation-defined，要求编译器必须对此做出明确规定，并写在编译器的文档中。
- Unspecified，编译器可以任意选择一种处理方式，不必写在编译器文档中，同一个编译器不同的版本选择的处理方式可以不同。
- Undefined，C 标准没规定怎么处理，也没规定运行的结果对不对，编译器很可能也没规定，比如数组访问越界就是 undefined  的。

- - -

对于有符号数在计算机中的表示，C 标准没有明确规定，也就是 Implementation Defined。大多数体系结构都采用补码表示法。

C 标准明确规定，除了 char 型以外的整型类型如果不明确写 signed 或 unsigned 关键字都表示 signed。

除了 char 型在 C 标准中明确规定占一个字节之外，其他整型占几个字节都是 Implementation-Defined。通常编译器实现遵守 ILP32 或 LP64 规范。

- ILP32 的意思是 int（I）、long（L）和指针（P）类型都占 32 位。32 位计算机的 C 编译器采用这种规范。
- LP64 是指 long（L）和指针（P）占 64 位。64 位计算机的 C 编译器采用这种规范。

- - -

指针类型的长度总是和计算机的位数一致。因为指针变量存储的是内存单元的地址，每个内存单元的地址长度是由计算机的字长决定的。

- - -

整数常量的类型（在 c 头文件 limits.h 中）

```
#define    INT_MAX      2147483647
#define    INT_MIN      (-INT_MAX - 1) 
```
写成（-INT_MAX - 1）是因为补码表示的不对称性和 C 语言的转换规则之间奇怪的交互。虽然 -2147483648 这个数值能够用 int 表示，但在 C 语言中却没法写出对应这个数值的 int 常量，C 编译器会把它当成一个整数常量 2147483648 和一个负号（-）运算符组成的表达式，而整数常量 2147483648 已经超出了 int 型的取值范围，写成 -2147483647 - 1 这样减号（-）运算符的两个操作数都是 int 型，计算结果也应该是 int 型，并且它的值也没有超出 int 型的取值范围。

- - -

C 标准规定中，既没有规定浮点型类型占多少字节，也没规定采用哪种表示形式。

大部分平台的浮点数实现遵循 IEEE 754，float 型通常是 32 位，double 型通常是 64 位。

浮点数在计算机中的表示是基于科学计数法的：
```
V = (-1)^s x M x 2^E

M: 尾数
E：指数
s: 符号，=0 表示正，=1 表示负
```

- - -

C 语法规则中最复杂的是类型转换。（P181)

## 十五

位运算 &、｜、^ 运算符都是要做 Usual Aritchetic Conversion 的（其中有一步是 Integer Promotion）。

～ 运算符也要做 Integer Promotion。

位运算符的操作数必须是整型。

- - -

在一定的取值范围内，将一个整数左移 1 位，相当于乘以 2。比如：二进制 [11]（十进制 3）左移一位变成 [110]，就是 6，在左移一位变成 [1100]，就是 12。

在一定的取值范围内，将一个整数右移 1 位，相当于除以 2，小数部分截掉。

- - -

操作数是有符号数时，右移运算的规则：

- 如果时正数，那么高位移入 0。
- 如果时负数，那么高位移入 1 还是 0 不一定，这是 Implementation-defined 的。对于 x86 平台的 gcc 编译器，最高位移入 1，也就是仍保持负数的符号位。这种处理方式对负数仍然保持了“右移 1 位相当于除以 2”的性质。（注：算术右移）。

建议只对无符号数做位运算，以减少出错的可能。

- - -

要对一个整数中的某些位进行操作，可以用*掩码*来表示这些位在整数中的位置。

例如：
```
1. 取出 8 ～ 15 位
（0x12345678 & 0x0000ff00) >> 8           /* 0x00000056 */

2. 将 8 ～ 15 位清 0
  0x12345678 & ～0x0000ff00                /* 12340078 */
```

- - -

一个数和自己做异或的结果是 0，即 x ^ x = 0。

- - -

a += 1 相当于 a = a + 1。( 表达式 a += 1，a 是求值一次；表达式 a = a + 1，a 求值两次。)

++i 相当于 i = i + 1。更准确说等价于 i += 1。

- - -

x ^ x ^ y == y

- - -

sizeof 表达式

sizeof(类型名)

这两种形式都是求类型所占的字节数。

例如：
```
1.
sizeof i++ 
求表达式 i++ 的类型所占的字节数。表达式 i++ 不会求值，sizeof 是在编译时计算。

2.
sizeof(int)
求 int 类型的字节数。
```

sizeof 运算符的结果是 size_t 类型。

C 标准规定 size_t 是一种无符号整型。

不同平台的编译器可能会根据自己平台的具体情况定义 size_t 所代表的类型，C 标准规定 size_t 这个名字就是为了隐藏这些细节，使代码具有可移植性。

- - -

typedef  关键字用于给某种类型起一个新的名字。

例：typedef unsigned long size_t；

这样 size_t 就是一个类型名，代表 unsigned long 类型，可以这样使用：`size_t y;`

- - -

类型名通常加个 _t 后缀表示 Type。

- - -

`||` 操作符，左操作数的值为 1 时，就不再求右操作数的值。

`&&` 操作，在左操作数的值为 0 时，就不再求右操作数的值。

- - -

异或运算的一些特性：

- 一个数和自己做异或的结果是 0。x86 平台的编译器可能会生成这样的指令：`XORL %eax, %eax`。不管 eax 寄存器里的值原来是多少，做异或运算都能得到 0，这条指令比同样效果的 movl $0, %eax 指令快。
- 不管 0 还是 1，和 0 做异或保持原值不变；和 1 做异或得到原值的相反值。
- 如果 a1 ^ a2 ^ a3 ... ^ aN 的结果是 1，则表示当中 1 的个数为奇数个，否则为偶数个。这条性质可用于奇偶校验。
- x ^ x ^ y == y，因为 x ^ x = 0，0 ^ y == y。这个性质可以用来不借助额外的存储空间交换两个变量的值，例如：

```
a = a ^ b;
b = b ^ a;
a = a ^ b;
```

- - -

为避免出现野指针，在定义指针变量是，应该给它明确的初值，或者把它初始化为 NULL。
```
int *p = NULL;
```
NULL 在标准库的头文件 stddef.h 中定义：
```
#define NULL ((void *)0)
```
就是把地址 0 转换成指针类型，称为空指针。它的特殊之处在于操作系统不会把任何数据保存在地址 0 及其附近，也不会把地址 0 ~ 0xfff 的页面映射到物理内存，所以任何对地址 0 的访问都会立即导致段错误。

## 十六

> All problems in compute science can be solved by another level of indirection.

现代计算机都是基于 Von Nenumann 体系结构。主要特点是：CPU 和内存是计算机的两个主要组成部分。内存中保存着数据和指令，CPU 从内存中取指令执行。

- - -

每个内存单元有一个地址，内存地址是从 0 开始编号的整数，CPU 通过地址找到相应的内存单元，取其中的指令或者读写其中的数据。

一个地址所对应的内存单元不能存很多东西，只能存*一个字节*。像 int、float 等多字节的数据类型保存在内存中要*占用连续的多个地址*，这种情况下数据的地址是它所占内存单元的起始地址。

- - -

> CPU 总是周而复始地做同一件事：从内存取指令，然后解释执行它，然后再取下一条指令，在解释执行。

CPU 最核心的功能单元包括：

- 寄存器（Register）。是 CPU 内部的高速存储器，像内存一样可以存取数据，但比访问内存快得多。
- 程序计数器（PC）。是一种特殊寄存器，保存着 CPU 取下一条指令的地址，CPU 按程序计数器保存的地址去内存中取指令然后解释执行，这时程序计数器保存的地址会自动加上该指令的长度，指向内存中的下一条指令。
- 指令译码器。CPU 取上来的指令由若干个字节组成，指令译码器负责解释它们的含义，然后调动相应的执行单元去执行它。
- 算术逻辑单元（ALU）。负责运算，比如加减乘除、位运算、逻辑运算。如果译码器将一条指令解释为运算指令，就调用算术逻辑单元去做运算。
- 地址和数据总线（Bus）。CPU 和内存之间同地址总线、数据总线和控制总线连接起来，每条线上有 1 和 0 两种状态。
	- 地址线、数据线和 CPU 寄存器的位数通常是一致的，比如 64 位。
	- 这里所说的地址线、数据线是指 CPU 的内总线，是直接和 CPU 的执行单元相连的，内总线经过 MMU 和总线接口的转换之后引出到芯片引脚才是外总线。
	- 外地址线和外数据线的位数都有可能和内总线不同。

- - -

从 CPU 的角度来看，访问设备只有内存映射 I/O 和端口 I/O 两种，要么像内存一样访问，要么用一种专用的指令访问。

计算机的设备五花八门，各种设备的要求都不一样，于是出现了各种适应不同要求的设备总线，比如 PCI、USB、SATA等，这些设备总线并不直接和 CPU 相连，CPU 通过内存映射 I/O 或端口 I/O 访问相应的总线控制器，通过总线控制器再去访问挂在总线上的设备。

- - -

x86 平台上，硬盘是挂在 IDE、SATA 或 SCSI 总线上的设备，保存在硬盘上的程序是不能被 CPU 直接取指令执行的。

- - -

操作系统在执行程序时会把它从硬盘拷贝到内存，这样 CPU 才能取指令执行，这个过程称为*加载（Load）*。

程序加载到内存之后，成为操作系统调度执行的一个任务，就成为*进程（process）*。

操作系统本身也是一段保存在磁盘上的程序，计算机在启动时执行一段固定的启动代码（称为 Boot loader）首先把操作系统从磁盘加载到内存，然后执行操作系统中的代码把用户需要的其他程序加载到内存。

操作系统是常驻内存的。

操作系统最核心的功能是管理进程调度、管理内存的分配使用和管理各种设备，做这些工作的程序称为内核（Kernel）。

- - -

内存只是保存数据而不会产生新的数据，如果 CPU不去读它，它也不需要主动提供数据给 CPU。

- - -

设备需要主动通知 CPU 来读数据。

每个设备都有一条中断线，通过中断控制器连接到 CPU，当设备需要主动通知 CPU 是就引发一个中断信号，CPU 正在执行的指令将被打断，程序计数器会指向某个固定的地址（由体系结构定义），于是 CPU 从这个地址开始取指令（或者说跳转到这个地址），执行中断服务程序（Interrupt Service Routine，ISR），完成中断处理之后再返回先前被打断的地方执行后续指令。

每个设备都需要专门的设备驱动程序。设备驱动程序通常是内核里的一个组函数，有些设备还要提供一个中断处理函数供 ISR 调用。

- - -

现代操作系统普遍采用虚拟内存管理（Virtual Memory Management）机制，这需要 CPU 中的 MMU（Memory Management Unit，内存管理单元）提供支持。

- - -

如果 CPU 没有 MMU，或者有 MMU 但没有启用，CPU 执行单元发出的内存地址将直接传到芯片引脚上，被内存芯片接收，这称为物理地址（Physical Address，PA）。

如果 CPU 启用了 MMU，CPU 执行单元发出的内存地址将被 MMU 截获，从 CPU 到 MMU 的地址称为虚拟地址（Virtual Address，VA），而 MMU 将这个地址翻译成另一个地址发到 CPU 芯片的外部地址引脚上，也就是将 VA 映射成 PA。

- - -

以 32 位 CPU 为例，则内地址总线是 32 位的，与 CPU 执行单元相连，而经过 MMU 转换之后的外地址总线则不一定是 32 位的。也就说虚拟地址空间和物理地址空间是独立的，32 位 CPU 的虚拟地址空间是 4GB，而物理地址空间既可以大于也可以小于 4GB。

- - -

MMU 将 VA 映射到 PA 是以页（Page）位单位的。

32 位 CPU 的页尺寸通常是 4KB（2^12）.

例：MMU 可以通过一个映射项将 VA 的一页 0xb7001000 ~ 0xb7001fff 映射到 PA 的一页 0x2000 ~ 0x2fff，如果 CPU 执行单元要访问虚拟地址 0xb7001008，则实际访问到的物理地址是 0x2008。

- - -

物理内存中的页称为物理页面或者页帧（Page Frame）。

虚拟内存的哪个页面映射到物理内存的哪个页帧是通过页表（Page table）来描述的，页表保存在物理内存中（页表由操作系统管理维护），MMU 会查找页表来确定一个 VA 应该映射到什么 PA。

- - -

程序中使用的地址都是虚拟地址，都会引发 MMU 做查表和地址转换操作。

- - -

操作系统可以在页表中设置每个内存页面的访问权限，当 CPU 要访问一个 VA 时，MMU 会检查 CPU 当前处于用户模式还是特权模式，访问内存的目的是读数据，写数据还是取指令，如果和操作系统设定的页面权限相符，就允许访问，把它转换成 PA，否则不允许访问，产生一个异常（Exception）。

- - -

操作系统把虚拟地址空间划分为`用户空间`和`内核空间`。

例如 x86 平台的 Linux 系统虚拟地址空间是 0x00000000 ~ 0xffffffff，前 3GB（0x00000000 ~ 0xbfffffff）是用户空间，后 1GB（0xc0000000 ~ 0xffffffff）是内核空间。

- - -

在正常情况下 CPU 在用户模式执行用户程序，在中断或异常产生时 CPU 切换到特权模式执行内核程序，处理完中断或异常之后，再返回用户模式继续执行用户程序。

- - -

对于多字节的整数类型，低地址保存的是整数的低位，这称为小端（Little Endian）字节序列（Byte order）。

x86 平台是小端字节序列的。

低地址保存整数的高位，称为大端（Big Endian）字节序列。

- - -

硬盘、内存、CPU 寄存器、Cache 在计算机中这些都是存储器，计算机把存储器分成若干级，称为 `Memory Hierarchy`。按照离 CPU 由近到远的顺序依次是 CPU 寄存器、Cache、内存、硬盘，越是靠近 CPU 的存储器容量越小，但访问速度越快。

- `CPU 寄存器`，位于 CPU 执行单元中。“寄存器” 这个名字是一种数字电路的名字，它由一组触发器（Flip-flop）组成，每个触发器保存一个 bit 的数据，可以做存取和移位等操作。计算机掉电时寄存器中保存的数据会丢失。
- `Cache`，和 MMU一样位于 CPU 核中。Cache 通常分为几级，一级靠近 CPU 执行单元，二级更靠近物理内存。Cache 和内存都是由 RAM（Random Access Memory）组成的，可以根据地址随机访问，计算机掉电时 RAM 中的数据会丢失。
	- Cache 由 SRAM（Static RAM，静态 RAM）组成。
	- 内存由 DRAM （Dynamic RAM，动态 RAM）组成。DRAM 电路简单，存储容量可以做得更大，但访问速度比 SRAM 慢。

Cache  缓存最近访问过的内存数据。一级 Cache 时这样工作的：CPU 执行单元要访问内存时首先发出 VA，Cache 利用 VA 查找相应的数据有没有被缓存，如果 Cache 中有就不需要访问物理内存了，如果是读操作就直接将 Cache 中的数据传给 CPU 寄存器，如果是写操作就直接改写到 Cache 中；如果 Cache 没有缓存该数据，就去物理内存中取数据，但并不是要哪个字节取哪个字节，而是把相邻的几十个字节都取上来缓存着，以备下次用到，这称为一个 Cache Line。典型的 Cache Line 大小是 32 ～ 256 字节。如果计算机还配置了二级缓存，则在访问物理内存之前先用 PA 去二级缓存中查找。
	- 一级 Cache 用 VA 寻址的，二级 Cache 是用 PA 寻址的。
	- Cache 所做的工作是由硬件自动完成的，不是由指令来决定的。
- 内存，位于 CPU 外的芯片，与 CPU 通过地址总线和数据总线相连。内存是通过地址来访问的，在启用 MMU 的情况下，程序指令中的地址是 VA，而访问内存用的是 PA，它们之间的映射关系（页表）由操作系统维护。

