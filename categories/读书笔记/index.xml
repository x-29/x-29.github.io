<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>读书笔记 on CS里的X-29</title>
    <link>https://x-29.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 读书笔记 on CS里的X-29</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 26 May 2022 13:38:20 +0800</lastBuildDate><atom:link href="https://x-29.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>The Pragmatic Programmer 笔记</title>
      <link>https://x-29.github.io/post/2022-05-the-pragmatic-programmer-notes/</link>
      <pubDate>Thu, 26 May 2022 13:38:20 +0800</pubDate>
      
      <guid>https://x-29.github.io/post/2022-05-the-pragmatic-programmer-notes/</guid>
      <description>这是《程序员修炼之道 第2版》一书的读书笔记。
 编程是一项艰难的工作
 你不应该拘泥于任何特定的技术，而应该拥有足够广泛的背景和经验基础，以便在特定的情况下选择合适的解决方案。你的背景来自对计算机科学基本原理的理解，而你的经验来自广泛的实际项目。
务实的程序员共有的特征：
 喜欢尝试。接触到新事物，能很快地掌握并应用起来。 好奇。倾向于问问题。 批判性的思考者。没有得到证实前很少接受既定的现实。 现实主义。试图理解面临的每个问题的本质。 多面手。熟悉各种技术和环境。 关注技艺。技艺人，不关注自己的技艺怎么能做好技艺活呢。   一  人生是你的，是你在拥有、经营和创造。
 工作环境很糟糕？工作很无聊？尝试纠正它。
想远程工作？要求过了吗？
你有选择权，人生是你的。
 责任意味着你对某事积极认同。
承担责任，做出承诺之前，必须分析超出你控制范围的风险情况，如果责任不清，抑或风险过大，你有权不承担责任。
承担责任意味着你将承接相关义务。
 犯了错误或是做出了错误的判断，诚实的承认它，并尝试给出选择 不要把问题归咎于别人或其他什么事情上，也不要寻找借口 不要说搞不定，解释一下要做什么才能挽回局面  意识到自己在说“我不知道”时，一定要接着说“&amp;mdash;但是我会去搞清楚”。
不要搁置“破窗”（糟糕的设计、错误的决定、低劣的代码），每发现一个就赶紧修一个。
不要只是因为一些东西非常紧急，就去造成附带损害。
破窗一扇都嫌太多。
构建知识组合，并对知识组合做定期投资。
读非技术书。你做的事情是为了满足人的需要。
批判性地分析你读到和听到的东西。
 问“五个为什么”。有了答案后，还要追问“为什么” 谁从中受益。追踪金钱的流动更容易理清脉络 有什么背景。每件事都有它发生的背景。 什么时候在哪里可以工作起来。是在什么情况下？太晚了嘛？不要停留在一阶思维下（接下来会发生什么），要进行二阶思考：它结束后还会发生什么？ 为什么是这个问。是否存在一个基础模型？这个基础模型是怎么工作的？  把母语看成另一门编程语言，像写代码一样用自然语言写文章：尊重 DRY 原则、ETC、自动化。
想说什么之前问一下自己：“这是否用正确的方式向我的听众传达了我想表达的东西？”
记下你想要沟通的想法，并准备多个让对方理解的策略。
听他们说。你不听他们的，他们也不会听你的。
回应别人。让人感觉到你并没有忘记他们。
二  ETC（Easier To Change，更容易变更），对代码而言，就是要顺应变化。
 无论什么设计原则，都是 ETC 的一个特例。e.g，解耦，单一职责原则。
价值观是帮助你做决定的：应该做这个，还是做那个？在软件领域思考时，ETC 是一个向导，它能帮助你在不同的路线中选出一条。ETC 是一种价值观念，不是一条规则。
 DRY&amp;mdash;不要重复自己
 DRY 针对的是你对知识和意图的复制。它强调的是，在两个地方表达的东西其实是相同的，只是表达方式有可能完全不同。</description>
    </item>
    
    <item>
      <title>计算机网络(Computer Networking)笔记(二)</title>
      <link>https://x-29.github.io/post/2022-05-computer-networking-notes-part2/</link>
      <pubDate>Wed, 25 May 2022 08:59:38 +0800</pubDate>
      
      <guid>https://x-29.github.io/post/2022-05-computer-networking-notes-part2/</guid>
      <description>这是《计算机网络自顶向下方法 第6版》一书的读书笔记的第二部分。
第一部分
四 网络层 网络层怎样实现主机到主机的通信服务？
 在网络中的每一台主机和路由器中都有一个网络层。
 转发和路由 网络层的作用是将分组从一台发送主机转移到一台接收主机。为此，需要两种重要的网络功能：
 转发。将分组从路由器的输入链路移动到相应的输出链路。转发发生的时间尺度很短（通常为几纳秒），通常用硬件实现。 路由选择。决定分组从源到目的地的路由或路径。路由选择发生的时间尺度长一些（通常为几秒），通常用软件实现。计算路径的算法称为路由选择算法。  用驾驶的例子类比，转发就像是通过单个立交桥的过程：驾驶员驾车从道路上进入立交桥的一个入口，并决定应当从哪个出口离开立交桥。路由选择可以看作是规划行程的过程：在开启行程之前，驾驶员查阅地图并在许多可能的路径中选择一条，其中每条路径都是由一系列经立交桥连接的路段组成。
 每台路由器中都有一张本地转发表（forwarding table）。路由器检查到达分组首部的一个或多个字段值，进而使用这些首部值在其转发表中索引查询。转发表中对应的表项指出了该分组将被转发的路由器的输出链路接口。
如图，一个首部值字段值为 0111 的分组到达路由器。路由器在它的转发表中索引，并确定该分组的输出链路接口是接口 2。然后路由器在内部将分组转发到接口 2。
网络服务模型  网络服务模型（networ service model）定义了分组在发送与接收端系统之间的端到端运输特性。
 因特网的网络层提供了单一的服务，即尽力而为服务（best-effort service）。使用尽力而为服务：
 既不能保证传送的分组以它们发送的顺序被接收，也不能保证它们最终交付。 既不能保证端到端时延，也不能保证有最小的带宽。   分组交换机是指一台通用分组交换设备，它根据分组首部字段中的值，从输入链路接口到输出链路接口转移分组。分组交换机主要有两类：
 链路层交换机（link-layer switches）。基于链路层字段中的值做转发决定。 路由器（router）。基于网络层字段中的值做转发决定。  路由器工作原理  路由器体系结构
  如上图，一台路由器由 4 个部分组成：
 输入端口（input ports） 交换结构（switching fabric） 输出端口（output ports） 路由选择处理器（routing processor）  路由器的输入端口、输出端口和交换结构几乎总是用硬件实现。它们共同实现了转发功能。
1. 输入端口
 输入端口处理
  输入端口的线路端接（line termination）功能与链路层处理（link-layer processing）实现了用于各个输入链路的物理层和链路层。</description>
    </item>
    
    <item>
      <title>计算机网络(Computer Networking)笔记(一)</title>
      <link>https://x-29.github.io/post/2022-05-computer-networking-notes/</link>
      <pubDate>Mon, 23 May 2022 23:56:18 +0800</pubDate>
      
      <guid>https://x-29.github.io/post/2022-05-computer-networking-notes/</guid>
      <description>这是《计算机网络自顶向下方法 第6版》一书的读书笔记的第一部分。
第二部分
一 计算机网络和因特网 从整体上粗线条地勾画出计算机网络地概貌。
因特网 因特网是一个世界范围地计算机网络，即它是一个互联了遍及全世界地数以亿计的计算机设备的网络。这些设备包括传统的桌面 PC、Linux 工作站已经现在的智能手机、平板电脑、游戏机、家用电器等，我们称之为主机（host）或端系统（end system）
 端系统 (end system) 通过通信链路 (communication link) 和分组交换机（packet switch）连接到一起。通信链路根据物理媒体组成可以分为铜轴电缆、铜线、光纤和无线电频谱。不同的链路以不同的速率传输数据，链路的传输速率以 bit/s 度量（或者 bps）。 一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节。由此形成的信息包称为分组 (packet）。这些分组通过网络发送到目的端系统。 分组交换机从它的一条入通信链路接收到达的分组，并从它的一条出通信链路转发该分组。交换机主要有两类：路由器（router）和链路层交换机（link-layer switch）。  从发送端系统到接收端系统，一个分组（packet）所经历的一系列通信链路和分组交换机称为该网络的路径(route 或 path)。   端系统、分组交换机和其他因特网部件都要运行一系列协议（protocol），这些协议控制因特网中信息的接收和发送。  e.g，TCP，IP，HTTP，Skype，802.11   因特网的标准由 IETF（Internet Engineering Task Force）研发。  IETF 的标准文档称为 RFC（Request For Comment）。    因特网也可以被看作为应用程序提供服务的基层设施，应用程序可以是 Web，Email，电子商务等。应用程序只需调用端系统提供的 API，就可通过因特网进行数据传输。
协议 协议（protocol）定义了在两个或多个通信实体之间交换的报文格式和次序，以及报文发送和/或接收一条报文或其他事件所采取的动作。
因特网广泛地使用了协议，不同的协议用于完成不同的通信任务。
因特网的部件：网络边缘、接入网和网络核心 端系统也称为主机，位于因特网的边缘。
 主机被进一步划分为客户端（client）和服务器（server）。客服端通常是桌面 PC、移动 PC和智能手机等；而服务器是更为强大的机器，用于存储和发布 Web 页面、流视频等，如今，通常用于大型数据中心（data center）。  接入网是指端系统连接到其边缘路由器（edge router）的物理链路。</description>
    </item>
    
    <item>
      <title>C 笔记</title>
      <link>https://x-29.github.io/post/2022-05-c-notes/</link>
      <pubDate>Mon, 23 May 2022 14:49:25 +0800</pubDate>
      
      <guid>https://x-29.github.io/post/2022-05-c-notes/</guid>
      <description>这是 《Linux C编程一站式学习》一书的读书笔记。
一 程序由一系列指令组成，指令包括：
 输出 输入 基本运算 测试和分支 循环（递归）  编写程序就是这样一个过程：
 把复杂的任务分解成子任务，把子任务再分解成更简单的任务，层层分解，直到最后简单得可以用以上指令来完成。
  一种平台就是一种体系结构，就是一种指令集，就是一种机器语言。
 计算机只能执行低级语言中的指令（汇编语言的指令要先转成机器码才能执行），高级语言要执行就必须先翻译成低级语言。翻译的方式有两种：1) 编译 2）解释。
1）编译执行的过程：
source code &amp;ndash;&amp;gt; complier &amp;ndash;&amp;gt; executable -&amp;gt; loader &amp;ndash;&amp;gt; 输出结果
把源代码全部翻译成机器指令，再加上一些描述信息，生成一个可执行文件，可执行文件可以被操作系统加载运行。
2） 解释执行的过程：
source code &amp;ndash;&amp;gt; interpeter &amp;ndash;&amp;gt; 结果
解释器读取源代码解释执行，程序运行的结果出现在屏幕上。
虚拟机执行过程：
source code &amp;ndash;&amp;gt; complier &amp;ndash;&amp;gt; byte code &amp;ndash;&amp;gt; interpeter &amp;ndash;&amp;gt; 结果
 编程语言是一种形式语言，是专门设计用来表达计算过程的形式语言。
形式语言有严格的语法(Syntax)规则。语法规则是由符号（Token）和结构（structure）的规则所组成。
 关于 Token 的规则称为词法（Lexical）规则。 关于结构的规则称为语法（Grammar）规则。   程序中的错误叫做 Bug。找到 Bug 并加以纠正的过程叫做调试（Debug）。
程序中的 Bug 分为：</description>
    </item>
    
  </channel>
</rss>
